[
    {
      "llmstxt": "# https://docs.ts.injective.network/ llms.txt\n\n- [Injective SDK Documentation](https://docs.ts.injective.network/): Comprehensive guide for developers on Injective SDK usage.\n- [Injective Technical Concepts](https://docs.ts.injective.network/getting-started/technical-concepts): Essential technical concepts for efficient dApps development on Injective.\n- [Injective Token Factory](https://docs.ts.injective.network/getting-started/application-concepts): Explore Injective's Token Factory for creating and swapping tokens.\n- [Calculations Overview](https://docs.ts.injective.network/getting-started/application-concepts/calculations): Explore calculations for number representation on the chain.\n- [Min Price Tick Size](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-price-tick-size): Understanding minimum price tick size calculations for markets.\n- [Minimum Quantity Tick Size](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-quantity-tick-size): Understanding minimum quantity tick size for order prices.\n- [Injective Networks Overview](https://docs.ts.injective.network/getting-started/application-concepts/networks): Explore Injective's public networks and endpoints for dApps.\n- [Injective with CosmJS](https://docs.ts.injective.network/getting-started/application-concepts/getting-started-cosmjs): Learn to use Injective with @injectivelabs packages effectively.\n- [Injective Asset Types](https://docs.ts.injective.network/getting-started/assets): Overview of asset types and token metadata on Injective.\n- [Creating Tokens on Injective](https://docs.ts.injective.network/getting-started/assets/creating-tokens): Easily create and manage tokens on Injective platform.\n- [Token Metadata and Denom Client](https://docs.ts.injective.network/getting-started/assets/denom-client): Guide for using TokenFactory and DenomClientAsync in Injective.\n- [Injective Token Metadata](https://docs.ts.injective.network/getting-started/assets/injective-list): Comprehensive guide for integrating Injective token metadata.\n- [Injective TS Examples](https://docs.ts.injective.network/getting-started/running-examples): Learn to run examples using Injective TS library.\n- [Injective Wallet Overview](https://docs.ts.injective.network/wallets/wallet): Injective wallet integration with Ethereum and Cosmos accounts.\n- [Injective Wallet Accounts](https://docs.ts.injective.network/wallets/wallet-accounts): Learn to manage Injective accounts and address conversions.\n- [Wallet Connections Guide](https://docs.ts.injective.network/wallets/wallet-connections): Connect Ethereum and Cosmos wallets to Injective easily.\n- [Injective Wallet Strategies](https://docs.ts.injective.network/wallets/wallet-wallet-strategy): Explore wallet strategies for Injective blockchain integration.\n- [Sign and Verify Data](https://docs.ts.injective.network/wallets/offchain-arbitrary-data): Learn to sign and verify arbitrary data using Keplr.\n- [Querying Injective Data](https://docs.ts.injective.network/querying/querying): Access Injective chain and Indexer API data easily.\n- [Querying Chain Data](https://docs.ts.injective.network/querying/querying-chain): Explore various modules for querying chain data effectively.\n- [Query Auction Module](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auction-module): Learn to query the auction module using gRPC methods.\n- [Querying Auth Module](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module): Learn how to query the auth module on Injective.\n- [Querying Bank Module](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module): Learn to query bank module data using gRPC and HTTP.\n- [Querying Chain Distribution](https://docs.ts.injective.network/querying/querying-chain/querying-chain-distribution): Learn to query chain distribution data using gRPC API.\n- [Querying Chain Exchange](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange): Learn how to query exchange module on Injective chain.\n- [Querying Chain Governance](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance): Learn how to query governance data on Injective chain.\n- [Querying IBC Data](https://docs.ts.injective.network/querying/querying-chain/querying-chain-ibc): Learn to query IBC data using gRPC methods.\n- [Querying Mint Module](https://docs.ts.injective.network/querying/querying-chain/querying-chain-mint): Learn to query mint module using gRPC API examples.\n- [Querying Insurance Funds](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds): Learn to query insurance funds on the Injective chain.\n- [Querying Chain Oracle](https://docs.ts.injective.network/querying/querying-chain/querying-chain-oracle): Learn to query the chain using the oracle API.\n- [Querying Peggy API](https://docs.ts.injective.network/querying/querying-chain/querying-chain-peggy): Learn to query Peggy API using gRPC methods.\n- [Querying Chain Permissions](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions): Example code snippets for querying chain permissions data.\n- [Querying Chain Staking](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking): Explore various methods to query staking data on Injective.\n- [Querying Chain Data](https://docs.ts.injective.network/querying/querying-chain/querying-chain-tendermint): Learn to query chain data using Tendermint API.\n- [Querying Injective WASM](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm): Learn how to query the Injective chain's WASM module.\n- [Querying wasmX Module](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasmx): Learn to query the wasmX module using gRPC API.\n- [Token Factory Queries](https://docs.ts.injective.network/querying/querying-chain/token-factory): Learn to query token factory data using gRPC API.\n- [Querying Injective API](https://docs.ts.injective.network/querying/querying-api): Comprehensive guide for querying various modules in Injective.\n- [Querying Indexer Account](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account): Learn how to query indexer account data effectively.\n- [Querying Auction Data](https://docs.ts.injective.network/querying/querying-api/querying-indexer-auction): Learn how to query auction data using gRPC API.\n- [Querying Derivatives API](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives): Learn to query derivatives data using gRPC and REST.\n- [Indexer Explorer API](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer): Explore Injective's API for querying indexer data effectively.\n- [Querying Insurance Funds](https://docs.ts.injective.network/querying/querying-api/querying-indexer-insurance-funds): Learn to query insurance funds using gRPC API.\n- [Querying Indexer Markets](https://docs.ts.injective.network/querying/querying-api/querying-indexer-markets): Learn how to query indexer markets using API.\n- [Indexer Leaderboard API](https://docs.ts.injective.network/querying/querying-api/querying-indexer-leaderboard): Learn to query the indexer leaderboard using API.\n- [Mito API Querying](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito): Explore Mito API for vault data querying and management.\n- [Querying Oracle Data](https://docs.ts.injective.network/querying/querying-api/querying-indexer-oracle): Learn to query oracle data using gRPC API examples.\n- [Querying Indexer Portfolio](https://docs.ts.injective.network/querying/querying-api/querying-indexer-portfolio): Learn to query portfolio data using gRPC API.\n- [Querying Spot Market](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot): Example code snippets for querying spot market data.\n- [Querying Indexer Transactions](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction): Example code snippets for querying indexer transactions using gRPC.\n- [Streaming Data Modules](https://docs.ts.injective.network/querying/querying-api/streaming): Learn how to stream data from various modules.\n- [Streaming Subaccount Balance](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-account): Learn to stream subaccount balance using gRPC API.\n- [Streaming Auction Data](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-auction): Learn to stream auction data using gRPC API.\n- [Streaming Derivatives API](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives): Learn to stream derivatives data using gRPC API.\n- [Streaming Oracle Prices](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-oracle): Learn to stream oracle prices using gRPC API.\n- [Streaming Indexer Portfolio](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-portfolio): Learn to stream portfolio data using gRPC API.\n- [Streaming Spot Market](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot): Example code snippets for streaming spot market data.\n- [Streaming Indexer Explorer](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-explorer): Learn to stream data from the indexer using gRPC.\n- [Querying Ethereum Data](https://docs.ts.injective.network/querying/querying-ethereum): Learn to query Ethereum data using GraphQL examples.\n- [Injective Transactions Guide](https://docs.ts.injective.network/transactions/transactions): Learn to create, sign, and broadcast transactions on Injective.\n- [Transaction Flow Overview](https://docs.ts.injective.network/transactions/transactions-cosmos): Detailed guide on preparing, signing, and broadcasting transactions.\n- [Ledger with Keplr](https://docs.ts.injective.network/transactions/transactions-cosmos/ledger-through-keplr-wallet): Guide for using Ledger with Keplr wallet on Injective.\n- [Ethereum Transaction Flow](https://docs.ts.injective.network/transactions/ethereum): Detailed guide on preparing, signing, and broadcasting Ethereum transactions.\n- [Signing Injective Transactions](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger): Learn to sign Injective transactions using Ledger device.\n- [MsgBroadcast Overview](https://docs.ts.injective.network/transactions/msgbroadcaster): Easily broadcast transactions on Injective using MsgBroadcast.\n- [Signing Transactions with PrivateKey](https://docs.ts.injective.network/transactions/private-key): Learn to sign transactions using a PrivateKey on Injective.\n- [Web3 Gateway Overview](https://docs.ts.injective.network/transactions/web3-gateway): API for gasless transactions and fee delegation on Injective.\n- [Injective Core Modules](https://docs.ts.injective.network/core-modules-and-examples/core-modules): Explore Injective chain core modules and transaction examples.\n- [INJ Auction Module](https://docs.ts.injective.network/core-modules-and-examples/auction): Auction module for INJ bids and burn mechanism.\n- [Authz Module Overview](https://docs.ts.injective.network/core-modules-and-examples/authz): Authorization module for granting and managing account privileges.\n- [Bank Module Overview](https://docs.ts.injective.network/core-modules-and-examples/bank): Manage multi-asset transfers and account balances securely.\n- [Staking Rewards Management](https://docs.ts.injective.network/core-modules-and-examples/distribution): Withdraw staking rewards and validator commissions easily.\n- [Injective Exchange Module](https://docs.ts.injective.network/core-modules-and-examples/exchange): Decentralized trading on Injective Chain with various order types.\n- [Feegrant Module Overview](https://docs.ts.injective.network/core-modules-and-examples/feegrant): Feegrant module enables accounts to grant fee allowances.\n- [Injective Governance](https://docs.ts.injective.network/core-modules-and-examples/governance): Participate in Injective governance by submitting proposals.\n- [IBC Coin Transfer](https://docs.ts.injective.network/core-modules-and-examples/ibc): Transfer coins between Injective and Cosmos chains via IBC.\n- [Injective Insurance Module](https://docs.ts.injective.network/core-modules-and-examples/insurance): Insurance module for derivative markets on Injective Chain.\n- [Injective Peggy Module](https://docs.ts.injective.network/core-modules-and-examples/peggy): Injective Ethereum bridge for fund transfers and withdrawals.\n- [Permissions Module Overview](https://docs.ts.injective.network/core-modules-and-examples/permissions): Manage namespaces, roles, and permissions in Injective ecosystem.\n- [Token Factory Module](https://docs.ts.injective.network/core-modules-and-examples/token-factory): Create and manage tokens on the Injective blockchain easily.\n- [Injective WASM Module](https://docs.ts.injective.network/core-modules-and-examples/wasm): Explore wasm module for Injective smart contracts and examples.\n- [CosmWasm Smart Contracts](https://docs.ts.injective.network/smart-contracts/contracts): Explore CosmWasm smart contracts and specific implementations.\n- [Injective Name Service](https://docs.ts.injective.network/smart-contracts/contracts/injective-name-service): Learn to query Injective Name Service contracts effectively.\n- [Neptune Service Tool](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service): Tool for interacting with Neptune smart contracts on Injective.\n- [CW20 to Bank Token Conversion](https://docs.ts.injective.network/smart-contracts/contracts/cw20-convert-and-market-order-example): Guide to convert CW20 tokens to bank tokens for market orders.\n- [Injective Cross-Chain Bridges](https://docs.ts.injective.network/bridges/bridge): Explore Injective's cross-chain bridges for financial applications.\n- [Injective Ethereum Bridge](https://docs.ts.injective.network/bridges/ethereum): Trustless Ethereum to Injective token bridge for ERC-20 transfers.\n- [IBC Bridges Overview](https://docs.ts.injective.network/bridges/ibc): Explore IBC bridges for seamless blockchain connectivity.\n- [Wormhole Bridge Overview](https://docs.ts.injective.network/bridges/wormhole): Explore the Wormhole bridge for cross-chain interactions.\n- [Building DApps on Injective](https://docs.ts.injective.network/building-dapps/building-dapps): Build decentralized finance applications on Injective blockchain.\n- [Configuring Nuxt3 for DApps](https://docs.ts.injective.network/building-dapps/configuring-nuxt): Guide to configure Nuxt3 for decentralized applications.\n- [Configuring React for DApps](https://docs.ts.injective.network/building-dapps/configuring-react): Guide to configure React with Injective for DApps.\n- [Injective dApps Examples](https://docs.ts.injective.network/building-dapps/dapps-examples): Explore various dApps examples built on Injective platform.\n- [Building dApps on Injective](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract): Learn to build dApps on Injective with smart contracts.\n- [Build a DEX](https://docs.ts.injective.network/building-dapps/dapps-examples/dex): Learn to build a DEX on Injective easily.\n- [DApps Examples](https://docs.ts.injective.network/building-dapps/dapps-examples/bridge): Explore examples of building decentralized applications on Injective.\n- [Simple HTML Example](https://docs.ts.injective.network/building-dapps/dapps-examples/simple-html-example-with-webpack): Clone, run, and understand a simple HTML example with Webpack.\n",
      "llmsfulltxt": "# https://docs.ts.injective.network/ llms-full.txt\n\n<|firecrawl-page-1-lllmstxt|>\n## Injective SDK Documentation\n**Supported Node Versions** **\\> 18.x**\n\n**Stable Package Version**\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fsdk-ts%2Flatest%3Flabel%3D%2540injectivelabs%252Fsdk-ts&width=768&dpr=4&quality=100&sign=950c8f54&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fwallet-ts%2Flatest%3Flabel%3D%2540injectivelabs%252Fwallet-ts&width=768&dpr=4&quality=100&sign=6c5e096a&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fnetworks%2Flatest%3Flabel%3D%2540injectivelabs%252Fnetworks&width=768&dpr=4&quality=100&sign=c58d5ede&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fts-types%2Flatest%3Flabel%3D%2540injectivelabs%252Fts-types&width=768&dpr=4&quality=100&sign=6e0e493e&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Futils%2Flatest%3Flabel%3D%2540injectivelabs%252Futils&width=768&dpr=4&quality=100&sign=6d1bd526&sv=2)\n\n**Latest Package Versions:**\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fsdk-ts%2Fnext%3Flabel%3D%2540injectivelabs%252Fsdk-ts&width=768&dpr=4&quality=100&sign=3653dcea&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fwallet-ts%2Fnext%3Flabel%3D%2540injectivelabs%252Fwallet-ts&width=768&dpr=4&quality=100&sign=ac080a4&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fnetworks%2Fnext%3Flabel%3D%2540injectivelabs%252Fnetworks&width=768&dpr=4&quality=100&sign=dfdce87c&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fts-types%2Fnext%3Flabel%3D%2540injectivelabs%252Fts-types&width=768&dpr=4&quality=100&sign=16b86dac&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Futils%2Fnext%3Flabel%3D%2540injectivelabs%252Futils&width=768&dpr=4&quality=100&sign=608e1fc4&sv=2)\n\n_**Note:**_ _The latest versions are published using the_ `next` _tag. For stable versions use the_ `latest` _tag or check npm registry for the latest stable version._\n\nThe purpose of this Wiki is to help developers build decentralized applications on top of Injective. Let's dive a bit deeper into each section and explain its purpose so its easier to get the bigger picture.\n\n_Note: Reading the Technical Concepts section after reading the overview below is highly recommended. There are some concepts that can have a bit steeper learning curve than others, so we recommend going through them to understand a bit more about Injective._\n\n- [Wallets](https://docs.ts.injective.network/wallets/wallet) \\- In this section, we are going to explain (in technical terms) how Accounts are derived on Injective, how you can connect your wallet straight from the dApp itself, and finally have a look at the **WalletStrategy** \\- a package built by the InjectiveLabs team which offers out of the box solution for providing multiple wallet solutions to the user to connect and interact with your dApp.\n\n- [Querying](https://docs.ts.injective.network/querying/querying) \\- In this section we are going to explore different ways to obtain data from different data sources needed to build your dApps. First, we are going to see how to query the chain directly and then we are going to explore the Indexer API - an indexer solution for easier data access/streaming including historical data.\n\n- [Transaction](https://docs.ts.injective.network/transactions/transactions) \\- In this section, we are going to explore different ways to make transactions on Injective. First, we are going to explain (in technical terms) how Transactions work on Injective and some technical concepts around them and then we are going to have a look at how to prepare, sign, and broadcast transactions on Injective in several ways. There are a couple of ways to do this.\n\n\n\n1. Using the Cosmos native approach in creating a transaction, sign it using a **Cosmos native wallet** and broadcast it to Injective,\n\n2. Using the Ethereum native approach in creating a transaction using EIP712 typed data, sign it using an **Ethereum native wallet** and broadcast it to Injective,\n\n3. Using the Ethereum native approach in creating a transaction using EIP712 typed data, sign it using a **Ledger device** and broadcast it to Injective,\n\n4. Using the Cosmos native approach in creating a transaction, sign it using a **raw PrivateKey** and broadcast it to Injective,\n\n5. Using the Web3Gateway microservice - an API that provides fee delegation services.\n\n\n- [Core Modules](https://docs.ts.injective.network/core-modules-and-examples/core-modules) \\- In this section we are going to have a quick summary of the core modules on Injective and show examples of how to create some Messages (+ pack them into a transaction, sign them using a private key, and broadcast them on Injective) within these core modules.\n\n- [Bridge](https://docs.ts.injective.network/bridges/bridge) \\- In this section, we are going to have a look at Injective's interoperability and explain how developers can utilize the Peggy bridge and the IBC bridge to bridge assets over to Injective.\n\n- [Networks](https://docs.ts.injective.network/getting-started/application-concepts/networks) \\- In this section, we will look at different (pre-defined) available Networks for developers to utilize while building dApps on top of Injective, allowing them to start building without the need to make their own infrastructure.\n\n- [Calculations](https://docs.ts.injective.network/getting-started/application-concepts/calculations) \\- In this section, we will look at different calculations formula converting values between UI human-readable and chain format.\n\n\n**Deprecated Packages:**\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fbridge-ts%2Flatest%3Flabel%3D%2540injectivelabs%252Fbridge-ts&width=768&dpr=4&quality=100&sign=10187282&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fcontracts%2Flatest%3Flabel%3D%2540injectivelabs%252Fcontracts&width=768&dpr=4&quality=100&sign=1e66bc86&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Fsdk-ui-ts%2Flatest%3Flabel%3D%2540injectivelabs%252Fsdk-ui-ts&width=768&dpr=4&quality=100&sign=b98e3776&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%2Ftoken-utils%2Flatest%3Flabel%3D%2540injectivelabs%252Ftoken-utils&width=768&dpr=4&quality=100&sign=88f1eba&sv=2)\n\n![](https://docs.ts.injective.network/~gitbook/image?url=https%3A%2F%2Fimg.shields.io%2Fnpm%2Fv%2F%2540injectivelabs%252Ftoken-metadata%2Flatest%3Flabel%3D%2540injectivelabs%252Ftoken-metadata&width=768&dpr=4&quality=100&sign=751ac8e4&sv=2)\n\n[NextTechnical Concepts](https://docs.ts.injective.network/getting-started/technical-concepts)\n\nLast updated 5 months ago\n\n<|firecrawl-page-2-lllmstxt|>\n## Injective Technical Concepts\nLearning these concepts can help you be a more efficient dApps developer on top of Injective. We'll keep the explanations brief so only the necessary context is shared with the reader. We encourage developers to explore these concepts more thoroughly at their own convenience.\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/technical-concepts\\#sentry-node)    Sentry Node\n\nSentry node is a read-only full node running the Injective chain. A full node is a server running a chain's binary (its software) that fully validates transactions and blocks of a blockchain and keeps a full record of all historic activity. A full node is distinct from a pruned node that processes only block headers and a small subset of transactions. Running a full node requires more resources than a pruned node. Validators can decide to run either a full node or a pruned node, but they need to make sure they retain enough blocks to be able to validate new blocks.\n\nWe query the sentry node to get on-chain data served on our decentralized application.\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/technical-concepts\\#indexer-api)    Indexer API\n\nThe Indexer API is a collection of microservices that serve data indexed from the Injective chain. The Injective Chain emits events when a transaction is included and there is an event listener within the Indexer API that listens for these events, processes them, and stores the data in a MongoDB. Querying the chain directly is an expensive (and less performant) API call than querying an API serving data from a MongoDB which is why the Indexer API exists.\n\nAnother benefit of using the Indexer API is streaming. MongoDB can stream updates in the collections/documents which can be quite beneficial for a nice user experience. This way we don't need to poll for the data, instead, we can subscribe for a stream and update the state of our dApp on updates broadcasted within the stream.\n\nFinally, the Indexer API can serve historical data or processed data over a period of time (ex: for drawing charts, etc).\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/technical-concepts\\#transactions)    Transactions\n\nLearn more about making transactions on Injective [here](https://docs.ts.injective.network/getting-started/technical-concepts#transactions).\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/technical-concepts\\#trading-account)    Trading Account\n\nSubaccounts or Trading Accounts are a concept that allows you to decouple the funds in the native Injective Bank module (which can be used for staking, bidding on auctions, participating in governance, creating markets, etc) into an isolated trading account from which you can execute trades. One Injective address can have an unlimited number of trading accounts. The way they are represented is `${ethereumAddress}${subaccountNonce}` where the `ethereumAddress` is the `hex` version of the `bech32` Injective address and the `subaccountNonce` is the nonce represented in 12 bytes. An example trading account at nonce 1 would be `0xc7dca7c15c364865f77a4fb67ab11dc95502e6fe000000000000000000000001`.\n\nStarting the v1.10.0 chain upgrade, the Bank balance and the default trading account (at nonce = 0) will be merged and the Bank funds will be directly used when executing trades originating from the default trading account.\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/technical-concepts\\#grpc-and-protobuf)    gRPC & Protobuf\n\ngRPC is a modern open-source high-performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking, and authentication. It is also applicable in the last mile of distributed computing to connect devices, mobile applications, and browsers to backend services.\n\nProtobuf is the most commonly used IDL (Interface Definition Language) for gRPC. It's where you basically store your data and function contracts in the form of a proto file.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nmessage Person {\n    required string name = 1;\n    required int32 id = 2;\n    optional string email = 3;\n}\n```\n\n[PreviousOverview](https://docs.ts.injective.network/) [NextApplication Concepts](https://docs.ts.injective.network/getting-started/application-concepts)\n\nLast updated 5 months ago\n\n<|firecrawl-page-3-lllmstxt|>\n## Injective Token Factory\nIn this section we are going to explain some application (Injective) specific concepts.\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/application-concepts\\#token-factory)    Token Factory\n\nThe Token Factory module on Injective which allows users and contracts to create new native tokens and swap native tokens with CW20 tokens using the Mint + Burn model. This is an important feature to have on chain because representing assets from different sources to a native bank denom is crucial to allow users to access the rest of the on-chain modules like exchange, auction, insurance funds, etc. The token factory denoms are in the following format `factory/{creator address}/{subdenom}`.\n\nCombined with the `CW20AdapterContract` which acts as a creator, we allow CW20 assets to be natively represented on Injective as Token Factory denoms. The way it works is that CW20 assets are held by the `CW20AdapterContract` and minted as a factory denom for the injective address and when we want to redeem them back to CW20, they are burned from the bank module and unlocked from the `CW20AdapterContract` back to the owner address.\n\nExample on how to redeem a factory denom to CW20:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgExecuteContractCompat,\n  ExecArgCW20AdapterRedeemAndTransfer,\n} from '@injectivelabs/sdk-ts'\n\nconst CW20_ADAPTER_CONTRACT = 'inj...'\nconst contractCw20Address = 'inj...'\nconst injectiveAddress = 'inj...'\n\nconst message = MsgExecuteContractCompat.fromJSON({\n  sender: injectiveAddress,\n  contractAddress: CW20_ADAPTER_CONTRACT,\n  funds: {\n    denom: `factory/${CW20_ADAPTER_CONTRACT}/${contractCw20Address}`,\n    amount: actualAmount.toFixed(),\n  },\n  execArgs: ExecArgCW20AdapterRedeemAndTransfer.fromJSON({\n    recipient: injectiveAddress,\n  }),\n})\n\n// Then pack the message in a transaction, sign it and broadcast to the chain\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/application-concepts\\#example-on-how-to-convert-cw20-to-a-factory-denom)    Example on how to convert CW20 to a factory denom:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  ExecArgCW20Send,\n  MsgExecuteContractCompat,\n} from '@injectivelabs/sdk-ts'\n\nconst CW20_ADAPTER_CONTRACT = 'inj...'\nconst contractCw20Address = 'inj...'\nconst injectiveAddress = 'inj...'\nconst amount = '1000000' // 1 USDT represented as on the chain as it has 6 decimals\n\nconst message = MsgExecuteContractCompat.fromJSON({\n  contractAddress: contractCw20Address,\n  sender: injectiveAddress,\n  execArgs: ExecArgCW20Send.fromJSON({\n    amount,\n    contractAddress: CW20_ADAPTER_CONTRACT,\n  }),\n})\n\n// Then pack the message in a transaction, sign it and broadcast to the chain\n```\n\n[PreviousTechnical Concepts](https://docs.ts.injective.network/getting-started/technical-concepts) [NextCalculations](https://docs.ts.injective.network/getting-started/application-concepts/calculations)\n\nLast updated 3 months ago\n\n<|firecrawl-page-4-lllmstxt|>\n## Calculations Overview\nIn this page we are going to look through some calculations and formatting to understand better about how numbers are represented on the chain vs how we are showing them on the UI.\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/application-concepts/calculations\\#tick-sizes)    Tick Sizes\n\nTopic\n\nDescription\n\n[Market min price tick size](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-price-tick-size)\n\nMinimum market order price tick size\n\n[Market min quantity tick size](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-quantity-tick-size)\n\nMinimum market order quantity tick size\n\n[PreviousApplication Concepts](https://docs.ts.injective.network/getting-started/application-concepts) [NextMin Price Tick Size](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-price-tick-size)\n\nLast updated 1 year ago\n\n<|firecrawl-page-5-lllmstxt|>\n## Min Price Tick Size\nThe min market price tick size for an order price - if a market has an minPriceTickSick of `0.001` and order submission with the price of `0.0011` will be rejected.\n\nNote that calculating the formula for calculating a spot and quote market price tick size are different.\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-price-tick-size\\#spot-market)    Spot market\n\n1. UI human readable to chain format: Using INJ/USDT market which has 18 base decimals and 6 quote decimals as an example, here's how we convert the value to the chain format:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst chainFormat = new BigNumberInBase(10)\n  .pow(quoteDecimal - baseDecimal)\n  .times(value)\n  .toFixed()\n```\n\n1. Chain format to UI human readable format: Using INJ/USDT market which has 18 base decimals and 6 quote decimals as an example, here's how we convert the value to the UI human readable format:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst humanReadableFormat = new BigNumber(value)\n  .shiftedBy(baseDecimals - quoteDecimals)\n  .toFixed()\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-price-tick-size\\#derivative-market)    Derivative market\n\n1. UI human readable to chain format: Using INJ/USDT perp market which has 6 quote decimals as an example, here's how we convert the value to the chain format:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst chainFormat = new BigNumberInBase(10)\n  .pow(-quoteDecimal)\n  .times(value)\n  .toFixed()\n```\n\n1. Chain format to UI human readable format: Using INJ/USDT perp market which has 6 quote decimals as an example, here's how we convert the value to the UI human readable format:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst humanReadableFormat = new BigNumber(value)\n  .shiftedBy(-quoteDecimals)\n  .toFixed()\n```\n\n[PreviousCalculations](https://docs.ts.injective.network/getting-started/application-concepts/calculations) [NextMin Quantity Tick Size](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-quantity-tick-size)\n\nLast updated 1 year ago\n\n<|firecrawl-page-6-lllmstxt|>\n## Minimum Quantity Tick Size\nThe min market quantity tick size for an order price - if a market has an minQuantityTickSize of `0.001` and order submission with the quantity of `0.0011` will be rejected.\n\nNote that derivate markets shares the same format for minQuantityTickSize between UI and the chain, so no formatting is required.\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-quantity-tick-size\\#spot-market)    Spot market\n\n1. UI human readable to chain format: Using on a INJ/USDT market which has 18 base decimals and 6 quote decimals as an example, here's how we convert the value to the chain format:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst chainFormat = new BigNumberInWei(value).toBase(baseDecimals)\n```\n\n1. Chain format to UI human readable format: Using INJ/USDT market which has 18 base decimals and 6 quote decimals as an example, here's how we convert the value to the UI human readable format:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst humanReadableFormat = new BigNumber(minQuantityTickSize)\n  .shiftedBy(-baseDecimals)\n  .toFixed()\n```\n\n[PreviousMin Price Tick Size](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-price-tick-size) [NextNetworks](https://docs.ts.injective.network/getting-started/application-concepts/networks)\n\nLast updated 1 year ago\n\n<|firecrawl-page-7-lllmstxt|>\n## Injective Networks Overview\nUp-to-date public Endpoints can be found [here](https://docs.injective.network/develop/public-endpoints/#mainnet). We **do not recommend** using them in production for applications having high usage/traffic. There are thousands of developers using the public infrastructure and we cannot promise 100% uptime and reliability.\n\nIf you still opt to use the **public** networks, you can use the `Network.{Mainnet|Testnet}Sentry` from the `@injectivelabs/networks` package.\n\nBuilding dApps on Injective requires tapping into different environments and networks where you can easily test your dApp. As part of the `injective-ts` monorepo, we have the `@injectivelabs/networks` package allows developers to easily access pre-defined environments to connect to different pieces of Injective.\n\nThere are two key functions exported from this package:\n\n- `export function getNetworkEndpoints(network: Network): NetworkEndpoints`\n\n- `export function getEndpointsForNetwork(network: Network): OldNetworkEndpoints`\n\n- `export function getNetworkInfo(network: Network): ChainInfo`\n\n\nThe first one, `getNetworkEndpoints` returns a pre-defined set of endpoints that can be used by the developers - depending on their needs. Here is the interface that gets returned from this function:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nexport type NetworkEndpoints = {\n  indexer: string // the grpc-web port of the indexer API service\n  grpc: string // the grpc-web port of the sentry node\n  rest: string // the REST endpoint of the sentry node\n  rpc?: string // the REST endpoint of the Tendermint RPC\n}\n\n/** @deprecated */\nexport type OldNetworkEndpoints = {\n  exchangeApi: string // @deprecated - the grpc-web port of the exchange API service\n  indexerApi: string // the grpc-web port of the indexer API service\n  sentryGrpcApi: string // the grpc-web port of the sentry node\n  sentryHttpApi: string // the REST endpoint of the sentry node\n  tendermintApi?: string // the REST endpoint of the Tendermint RPC\n  chronosApi?: string // the REST endpoint of the chronos API service\n  exchangeWeb3GatewayApi?: string // the grpc-web port of the web3-gateway service API\n}\n```\n\nLet's explain these endpoints, and what they mean:\n\n- `indexer` is the [**grpc-web**](https://github.com/grpc/grpc-web) endpoint that we can use to connect to the `exchange/indexer` service which listens for events from the chain, processes the events, and stores the data into a MongoDB so it's easier and much more performant to serve that data than querying it straight from the chain itself,\n\n- `grpc` is the [**grpc-web**](https://github.com/grpc/grpc-web) endpoint that we can use to connect to a sentry node. A Sentry node is a read (and light) only version of the chain that we can use to query data directly from the chain.\n\n- `rest` is the REST endpoint that we can use to connect to a sentry node.\n\n- `rpc` is the REST endpoint that we can use to connect to the Tendermint RPC,\n\n\nThe `getNetworkInfo` exports these endpoints plus the `chainId` and the default `fee` for the `Network` we want.\n\nUsing the TypeScript SDK with your infrastructure (endpoints) means you have to set up a `grpc-web` proxy in your server. To learn more about it, please reference [this documentation](https://github.com/grpc/grpc-web?tab=readme-ov-file#2-run-the-server-and-proxy).\n\n[PreviousMin Quantity Tick Size](https://docs.ts.injective.network/getting-started/application-concepts/calculations/min-quantity-tick-size) [NextCosmJs Support](https://docs.ts.injective.network/getting-started/application-concepts/getting-started-cosmjs)\n\nLast updated 12 months ago\n\n<|firecrawl-page-8-lllmstxt|>\n## Injective with CosmJS\nInjective is not natively supported on the `@cosmjs` packages. It's highly recommended to use our `@injectivelabs` packages to interact with Injective.\n\nIf you are familiar with the `@cosmjs` packages we are exporting similar interfaces/classes that work the same as the classes on `@cosmjs` but have support for Injective as well.\n\nAgain, keep in mind that the recommended approach is to use the Injective's standard approach, which you can learn more about [here](https://docs.ts.injective.network/transactions/transactions-cosmos).\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/application-concepts/getting-started-cosmjs\\#usage-using-keplr)    Usage using Keplr\n\nHere is an example on how to use the `@injectivelabs` alternatives from the `@cosmjs` packages with Keplr:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  PrivateKey,\n  InjectiveStargate,\n} from \"@injectivelabs/sdk-ts\";\nimport { OfflineDirectSigner } from \"@cosmjs/proto-signing\";\nimport { assertIsBroadcastTxSuccess } from '@cosmjs/stargate'\n\n(async () => {\n  // Enable Keplr\n  await window.keplr.enable(chainId);\n\n  // Get the offline signer\n  const offlineSigner = window.getOfflineSigner(chainId);\n  const [account] = await offlineSigner.getAccounts();\n\n  // Initialize the stargate client\n  const client =\n    await InjectiveStargate.InjectiveSigningStargateClient.connectWithSigner(\n      \"https://lcd-cosmoshub.keplr.app/rest\",\n      offlineSigner,\n    );\n  })\n\n  const amount = {\n    denom: \"inj\",\n    amount: amount.toString(),\n  };\n  const fee = {\n    amount: [\\\n      {\\\n        denom: \"inj\",\\\n        amount: \"5000000000000000\",\\\n      },\\\n    ],\n    gas: \"200000\",\n  };\n\n  const result = await client.sendTokens(\n    account.address,\n    recipient,\n    [amount],\n    fee,\n    \"\"\n  );\n\n  assertIsBroadcastTxSuccess(result);\n\n  if (result.code !== undefined && result.code !== 0) {\n    alert(\"Failed to send tx: \" + result.log || result.rawLog);\n  } else {\n    alert(\"Succeed to send tx:\" + result.transactionHash);\n  }\n})()\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/application-concepts/getting-started-cosmjs\\#usage-in-a-cli-node-environment)    Usage in a CLI/Node environment\n\nHere is an example on how to use the `@injectivelabs` alternatives from the `@cosmjs` packages in a node or CLI environment.\n\nAgain, keep in mind that the recommended approach is to use the [MsgBroadcasterWithPk](https://docs.ts.injective.network/transactions/private-key#example-with-msgbroadcasterwithpk) abstraction to follow the Injective's standard approach.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  PrivateKey,\n  InjectiveStargate,\n  InjectiveDirectEthSecp256k1Wallet,\n} from \"@injectivelabs/sdk-ts\";\nimport { OfflineDirectSigner } from \"@cosmjs/proto-signing\";\nimport { Network, getNetworkInfo } from \"@injectivelabs/networks\";\nimport { getStdFee } from \"@injectivelabs/utils\";\n\n(async () => {\n  const network = getNetworkInfo(Network.Testnet);\n  const privateKeyHash = process.env.PRIVATE_KEY as string;\n  const privateKey = PrivateKey.fromHex(privateKeyHash);\n  const injectiveAddress = privateKey.toBech32();\n\n  const wallet = (await InjectiveDirectEthSecp256k1Wallet.fromKey(\n    Buffer.from(privateKeyHash, \"hex\")\n  )) as OfflineDirectSigner;\n  const [account] = await wallet.getAccounts();\n\n  const client =\n    await InjectiveStargate.InjectiveSigningStargateClient.connectWithSigner(\n      network.rpc as string,\n      wallet\n    );\n\n  const recipient = injectiveAddress;\n  const amount = {\n    denom: \"inj\",\n    amount: \"1000000000\",\n  };\n\n  const txResponse = await client.sendTokens(\n    account.address,\n    recipient,\n    [amount],\n    getStdFee(),\n    \"Have fun with your star coins\"\n  );\n\n  if (txResponse.code !== 0) {\n    console.log(`Transaction failed: ${txResponse.rawLog}`);\n  } else {\n    console.log(\n      `Broadcasted transaction hash: ${JSON.stringify(\n        txResponse.transactionHash\n      )}`\n    );\n  }\n})();\n```\n\n[PreviousNetworks](https://docs.ts.injective.network/getting-started/application-concepts/networks) [NextAssets](https://docs.ts.injective.network/getting-started/assets)\n\nLast updated 12 months ago\n\n<|firecrawl-page-9-lllmstxt|>\n## Injective Asset Types\n## [Direct link to heading](https://docs.ts.injective.network/getting-started/assets\\#denom)    Denom\n\nA denom is how assets are represented within the Bank module of Injective. These assets can be used for trading, creating new markets on the exchange module, participating in auctions, transferring to another address, etc.\n\nDepending on the origin of the denom and how it was created on Injective we have different types of denoms:\n\n- **Native denoms** \\- there is only one denom of this type, the `inj` denom which represented the native coin of Injective,\n\n- **Peggy denoms** \\- these denoms represent assets bridged over from Ethereum to Injective using the Peggy bridge. They have the following format `peggy{ERC20_CONTRACT_ADDRESS}`\n\n- **IBC denoms** \\- these denoms represent assets bridged over from other Cosmos chains through IBC. They have the following format `ibc/{hash}`.\n\n- **Insurance Fund Denoms** \\- these denoms represent token shares of the insurance funds created on Injective. They have the following format `share{id}`\n\n- **Factory Denoms** \\- these denoms are a representation of a CW20 token from Cosmwasm on the Injective native bank module. They have the following format `factory/{OWNER}/{SUBDENOM}` where the `OWNER` is the owner who created the factory denom. One example is the CW20 token factory denom `factory/{CW20_ADAPTER_CONTRACT}/{CW20_CONTRACT_ADDRESS}` where the `CW20_ADAPTER_CONTRACT` is the adapter contract address which does the conversion between CW20 and the native Bank module.\n\n\n#### [Direct link to heading](https://docs.ts.injective.network/getting-started/assets\\#token)    Token\n\nToken is simply a denom on the Injective chain with some meta information. The metadata includes information like symbol, name, decimals, logo for the particular denom, etc. The metadata of the denom is quite important for a dApp developer as information on the chain is stored in its raw form (for example `1inj` on the chain is represented as `1*10^18inj`) so we need to have a way to show the user human-readable information (numbers, logo, symbol, etc).\n\n## [Direct link to heading](https://docs.ts.injective.network/getting-started/assets\\#token-metadata)    Token Metadata\n\nAssets on Injective are represented as denoms. Denoms (and the amounts) are not human readable and this is why we need to have a way to \"attach\" token metadata information for a particular denom.\n\nLet's recap the types of denoms we have in the Getting Started section:\n\n- **Native denoms** \\- there is only one denom of this type, the `inj` denom which represented the native coin of Injective,\n\n- **Peggy denoms** \\- these denoms represent assets bridged over from Ethereum to Injective using the Peggy bridge. They have the following format `peggy{ERC20_CONTRACT_ADDRESS}`\n\n- **IBC denoms** \\- these denoms represent assets bridged over from other Cosmos chains through IBC. They have the following format `ibc/{hash}`.\n\n- **Insurance Fund Denoms** \\- these denoms represent token shares of the insurance funds created on Injective. The have the following format `share{id}`\n\n- **Factory Denoms** \\- these denoms represent a CW20 token from Cosmwasm on the Injective native bank module. They have the following format `factory/{CW20_ADAPTER_CONTRACT}/{CW20_CONTRACT_ADDRESS}` where the `CW20_ADAPTER_CONTRACT` is the adapter contract address that converts CW20 and the native Bank module.\n\n\nWe maintain our token metadata list off-chain for faster access to the [injective-lists](https://github.com/InjectiveLabs/injective-lists/tree/master/tokens) repository.\n\n### [Direct link to heading](https://docs.ts.injective.network/getting-started/assets\\#token-verification)    Token Verification\n\nVerifying your token's metadata can be done in a couple of ways. Here are the verification levels and what they mean:\n\n- **Verified** -\\> Your asset metadata has been **submitted and verified** to the `@injectivelabs/token-metadata` package. You can find a tutorial on how to add your token's metadata to the package [here](https://github.com/InjectiveLabs/injective-lists/blob/master/CONTRIBUTING.md).\n\n- **Internal** -\\> Your asset's metadata has been verified on-chain using the `MsgSetDenomMetadata` message, as explained [here](https://docs.ts.injective.network/core-modules/token-factory#msgsetdenommetadata).\n\n- **External** -\\> Your asset's metadata has been verified on some external source like from Ethereum's contract details, etc.\n\n- **Unverified** -\\> Your asset's metadata has not been provided anywhere.\n\n\n[PreviousCosmJs Support](https://docs.ts.injective.network/getting-started/application-concepts/getting-started-cosmjs) [NextCreating Tokens](https://docs.ts.injective.network/getting-started/assets/creating-tokens)\n\nLast updated 1 month ago\n\n<|firecrawl-page-10-lllmstxt|>\n## Creating Tokens on Injective\nThe easiest way to create your own token on Injective is by using the `tokenfactory` module. The `tokenfactory` module allows any account to create a new token with the name `factory/{creator address}/{subdenom}`. Because tokens are namespaced by creator address, this allows token minting to be permissionless, due to not needing to resolve name collisions.\n\nA single account can create multiple denoms, by providing a unique subdenom for each created denom. Once a denom is created, the original creator is given \"admin\" privileges over the asset. This allows them to:\n\n- Mint their denom to any account\n\n- Burn their denom from any account\n\n- Create a transfer of their denom between any two accounts\n\n- Change the admin. In the future, more admin capabilities may be added. Admins can choose to share admin privileges with other accounts using the authz module. The ChangeAdmin functionality allows changing the master admin account, or even setting it to the zero address `inj1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqe2hm49`, meaning no account has admin privileges over the asset.\n\n- Set their token metadata on chain\n\n\nOne special use case for the factory denoms is the `CW20_ADAPTER`. Using this adapter, assets represented as CW20 can be converted to a bank denom which then can be used to launch a market, send easily on chain, etc.\n\nThe denom for a CW20 asset is always in the `factory/{CW20_ADAPTER_CONTRACT_ADDRESS}/{CW20_ASSET_ADDRESS}` where `CW20_ADAPTER_CONTRACT_ADDRESS=inj14ejqjyq8um4p3xfqj74yld5waqljf88f9eneuk` for mainnet.\n\nTo start creating your denoms, head to our [TokenFactory Core Module page](https://docs.ts.injective.network/core-modules-and-examples/token-factory) to see examples.\n\n[PreviousAssets](https://docs.ts.injective.network/getting-started/assets) [NextDenom Client (deprecated)](https://docs.ts.injective.network/getting-started/assets/denom-client)\n\nLast updated 12 months ago\n\n<|firecrawl-page-11-lllmstxt|>\n## Token Metadata and Denom Client\nThis is deprecated, refer to the [injective-list](https://github.com/InjectiveLabs/injective-ts/blob/dev/.gitbook/readme/assets/readme/token-metadata/injective-list.md) guide instead.\n\n~~The easiest way to get the token metadata information for a particular denom is to utilize the~~ `TokenFactory` ~~class and use its methods:~~\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { TokenFactory } from '@injectivelabs/token-metadata'\nimport { Network } from '@injectivelabs/networks'\n\nconst network = Network.Mainnet\nconst tokenFactory = TokenFactory.make(network) // you can omit the network argument if you want to have the TokenFactory for mainnet\n\n// After instantiating, we can start using it in our dApp\nconst denom = 'peggy0x...'\nconst token = tokenFactory.toToken(denom)\n\nconsole.log(token)\n```\n\n~~There are few edge cases that we have to consider while using the \\`TokenFactory\\`:~~\n\n- ~~If you are trying to query token metadata for a denom that doesn't exist in the~~ [~~list of tokens~~](https://github.com/InjectiveLabs/injective-ts/blob/master/deprecated/token-metadata/src/tokens/tokens/tokens.ts) ~~the~~ `TokenFactory` ~~will return undefined. If so, you should follow our~~ [~~CONTRIBUTION guide~~](https://github.com/InjectiveLabs/injective-ts/blob/master/deprecated/token-metadata/CONTRIBUTING.md) ~~to add the token metadata information in the package.~~\n\n- ~~**IMPORTANT**~~ ~~~~ `TokenFactory` ~~does not have the logic to query a denom trace for an IBC denom. Instead, we have a list of pre-defined IBC hashes which we use to get metadata from. We'll explore how to have this possibility as well below.~~\n\n\n#### [Direct link to heading](https://docs.ts.injective.network/getting-started/assets/denom-client\\#denomclientasync-deprecated)    DenomClientAsync (deprecated)\n\n~~As part of the~~ `@injectivelabs/sdk-ui-ts` ~~package we have an abstraction class~~ [~~DenomClientAsync~~](https://github.com/InjectiveLabs/injective-ts/blob/dev/packages/sdk-ui-ts/src/denom/DenomClientAsync.ts) ~~which uses the~~ `TokenFactory` ~~class under the hood, has a caching mechanism for IBC hashes, fetches token metadata from the chain, ERC20 contract details, CW20 contract details, etc. With it, you can ensure that you get all of the~~ `Token` ~~information for the denoms used within your application.~~\n\n~~The usage is pretty simple, here is an example:~~\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { DenomClientAsync } from '@injectivelabs/sdk-ui-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst network = Network.Mainnet\nconst denomClient = new DenomClientAsync(network) // you can omit the network argument if you want to have the TokenFactory for mainnet\n\n// After instantiating, we can start using it in our dApp\nconst denom = 'peggy0x...'\n\n/**\n * We have to use await here in case the IBC denom hash is not\n * in the list of hardcoded IBC hashes so we fetch all of the\n * denom traces from the chain and cache them in the local instance of the\n * DenomClient class so we can access them easily\n */\nconst token = await denomClient.getDenomToken(denom)\n\nconsole.log(token)\n```\n\n[PreviousCreating Tokens](https://docs.ts.injective.network/getting-started/assets/creating-tokens) [NextInjective Lists](https://docs.ts.injective.network/getting-started/assets/injective-list)\n\nLast updated 9 months ago\n\n<|firecrawl-page-12-lllmstxt|>\n## Injective Token Metadata\nWe have moved the on-chain denoms token metadata to the [injective-list](https://github.com/InjectiveLabs/injective-lists) repository. This repository will aggregate data from several sources and produce a comprehensive token metadata master list.\n\nHere is an example of how to integrate injective-list with the TokenFactoryStatic class:\n\n1. Download the injective list json file from github: https://github.com/InjectiveLabs/injective-lists?tab=readme-ov-file#-usage\n\n2. Use the `TokenFactoryStatic` class from the `sdk-ts` package\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TokenType,\n  TokenStatic,\n  TokenFactoryStatic,\n} from '@injectivelabs/sdk-ts'\nimport { tokens } from '../data/tokens.json' // json file downloaded from step 1\n\nexport const tokenFactoryStatic = new TokenFactoryStatic(\n  tokens as TokenStatic[],\n)\n\n// After instantiating, we can start using it in our dApp\nconst denom = 'peggy0x...'\nconst token = tokenFactoryStatic.toToken(denom)\n\nconsole.log(token)\n```\n\nThere are few edge cases that we have to consider while using the `TokenFactory`:\n\n- If you are trying to query token metadata for a denom that doesn't exist in the [list of tokens](https://github.com/InjectiveLabs/injective-ts/blob/master/deprecated/token-metadata/src/tokens/tokens/tokens.ts) the `TokenFactory` will return undefined. If so, you should follow our [CONTRIBUTION guide](https://github.com/InjectiveLabs/injective-lists/blob/master/CONTRIBUTING.md) to add the token metadata information in the package.\n\n\n[PreviousDenom Client (deprecated)](https://docs.ts.injective.network/getting-started/assets/denom-client) [NextRunning examples](https://docs.ts.injective.network/getting-started/running-examples)\n\nLast updated 9 months ago\n\n<|firecrawl-page-13-lllmstxt|>\n## Injective TS Examples\nYou can clone this open-sourced repository [https://github.com/InjectiveLabs/injective-ts-examples](https://github.com/InjectiveLabs/injective-ts-examples) and follow the steps in ** Getting Started** to get started with your examples!\n\nYou can check the two examples in the repository to make everything work out of the box in a Node environment, querying and sending a transaction.\n\n[PreviousInjective Lists](https://docs.ts.injective.network/getting-started/assets/injective-list) [NextGetting Started](https://docs.ts.injective.network/wallets/wallet)\n\nLast updated 12 months ago\n\n<|firecrawl-page-14-lllmstxt|>\n## Injective Wallet Overview\nInjective defines its own custom `Account` type that uses Ethereum's ECDSA secp256k1 curve for keys. In simple words said, it means that Injective's Account is native (compatible) with Ethereum accounts. This allows users to use Ethereum native wallets to interact with Injective.\n\nInjective is built on top of the CosmosSDK. This means that (with some modifications, since Cosmos uses different curve for keys) users can also use Cosmos native wallets to interact with Injective.\n\n### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet\\#technical-explanation)    Technical Explanation\n\nLet's briefly explain how the accounts (wallets) work on Injective and in crypto in general.\n\n- Everything starts from a **SeedPhase** (or mnemonic). A **SeedPhrase** is a list of 12 or 24 common words in a particular order.\n\n- From the **SeedPhase** you can have an **infinite** number of **PrivateKeys** derived using indexing (the first private key starts at index 0). This is why you can add multiple accounts on Metamask, Keplr, or any other popular wallet without generating a new **SeedPhase** _(the derivation itself is a bit complicated for this brief explanation so we are going to omit it for now)._\n\n- After a **PrivateKey** has been derived from your **seed phase**, you can use this **PrivateKey** to derive your **PublicKey**. **One PrivateKey always corresponds to one PublicKey!**\n\n- Once you have your P **ublicKey** you can derive your **PublicAddress**. These public addresses can be derived using different derivation schemes and representations ( _base64_, _hex_, _bech32_, etc).\n\n\nWith the explanation above, we can understand that once you have your **PublicKey** you can derive both your Ethereum address (represented in a hex format, `0x...`) and your Injective address (represented in a bech32 format, `inj1...`).\n\n* * *\n\n### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet\\#topics)    Topics\n\nTopic\n\nDescription\n\n[Accounts on Injective](https://docs.ts.injective.network/wallets/wallet-accounts)\n\nAccounts/Wallets definition on Injective\n\n[Wallet Connections](https://docs.ts.injective.network/wallets/wallet-connections)\n\nConnecting directly using Metamask or Keplr\n\n[Wallet Strategy](https://docs.ts.injective.network/wallets/wallet-wallet-strategy)\n\nUsing the WalletStrategy to connect using different wallets\n\n[Offchain (Arbitrary) Data](https://docs.ts.injective.network/wallets/offchain-arbitrary-data)\n\nSigning and verifying data offchain using the ADR-036 by Cosmos\n\n[PreviousRunning examples](https://docs.ts.injective.network/getting-started/running-examples) [NextAccounts](https://docs.ts.injective.network/wallets/wallet-accounts)\n\nLast updated 1 month ago\n\n<|firecrawl-page-15-lllmstxt|>\n## Injective Wallet Accounts\nInjective defines its own custom Account type that uses Ethereum's ECDSA secp256k1 curve for keys. This satisfies the [EIP84](https://github.com/ethereum/EIPs/issues/84) for full [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) paths. The root HD path for Injective-based accounts is `m/44'/60'/0'/0.`\n\n### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet-accounts\\#address-conversion)    Address conversion\n\nYou can easily convert between an Injective address and Ethereum address by using our utility functions in the `@injectivelabs/sdk-ts` package:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { getInjectiveAddress, getEthereumAddress } from '@injectivelabs/sdk-ts'\n\nconst injectiveAddress = 'inj1...'\nconst ethereumAddress = '0x..'\n\nconsole.log('Injective address from Ethereum address => ', getInjectiveAddress(ethereumAddress))\nconsole.log('Ethereum address from Injective address => ', getEthereumAddress(injectiveAddress))\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet-accounts\\#deriving-wallets)    Deriving wallets\n\n**Using Injective utility classes**\n\n- Example code snippet on how to derive Injective Account from a private key and/or a mnemonic phrase:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PrivateKey } from '@injectivelabs/sdk-ts'\n\nconst mnemonic = \"indoor dish desk flag debris potato excuse depart ticket judge file exit\"\nconst privateKey = \"afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890\"\nconst privateKeyFromMnemonic = PrivateKey.fromMnemonic(mnemonic)\nconst privateKeyFromHex = PrivateKey.fromPrivateKey(privateKey)\n\nconst address = privateKeyFromMnemonic.toAddress() /* or privateKeyFromHex.toAddress() */\nconsole.log({ injectiveAddress: address.toBech32(), ethereumAddress: address.toHex() })\n```\n\n- Example code snipped on how to derive a public address from a public key:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PublicKey } from '@injectivelabs/sdk-ts'\n\nconst pubKey = \"AuY3ASbyRHfgKNkg7rumWCXzSGCvvgtpR6KKWlpuuQ9Y\"\nconst publicKey = PublicKey.fromBase64(pubKey)\n\nconsole.log(publicKey.toAddress().toBech32())\n```\n\n- Example code snipped on how to derive an address from a private key:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PublicKey } from '@injectivelabs/sdk-ts'\n\nconst privateKey = \"afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890\"\nconst publicKey = PublicKey.fromPrivateKeyHex(privateKey)\nconst type = '/injective.crypto.v1beta1.ethsecp256k1.PubKey'\n\nconsole.log(publicKey.toBase64())\n```\n\n**Without using Injective utility classes**\n\n- Example code snippet on how to derive Injective Account from a private key and/or a mnemonic phrase:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { Wallet } from 'ethers'\nimport { Address as EthereumUtilsAddress } from 'ethereumjs-util'\n\nconst mnemonic = \"indoor dish desk flag debris potato excuse depart ticket judge file exit\"\nconst privateKey = \"afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890\"\nconst defaultDerivationPath = \"m/44'/60'/0'/0/0\"\nconst defaultBech32Prefix = 'inj'\nconst isPrivateKey: boolean = true /* just for the example */\n\nconst wallet = isPrivateKey ? Wallet.fromMnemonic(mnemonic, defaultDerivationPath) : new Wallet(privateKey)\nconst ethereumAddress = wallet.address\nconst addressBuffer = EthereumUtilsAddress.fromString(ethereumAddress.toString()).toBuffer()\nconst injectiveAddress = bech32.encode(defaultBech32Prefix, bech32.toWords(addressBuffer))\n```\n\n- Example code snipped on how to derive a public key from a private key:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport secp256k1 from 'secp256k1'\n\nconst privateKey = \"afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890\"\nconst privateKeyHex = Buffer.from(privateKey.toString(), 'hex')\nconst publicKeyByte = secp256k1.publicKeyCreate(privateKeyHex)\n\nconst buf1 = Buffer.from([10])\nconst buf2 = Buffer.from([publicKeyByte.length])\nconst buf3 = Buffer.from(publicKeyByte)\n\nconst publicKey = Buffer.concat([buf1, buf2, buf3]).toString('base64')\nconst type = '/injective.crypto.v1beta1.ethsecp256k1.PubKey'\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet-accounts\\#convert-cosmos-address-to-injective-address)    Convert Cosmos address to Injective Address\n\nAs Injective has a different derivation path than the default Cosmos one, you need the `publicKey` of the account to convert a Cosmos `publicAddress` to Injective one.\n\nHere is an example of how to do it\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { config } from \"dotenv\";\nimport { ChainRestAuthApi, PublicKey } from \"@injectivelabs/sdk-ts\";\n\nconfig();\n\n(async () => {\n  const chainApi = new ChainRestAuthApi(\n    \"https://rest.cosmos.directory/cosmoshub\"\n  );\n\n  const cosmosAddress = \"cosmos1..\";\n  const account = await chainApi.fetchCosmosAccount(cosmosAddress);\n\n  if (!account.pub_key?.key) {\n    console.log(\"No public key found\");\n    return;\n  }\n\n  console.log(\n    \"injectiveAddress\",\n    PublicKey.fromBase64(account.pub_key.key || \"\")\n      .toAddress()\n      .toBech32()\n  );\n})();\n\n```\n\n[PreviousGetting Started](https://docs.ts.injective.network/wallets/wallet) [NextWallet Connections](https://docs.ts.injective.network/wallets/wallet-connections)\n\nLast updated 1 month ago\n\n<|firecrawl-page-16-lllmstxt|>\n## Wallet Connections Guide\nInjective supports both Ethereum and Cosmos native wallets. You can use popular wallets like Metamask, Ledger, Keplr, Leap, etc. to sign transactions on Injective.\n\n### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet-connections\\#wallet-strategy)    Wallet Strategy\n\nThe recommended way to have support for all of these wallets out of the box is to use the [WalletStrategy](https://docs.ts.injective.network/wallets/wallet-wallet-strategy) abstraction we've built. This approach will enable your dApp users to connect and interact with different wallets.\n\nCombining it with the [MsgBroadcaster](https://docs.ts.injective.network/transactions/msgbroadcaster) abstraction allows you to sign transactions using one function call. This is what's being used on all products like Helix, Hub, Explorer, etc., and we strongly recommend using this approach in your dApp.\n\nIn case you still want to use some wallet natively (without the WalletStrategy class), we are going to provide examples of how to connect to a dApp built on Injective via Metamask and Keplr in this doc.\n\n### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet-connections\\#metamask)    Metamask\n\nMetamask is an Ethereum native wallet and can be used to connect and interact with your dApp built on Injective.\n\n- **Get Injective addresses from Metamask**\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n\nimport { getInjectiveAddress } from '@injectivelabs/sdk-ts'\n\nconst getEthereum = () => {\n  if (!window.ethereum) {\n    throw new Error('Metamask extension not installed')\n  }\n\n  return window.ethereum\n}\n\nconst ethereum = getEthereum()\nconst addresses = await ethereum.request({\n  method: 'eth_requestAccounts',\n}) /** these are evm addresses */\n\nconst injectiveAddresses = addresses.map(getInjectiveAddress)\nconsole.log(injectiveAddresses)\n```\n\n- **Sign transactions using Metamask**\n\n\nAn example of how to prepare + sign + broadcast a transaction on Injective using Metamask can be found [here](https://docs.ts.injective.network/transactions/ethereum).\n\n### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet-connections\\#keplr)    Keplr\n\nKeplr is an Cosmos native wallet and can be used to connect and interact with your dApp built on Injective.\n\n- **Get Injective addresses from Keplr**\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n\nimport { getInjectiveAddress } from '@injectivelabs/sdk-ts'\nimport { ChainId } from '@injectivelabs/ts-types'\n\nconst getKeplr = () => {\n  if (!window.keplr) {\n    throw new Error('Keplr extension not installed')\n  }\n\n  return window.keplr\n}\n\n(async() => {\n  const keplr = getKeplr()\n  const chainId = ChainId.Mainnet\n  await keplr.enable(chainId)\n  const injectiveAddresses = await keplr.getOfflineSigner(chainId).getAccounts()\n\n  console.log(injectiveAddresses)\n})()\n```\n\n- **Sign transactions using Keplr**\n\n\nAn example of how to prepare + sign + broadcast a transaction on Injective using Keplr can be found [here](https://docs.ts.injective.network/transactions/transactions-cosmos).\n\n[PreviousAccounts](https://docs.ts.injective.network/wallets/wallet-accounts) [NextWallet Strategy](https://docs.ts.injective.network/wallets/wallet-wallet-strategy)\n\nLast updated 1 year ago\n\n<|firecrawl-page-17-lllmstxt|>\n## Injective Wallet Strategies\nThe main purpose of the `@injectivelabs/wallet-strategy` is to offer developers a way to have different wallet implementations on Injective. All of these wallets implementations are exposing the same `ConcreteStrategy` interface which means that users can just use these methods without the need to know the underlying implementation for specific wallets as they are abstracted away.\n\nTo start, you have to make an instance of the `WalletStrategy` class which gives you the ability to use different wallets out of the box. You can switch the current wallet that is used by using the `setWallet` method on the `walletStrategy` instance.\n\nLet's have a look at the methods that `WalletStrategy` strategy exposes and what they mean:\n\n**Both Ethereum and Cosmos native wallets:**\n\n- `getAddresses` gets the addresses from the connected wallet strategy. This method returns the Ethereum addresses for Ethereum native wallets (strategies) and Injective addresses for Cosmos native wallets (strategies).\n\n- `signTransaction` signs a transaction using the corresponding wallet type method ( `signCosmosTransaction` for Cosmos native wallets, `signEip712TypedData` for Ethereum native wallets)\n\n- `sendTransaction` signs a transaction using the corresponding wallet type method (needs a `sentryEndpoint` passed to the options if we wanna use it on Ethereum native wallets - explanation can be found below)\n\n- `getWalletDeviceType` returns the wallet connection type (mobile, browser, hardware),\n\n\n**Cosmos native wallets:**\n\n- `signCosmosTransaction` signs an Injective transaction using the connected wallet strategy,\n\n- `getPublicKey` get the public key for the Cosmos native wallet strategies,\n\n\n**Ethereum native wallets:**\n\n- `getEthereumChainId` get the chain id for the Ethereum native wallet strategies,\n\n- `signEip712TypedData` signs an EIP712 typed data using the connected wallet strategy,\n\n- `sendEthereumTransaction` sends an Ethereum Web3 transaction using the connected wallet strategy,\n\n- `signEthereumTransaction` signs an Ethereum Web3 transaction using the connected wallet strategy,\n\n- `getEthereumTransactionReceipt` get the transaction receipt for Ethereum native transactions for the wallet strategy,\n\n\n### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet-wallet-strategy\\#arguments)    Arguments\n\nThe arguments passed to the WalletStrategy have the following interface:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nexport interface WalletStrategyEthereumOptions {\n  rpcUrl: string // rpc url needed **ONLY** the Ethereum native methods on the strategies\n  ethereumChainId: EthereumChainId // needed if you are signing EIP712 typed data using the Wallet Strategies\n}\n\nexport interface EthereumWalletStrategyArgs {\n  chainId: ChainId // the Injective chain id\n  ethereumOptions?: WalletStrategyEthereumOptions // optional, needed only if you are using Ethereum native wallets\n  disabledWallets?: Wallet[] // optional, needed if you wanna disable some wallets for being instantiated\n  wallet?: Wallet // optional, the initial wallet selected (defaults to Metamask if `ethereumOptions` are passed and Keplr if they are not)\n}\n```\n\n_Note:_ When we wanna use the `sendTransaction` on Ethereum native wallets alongside the other options (chainId and address) we also need to pass a gRPC endpoint to a sentry to broadcast the transaction. This is needed because from Ethereum native wallets, we don't have access to a `broadcastTx` method as we have on Keplr or Leap to broadcast the transaction using the wallet's abstraction so we have to broadcast it on the client side directly to the chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/wallets/wallet-wallet-strategy\\#example-usage)    Example usage\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { WalletStrategy } from '@injectivelabs/wallet-strategy'\nimport { EthereumChainId, ChainId } from '@injectivelabs/ts-types'\nimport { TxRaw } from '@injectivelabs/sdk-ts'\nimport { Web3Exception } from '@injectivelabs/exceptions'\n\nexport const alchemyRpcEndpoint = `https://eth-mainnet.alchemyapi.io/v2/${process.env.ALCHEMY_KEY}`\n\nexport const walletStrategy = new WalletStrategy({\n  chainId: ChainId.Mainnet,\n  ethereumOptions: {\n    ethereumChainId: EthereumChainId.Mainnet,\n    rpcUrl: alchemyRpcEndpoint\n  }\n})\n\n// Get wallet's addresses\nexport const getAddresses = async (): Promise<string[]> => {\n  const addresses = await walletStrategy.getAddresses()\n\n  if (addresses.length === 0) {\n    throw new Web3Exception(new Error('There are no addresses linked in this wallet.'))\n  }\n\n  return addresses\n}\n\n// Sign an Injective transaction\nexport const signTransaction = async (tx: TxRaw): Promise<string[]> => {\n  const response = await walletStrategy.signCosmosTransaction(\n    /*transaction:*/ { txRaw: tx, accountNumber: /* */, chainId: 'injective-1' },\n    /*address: */ 'inj1...',\n  )\n\n  return response\n}\n\n// Send an Injective transaction\nexport const sendTransaction = async (tx: TxRaw): Promise<string[]> => {\n  const response = await walletStrategy.sendTransaction(\n    tx,\n    // `sentryEndpoint` needed if Ethereum wallets are used\n    {address: 'inj1...', chainId: 'injective-1', sentryEndpoint: 'https://grpc.injective.network' }\n  )\n\n  return response\n}\n```\n\n[PreviousWallet Connections](https://docs.ts.injective.network/wallets/wallet-connections) [NextOffchain (Arbitrary) Data](https://docs.ts.injective.network/wallets/offchain-arbitrary-data)\n\nLast updated 11 days ago\n\n<|firecrawl-page-18-lllmstxt|>\n## Sign and Verify Data\nOn this page, we'll provide an example of how to sign and verify arbitrary data as per the [ADR-036](https://docs.cosmos.network/main/build/architecture/adr-036-arbitrary-signature) specification on Cosmos.\n\nYou can use the `generateArbitrarySignDoc` function from `@injectivelabs/sdk-ts` to generate ADR-36 compatible `signDoc`. You can then use it to sign/verify using a browser wallet or in a CLI environment. Make sure you are using the latest package versions.\n\n#### [Direct link to heading](https://docs.ts.injective.network/wallets/offchain-arbitrary-data\\#sign-and-verify-using-a-browser-wallet-like-keplr)    Sign and verify using a browser wallet like Keplr\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n\n(async () => {\n  const message = \"Offline Sign Message Example\";\n  const signer = 'inj1...'\n  const chainId = 'injective-1'\n\n  // Sign Arbitrary Data\n  const signature = await window.keplr.signArbitrary(chainId, signer, message)\n\n  // Verify Arbitrary Data\n  const result = await window.keplr.verifyArbitrary(chainId, signer, message, signature)\n\n  if (result) {\n    console.log(\"Signature is valid\");\n  }\n})();\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/wallets/offchain-arbitrary-data\\#sign-and-verify-using-privatekey-in-a-cli-environment)    Sign and verify using PrivateKey in a CLI environment\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { config } from \"dotenv\";\nimport { PrivateKey, generateArbitrarySignDoc } from \"@injectivelabs/sdk-ts\";\n\nconfig();\n\n(async () => {\n  const { privateKey } = PrivateKey.generate();\n  const injectiveAddress = privateKey.toBech32();\n  const publicKey = privateKey.toPublicKey();\n\n  const message = \"Offline Sign Message Example\";\n  const { signDocBuff } = generateArbitrarySignDoc(message, injectiveAddress);\n\n  const signature = await privateKey.sign(signDocBuff);\n  const signatureInHex = Buffer.from(signature).toString(\"hex\");\n\n  if (\n    PrivateKey.verifyArbitrarySignature({\n      signature: signatureInHex,\n      signDoc: signDocBuff,\n      publicKey: publicKey.toHex(),\n    })\n  ) {\n    console.log(\"Signature is valid\");\n  }\n})();\n\n```\n\n[PreviousWallet Strategy](https://docs.ts.injective.network/wallets/wallet-wallet-strategy) [NextGetting Started](https://docs.ts.injective.network/querying/querying)\n\nLast updated 9 months ago\n\n<|firecrawl-page-19-lllmstxt|>\n## Querying Injective Data\nThere are 2 data sources that can be accessed through the `sdk-ts`:\n\n- The Injective chain itself through a sentry node,\n\n- The Indexer API (indexer of events from the Injective chain to a MongoDB),\n\n\nFor each of the data sources there are two ways that they can be queried:\n\n- using the gRPC protocol,\n\n- Using HTTP REST\n\n\nWe also have a GraphQL consumer of the Peggy subgraph on Ethereum (used only for tracking deposits and withdrawals on Ethereum).\n\nFor the 2 main data sources, there are abstraction classes that developers can use to access specific modules of the Injective Chain **or** specific modules within the Exchange API. The responses of these requests are always mapped into normal JavaScript objects (regardless of the data source type) and served to the end user.\n\n* * *\n\n* * *\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying\\#topics)    Topics\n\nTopic\n\nDescription\n\n[Querying the Chain](https://docs.ts.injective.network/querying/querying-chain)\n\nQuerying data from the chain\n\n[Querying the Indexer API](https://docs.ts.injective.network/querying/querying-api)\n\nQuerying data from the Indexer API\n\n[Steaming from the Indexer API](https://docs.ts.injective.network/querying/querying-api/streaming)\n\nStreaming data from the Indexer API\n\n[Querying Ethereum from the Graph](https://docs.ts.injective.network/querying/querying-ethereum)\n\nQuerying Ethereum via GraphQL\n\n[PreviousOffchain (Arbitrary) Data](https://docs.ts.injective.network/wallets/offchain-arbitrary-data) [NextChain](https://docs.ts.injective.network/querying/querying-chain)\n\nLast updated 11 months ago\n\n<|firecrawl-page-20-lllmstxt|>\n## Querying Chain Data\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain\\#querying-the-chain)    Querying the Chain\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain\\#topics)    Topics\n\nTopic\n\nDescription\n\n[Auction](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auction-module)\n\nQuerying data from the auction module\n\n[Auth](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module)\n\nQuerying data from the auth module\n\n[Bank](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module)\n\nQuery data from the bank module\n\n[Distribution](https://docs.ts.injective.network/querying/querying-chain/querying-chain-distribution)\n\nQuery data related to delegating to validators\n\n[Exchange](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange)\n\nQuery data from the exchange module\n\n[Gov](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance)\n\nQuery data from the governance module\n\n[IBC](https://docs.ts.injective.network/querying/querying-chain/querying-chain-ibc)\n\nQuery data related to IBC\n\n[Insurance Fund](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds)\n\nQuery data related to insurance funds\n\n[Mint](https://docs.ts.injective.network/querying/querying-chain/querying-chain-mint)\n\nQuery data from the mint module\n\n[Oracl](https://docs.ts.injective.network/querying/querying-chain/querying-chain-oracle)\n\nQuery data related to the oracle api\n\n[Peggy](https://docs.ts.injective.network/querying/querying-chain/querying-chain-peggy)\n\nQuery ethereum data using the peggy api\n\n[Permissions](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions)\n\nQuery data from the permissions module\n\n[Staking](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking)\n\nQuery data from the staking module\n\n[Wasm](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm)\n\nQuery data from the wasm module\n\n[WasmX](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasmx)\n\nQuery data from the wasmX module\n\n[Tendermint](https://docs.ts.injective.network/querying/querying-chain/querying-chain-tendermint)\n\nQuery data related to the tendermint api\n\n[Token Factory](https://docs.ts.injective.network/querying/querying-chain/token-factory)\n\nQuery data from the token factory module\n\n* * *\n\n[PreviousGetting Started](https://docs.ts.injective.network/querying/querying) [NextAuction](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auction-module)\n\nLast updated 6 months ago\n\n<|firecrawl-page-21-lllmstxt|>\n## Query Auction Module\nExample code snippets to query the auction module on the chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auction-module\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auction-module\\#fetch-module-params-such-as-the-auction-period)    Fetch module params such as the auction period\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcBankApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcAuctionApi = new ChainGrpcAuctionApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcAuctionApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auction-module\\#fetch-the-state-of-the-current-auction-such-as-the-latest-round)    Fetch the state of the current auction, such as the latest round\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcBankApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcAuctionApi = new ChainGrpcAuctionApi(endpoints.grpc)\n\nconst latestAuctionModuleState = await auctionApi.fetchModuleState()\n\nconsole.log(latestAuctionModuleState)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auction-module\\#fetch-the-current-auction-basket-and-get-info-such-as-the-highest-bidder-and-amount)    Fetch the current auction basket and get info such as the highest bidder and amount\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcBankApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcAuctionApi = new ChainGrpcAuctionApi(endpoints.grpc)\n\nconst currentBasket = await chainGrpcAuctionApi.fetchCurrentBasket()\n\nconsole.log(currentBasket)\n```\n\n[PreviousChain](https://docs.ts.injective.network/querying/querying-chain) [NextAuth](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module)\n\nLast updated 12 months ago\n\n<|firecrawl-page-22-lllmstxt|>\n## Querying Auth Module\nExample code snippets to query the auth module on the chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module\\#fetch-parameters-such-as-max-memo-characters-or-tsx-signature-limit)    Fetch parameters such as max memo characters or tsx signature limit\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcAuthApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcAuthApi = new ChainGrpcAuthApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcAuthApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module\\#fetch-ccount-details-associated-with-an-injective-address-such-as-the-accounts-address-sequence-or-p)    Fetch ccount details associated with an injective address such as the account's address, sequence, or pub\\_key\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcAuthApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcAuthApi = new ChainGrpcAuthApi(endpoints.grpc)\nconst injectiveAddress = 'inj...'\n\nconst accountDetailsResponse = await chainGrpcAuthApi.fetchAccount(\n  injectiveAddress,\n)\n\nconsole.log(accountDetailsResponse)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module\\#fetch-list-of-accounts-on-chain)    Fetch list of accounts on chain\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcAuthApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcAuthApi = new ChainGrpcAuthApi(endpoints.grpc)\nconst injectiveAddress = 'inj...'\nconst pagination = {...} as PaginationOption\n\nconst accounts = await chainGrpcAuthApi.fetchAccounts(/* optional pagination params*/)\n\nconsole.log(accounts)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module\\#using-http-rest)    Using HTTP REST\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module\\#fetch-account-details-associated-with-an-injective-address-such-as-the-accounts-address-sequence-or)    Fetch account details associated with an injective address such as the account's address, sequence, or pub\\_key\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainRestAuthApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainRestAuthApi = new ChainRestAuthApi(endpoints.rest)\nconst injectiveAddress = 'inj...'\n\nconst accountDetailsResponse = await chainRestAuthApi.fetchAccount(\n  injectiveAddress,\n)\n\nconsole.log(accountDetailsResponse)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module\\#fetch-cosmos-address-from-an-injective-address)    Fetch cosmos address from an injective address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainRestAuthApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainRestAuthApi = new ChainRestAuthApi(endpoints.rest)\nconst injectiveAddress = 'inj...'\n\nconst cosmosAddress = await chainRestAuthApi.fetchCosmosAccount(\n  injectiveAddress,\n)\n\nconsole.log(cosmosAddress)\n```\n\n[PreviousAuction](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auction-module) [NextBank](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module)\n\nLast updated 12 months ago\n\n<|firecrawl-page-23-lllmstxt|>\n## Querying Bank Module\nExample code snippets to query the chain for bank module related data.\n\n## [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module\\#fetch-bank-module-params)    Fetch bank module params\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcBankApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcBankApi = new ChainGrpcBankApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcBankApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module\\#fetching-injective-addresss-balances)    Fetching injective address's balances\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcBankApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcBankApi = new ChainGrpcBankApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj...'\n\nconst balances = await chainGrpcBankApi.fetchBalances(injectiveAddress)\n\nconsole.log(balances)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module\\#fetching-cosmos-address-balances-per-base-denom)    Fetching cosmos address' balances per base denom\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcBankApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcBankApi = new ChainGrpcBankApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj1' /* example is using Cosmos Hub */\nconst denom = 'inj'\n\nconst balance = await chainGrpcBankApi.fetchBalance({\n  accountAddress: injectiveAddress,\n  denom,\n})\n\nconsole.log(balance)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module\\#fetching-total-supply-on-chain)    Fetching total supply on chain\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcBankApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcBankApi = new ChainGrpcBankApi(endpoints.grpc)\n\nconst pagination = {...} as PaginationOption\n\nconst totalSupply = await chainGrpcBankApi.fetchTotalSupply(\n  pagination /* optional pagination parameter */\n)\n\nconsole.log(totalSupply)\n```\n\n## [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module\\#using-http-rest)    Using HTTP REST\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module\\#fetching-addresss-balances)    Fetching address's balances\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainRestBankApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainRestBankApi = new ChainRestBankApi(endpoints.rest)\n\nconst injectiveAddress = 'inj...'\n\nconst balances = await chainGrpcBankApi.fetchBalances(injectiveAddress)\n\nconsole.log(balances)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module\\#fetching-cosmos-address-balances-per-base-denom-1)    Fetching cosmos address' balances per base denom\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainRestBankApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainRestBankApi = new ChainRestBankApi(endpoints.rest)\n\nconst cosmosAddress = 'cosmos...' /* example is using Cosmos Hub */\nconst denom = 'uatom'\n\nconst balance = await chainRestBankApi.fetchBalance(cosmosAddress, denom)\n\nconsole.log(balance)\n```\n\n[PreviousAuth](https://docs.ts.injective.network/querying/querying-chain/querying-chain-auth-module) [NextDistribution](https://docs.ts.injective.network/querying/querying-chain/querying-chain-distribution)\n\nLast updated 12 months ago\n\n<|firecrawl-page-24-lllmstxt|>\n## Querying Chain Distribution\nExample code snippets to query data related to delegating to validators from the chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-distribution\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-distribution\\#fetch-parameters-such-as-the-base-and-bonus-proposer-reward)    Fetch parameters such as the base and bonus proposer reward\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcDistributionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcDistributionApi = new ChainGrpcDistributionApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcDistributionApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-distribution\\#fetch-the-amount-and-denom-of-rewards-for-a-delegator-delagating-to-a-specific-validator)    Fetch the amount and denom of rewards for a delegator delagating to a specific validator\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcDistributionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcDistributionApi = new ChainGrpcDistributionApi(endpoints.grpc)\n\nconst delegatorAddress = 'inj...'\nconst validatorAddress = 'injvaloper...'\n\nconst delegatorRewardsFromValidator =\n  await chainGrpcDistributionApi.fetchDelegatorRewardsForValidatorNoThrow({\n    delegatorAddress,\n    validatorAddress,\n  })\n\nconsole.log(delegatorRewardsFromValidator)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-distribution\\#fetch-the-amount-and-denom-of-all-rewards-for-a-delegator)    Fetch the amount and denom of all rewards for a delegator\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcDistributionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcDistributionApi = new ChainGrpcDistributionApi(endpoints.grpc)\n\nconst delegatorAddress = 'inj...'\n\nconst totalDelegatorRewards =\n  await chainGrpcDistributionApi.fetchDelegatorRewardsNoThrow(delegatorAddress)\n\nconsole.log(totalDelegatorRewards)\n```\n\n[PreviousBank](https://docs.ts.injective.network/querying/querying-chain/querying-chain-bank-module) [NextExchange](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange)\n\nLast updated 12 months ago\n\n<|firecrawl-page-25-lllmstxt|>\n## Querying Chain Exchange\nExample code snippets to query the exchange module on the chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange\\#fetch-parameters-such-as-the-default-spot-and-derivatives-fees-trading-rewards)    Fetch parameters such as the default spot and derivatives fees/trading rewards\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcExchangeApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcExchangeApi = new ChainGrpcExchangeApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcExchangeApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange\\#fetch-the-fee-discount-schedules)    Fetch the fee discount schedules\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcExchangeApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcExchangeApi = new ChainGrpcExchangeApi(endpoints.grpc)\n\nconst feeDiscountSchedule =\n  await chainGrpcExchangeApi.fetchFeeDiscountSchedule()\n\nconsole.log(feeDiscountSchedule)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange\\#fetch-the-fee-discounts-associated-with-an-injective-address)    Fetch the fee discounts associated with an injective address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcExchangeApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcExchangeApi = new ChainGrpcExchangeApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj...'\n\nconst feeDiscountAccountInfo =\n  await chainGrpcExchangeApi.fetchFeeDiscountAccountInfo(injectiveAddress)\n\nconsole.log(feeDiscountAccountInfo)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange\\#fetch-the-details-regarding-the-trading-reward-campaign-such-as-the-total-reward-points)    Fetch the details regarding the trading reward campaign, such as the total reward points\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcExchangeApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcExchangeApi = new ChainGrpcExchangeApi(endpoints.grpc)\n\nconst tradingRewardsCampaign =\n  await chainGrpcExchangeApi.fetchTradingRewardsCampaign()\n\nconsole.log(tradingRewardsCampaign)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange\\#fetch-the-trading-rewards-points-for-an-injective-address)    Fetch the trading rewards points for an injective address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcExchangeApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcExchangeApi = new ChainGrpcExchangeApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj...'\n\nconst tradeRewardsPoints = await chainGrpcExchangeApi.fetchTradeRewardsPoints(\n  injectiveAddress,\n)\n\nconsole.log(tradeRewardsPoints)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange\\#fetch-the-pending-trading-rewards-points-for-injective-addresses)    Fetch the pending trading rewards points for injective addresses\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcExchangeApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcExchangeApi = new ChainGrpcExchangeApi(endpoints.grpc)\n\nconst injectiveAddresses = ['inj...']\n\nconst pendingTradeRewardsPoints =\n  await chainGrpcExchangeApi.fetchPendingTradeRewardPoints(injectiveAddresses)\n\nconsole.log(pendingTradeRewardsPoints)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange\\#fetch-the-current-positions-such-as-subaccountid-marketid-and-position)    Fetch the current positions, such as subaccountId, marketId, and position\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcExchangeApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcExchangeApi = new ChainGrpcExchangeApi(endpoints.grpc)\n\nconst positions = await chainGrpcExchangeApi.fetchPositions(injectiveAddresses)\n\nconsole.log(positions)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange\\#fetch-the-subaccount-trade-nonce)    Fetch the subaccount trade nonce\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcExchangeApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcExchangeApi = new ChainGrpcExchangeApi(endpoints.grpc)\n\nconst subaccountId = '0x...'\n\nconst subaccountTradeNonce =\n  await chainGrpcExchangeApi.fetchSubaccountTradeNonce(subaccountId)\n\nconsole.log(subaccountTradeNonce)\n```\n\n[PreviousDistribution](https://docs.ts.injective.network/querying/querying-chain/querying-chain-distribution) [NextGovernance](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance)\n\nLast updated 12 months ago\n\n<|firecrawl-page-26-lllmstxt|>\n## Querying Chain Governance\nExample code snippets to query the governance module on the chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance\\#fetch-parameters-such-as-the-voting-period-max-depositing-period-or-tallying-details)    Fetch parameters such as the voting period, max depositing period, or tallying details\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcGovApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcGovApi = new ChainGrpcGovApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcGovApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance\\#fetch-proposals-based-on-the-status)    Fetch proposals based on the status\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcGovApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\nimport { ProposalStatusMap } from '@injectivelabs/chain-api'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcGovApi = new ChainGrpcGovApi(endpoints.grpc)\n\nconst status = 3 as ProposalStatusMap[keyof ProposalStatusMap]\nconst pagination = {...} as PaginationOption\n\nconst proposals = await chainGrpcGovApi.fetchProposals({\n  status,\n  pagination /* optional pagination params */\n})\n\nconsole.log(proposals)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance\\#fetch-proposal-details-based-on-a-proposals-id)    Fetch proposal details based on a proposal's id\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcGovApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcGovApi = new ChainGrpcGovApi(endpoints.grpc)\n\nconst proposalId = 123\n\nconst proposalDetails = await chainGrpcGovApi.fetchProposal(proposalId)\n\nconsole.log(proposalDetails)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance\\#fetch-proposal-deposits-based-on-a-proposals-id)    Fetch proposal deposits based on a proposal's id.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcGovApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcGovApi = new ChainGrpcGovApi(endpoints.grpc)\n\nconst proposalId = 123\nconst pagination = {...} as PaginationOption\n\nconst proposalDeposits = await chainGrpcGovApi.fetchProposalDeposits({\n  proposalId,\n  pagination /* optiona pagination parameter */\n})\n\nconsole.log(proposalDeposits)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance\\#fetch-proposal-details-based-on-a-proposals-id-1)    Fetch proposal details based on a proposal's id\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcGovApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcGovApi = new ChainGrpcGovApi(endpoints.grpc)\n\nconst proposalId = 123\n\nconst proposalDetails = await chainGrpcGovApi.fetchProposal(proposalId)\n\nconsole.log(proposalDetails)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance\\#fetch-proposal-deposits-based-on-a-proposals-id-1)    Fetch proposal deposits based on a proposal's id\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcGovApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcGovApi = new ChainGrpcGovApi(endpoints.grpc)\n\nconst proposalId = 123\nconst pagination = {...} as PaginationOption\n\nconst proposalDeposits = await chainGrpcGovApi.fetchProposalDeposits({\n  proposalId,\n  pagination /* optional pagination param */\n})\n\nconsole.log(proposalDeposits)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance\\#fetch-proposal-votes-based-on-a-proposals-id)    Fetch proposal votes based on a proposal's id\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcGovApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcGovApi = new ChainGrpcGovApi(endpoints.grpc)\n\nconst proposalId = 123\n\nconst proposalVotes = await chainGrpcGovApi.fetchProposalVotes({\n  proposalId,\n  pagination: /* optional pagination Options */\n})\n\nconsole.log(proposalVotes)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance\\#fetch-proposal-tally-based-on-a-proposals-id)    Fetch proposal tally based on a proposal's id\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcGovApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcGovApi = new ChainGrpcGovApi(endpoints.grpc)\n\nconst proposalId = 123\nconst pagination = {...} as PaginationOption\n\nconst proposalTally = await chainGrpcGovApi.fetchProposalTally({\n  proposalId,\n  pagination /* optional pagination Options */\n})\n\nconsole.log(proposalTally)\n```\n\n[PreviousExchange](https://docs.ts.injective.network/querying/querying-chain/querying-chain-exchange) [NextIBC](https://docs.ts.injective.network/querying/querying-chain/querying-chain-ibc)\n\nLast updated 12 months ago\n\n<|firecrawl-page-27-lllmstxt|>\n## Querying IBC Data\nExample code snippets to query the chain for IBC related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-ibc\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-ibc\\#fetch-denom-trace-from-the-ibc-hash)    Fetch denom trace from the IBC hash\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcIbcApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcIbcApi = new ChainGrpcIbcApi(endpoints.grpc)\nconst hash = '...'\n\nconst denomTrace = await chainGrpcIbcApi.fetchDenomTrace(hash)\n\nconsole.log(denomTrace)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-ibc\\#fetch-list-of-denom-traces)    Fetch list of denom traces\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcIbcApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcIbcApi = new ChainGrpcIbcApi(endpoints.grpc)\n\nconst denomTraces = await chainGrpcIbcApi.fetchDenomsTrace()\n\nconsole.log(denomTraces)\n```\n\n[PreviousGovernance](https://docs.ts.injective.network/querying/querying-chain/querying-chain-governance) [NextMint](https://docs.ts.injective.network/querying/querying-chain/querying-chain-mint)\n\nLast updated 12 months ago\n\n<|firecrawl-page-28-lllmstxt|>\n## Querying Mint Module\nExample code snippets to query the mint module on the chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-mint\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-mint\\#fetch-parameters-related-to-the-mint-module)    Fetch parameters related to the mint module\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcMintApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcMintApi = new ChainGrpcMintApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcMintApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-mint\\#fetch-inflation)    Fetch inflation\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcMintApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcMintApi = new ChainGrpcMintApi(endpoints.grpc)\n\nconst inflation = await chainGrpcMintApi.fetchInflation()\n\nconsole.log(inflation)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-mint\\#fetch-the-annual-provisions)    Fetch the annual provisions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcMintApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcMintApi = new ChainGrpcMintApi(endpoints.grpc)\n\nconst annualProvisions = await chainGrpcMintApi.fetchAnnualProvisions()\n\nconsole.log(annualProvisions)\n```\n\n[PreviousIBC](https://docs.ts.injective.network/querying/querying-chain/querying-chain-ibc) [NextInsurance Funds](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds)\n\nLast updated 12 months ago\n\n<|firecrawl-page-29-lllmstxt|>\n## Querying Insurance Funds\nExample code snippets to query data related to the insurance fund on chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds\\#fetch-default-redemption-notice-period-duration)    Fetch default redemption notice period duration\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcInsuranceFundApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcInsuranceFundApi = new ChainGrpcInsuranceFundApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcInsuranceFundApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds\\#fetch-insurance-funds-and-associated-metadata)    Fetch insurance funds and associated metadata\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcInsuranceFundApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcInsuranceFundApi = new ChainGrpcInsuranceFundApi(endpoints.grpc)\n\nconst insuranceFunds = await chainGrpcInsuranceFundApi.fetchInsuranceFunds()\n\nconsole.log(insuranceFunds)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds\\#fetch-insurance-fund-and-associated-metadata-based-on-the-market-id)    Fetch insurance fund and associated metadata based on the market ID\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcInsuranceFundApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcInsuranceFundApi = new ChainGrpcInsuranceFundApi(endpoints.grpc)\n\nconst marketId = '0x...'\nconst insuranceFund = await chainGrpcInsuranceFundApi.fetchInsuranceFund(\n  marketId,\n)\n\nconsole.log(insuranceFund)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds\\#fetch-estimated-redemptions-for-a-given-injective-address-for-a-market)    Fetch estimated redemptions for a given injective address for a market\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcInsuranceFundApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcInsuranceFundApi = new ChainGrpcInsuranceFundApi(endpoints.grpc)\n\nconst marketId = '0x...'\nconst injectiveAddress = 'inj...'\n\nconst estimatedRedemptions =\n  await chainGrpcInsuranceFundApi.fetchEstimatedRedemptions({\n    marketId,\n    address: injectiveAddress,\n  })\n\nconsole.log(estimatedRedemptions)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds\\#fetch-pending-redemptions-for-a-given-injective-address-for-a-market)    Fetch pending redemptions for a given injective address for a market\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcInsuranceFundApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcInsuranceFundApi = new ChainGrpcInsuranceFundApi(endpoints.grpc)\n\nconst marketId = '0x...'\nconst injectiveAddress = 'inj...'\n\nconst pendingRedemptions =\n  await chainGrpcInsuranceFundApi.fetchPendingRedemptions({\n    marketId,\n    address: injectiveAddress,\n  })\n\nconsole.log(pendingRedemptions)\n```\n\n[PreviousMint](https://docs.ts.injective.network/querying/querying-chain/querying-chain-mint) [NextOracle](https://docs.ts.injective.network/querying/querying-chain/querying-chain-oracle)\n\nLast updated 12 months ago\n\n<|firecrawl-page-30-lllmstxt|>\n## Querying Chain Oracle\nExample code snippets to query the chain via the oracle api.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-oracle\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-oracle\\#fetch-parameters-related-to-the-oracle)    Fetch parameters related to the oracle\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcOracleApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcOracleApi = new ChainGrpcOracleApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcOracleApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n[PreviousInsurance Funds](https://docs.ts.injective.network/querying/querying-chain/querying-chain-insurance-funds) [NextPeggy](https://docs.ts.injective.network/querying/querying-chain/querying-chain-peggy)\n\nLast updated 12 months ago\n\n<|firecrawl-page-31-lllmstxt|>\n## Querying Peggy API\nExample code snippets to query the chain via the peggy api.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-peggy\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-peggy\\#fetch-parameters-related-to-peggy)    Fetch parameters related to peggy\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcPeggyApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcPeggyApi = new ChainGrpcPeggyApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcPeggyApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n[PreviousOracle](https://docs.ts.injective.network/querying/querying-chain/querying-chain-oracle) [NextPermissions](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions)\n\nLast updated 12 months ago\n\n<|firecrawl-page-32-lllmstxt|>\n## Querying Chain Permissions\nExample code snippets to query data related to the permissions module on chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions\\#fetch-all-namespaces)    Fetch all namespaces\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcPermissionsApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcPermissionsApi = new ChainGrpcPermissionsApi(endpoints.grpc)\n\nconst allNamespaces = await chainGrpcPermissionsApi.fetchAllNamespaces()\n\nconsole.log(allNamespaces)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions\\#fetch-a-namespace-based-on-the-denom)    Fetch a namespace based on the denom\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcPermissionsApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcPermissionsApi = new ChainGrpcPermissionsApi(endpoints.grpc)\n\nconst subdenom = 'NINJA'\nconst includeRoles = true\n\nconst namespace = await chainGrpcPermissionsApi.fetchNamespaceByDenom({\n  subdenom,\n  includeRoles: includeRoles,\n})\n\nconsole.log(namespace)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions\\#fetch-all-roles-that-are-associated-to-an-address-based-on-the-denom)    Fetch all roles that are associated to an address based on the denom\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcPermissionsApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcPermissionsApi = new ChainGrpcPermissionsApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj...'\nconst subdenom = 'NINJA'\n\nconst addressRoles = await chainGrpcPermissionsApi.fetchAddressRoles({\n  injectiveAddress,\n  denom: subdenom,\n})\n\nconsole.log(addressRoles)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions\\#fetch-all-addresses-that-are-associated-to-a-given-role-for-a-denom)    Fetch all addresses that are associated to a given role for a denom\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcPermissionsApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcPermissionsApi = new ChainGrpcPermissionsApi(endpoints.grpc)\n\nconst subdenom = 'NINJA'\nconst role = 'role'\n\nconst addressesByRole = await chainGrpcPermissionsApi.fetchAddressesByRole({\n    subdenom,\n    role: role,\n})\n\nconsole.log(addressesByRole)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions\\#fetch-vouchers-for-a-given-injective-address)    Fetch vouchers for a given injective address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcPermissionsApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcPermissionsApi = new ChainGrpcPermissionsApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj...'\n\nconst vouchers = await chainGrpcPermissionsApi.fetchVouchersForAddress(\n    injectiveAddress,\n)\n\nconsole.log(vouchers)\n```\n\n[PreviousPeggy](https://docs.ts.injective.network/querying/querying-chain/querying-chain-peggy) [NextStaking](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking)\n\nLast updated 6 months ago\n\n<|firecrawl-page-33-lllmstxt|>\n## Querying Chain Staking\nExample code snippets to query the chain's staking module\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-parameters-related-to-the-staking-module-such-as-the-unbonding-time-or-bond-denom)    Fetch parameters related to the staking module such as the unbonding time or bond denom\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcStakingApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-unbonded-and-bonded-tokens-for-a-pool)    Fetch unbonded and bonded tokens for a pool\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst pool = await chainGrpcStakingApi.fetchPool()\n\nconsole.log(pool)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-validators-and-associated-metadata)    Fetch validators and associated metadata\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst validators = await chainGrpcStakingApi.fetchValidators()\n\nconsole.log(validators)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-validator-and-associated-metadata-from-a-validator-address)    Fetch validator and associated metadata from a validator address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst validatorAddress = 'injvaloper...'\n\nconst validator = await chainGrpcStakingApi.fetchValidator(validatorAddress)\n\nconsole.log(validator)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-delegations-associated-with-a-validator)    Fetch delegations associated with a validator\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst validatorAddress = 'injvaloper...'\nconst pagination = {...} as PaginationOption\n\nconst delegations = await chainGrpcStakingApi.fetchValidatorDelegationsNoThrow({\n  validatorAddress,\n  pagination /* optional pagination options */\n})\n\nconsole.log(delegations)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-unbonding-delegations-associated-with-a-validator)    Fetch unbonding delegations associated with a validator\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst validatorAddress = 'injvaloper...'\nconst pagination = {...} as PaginationOption\n\nconst unbondingDelegations = await chainGrpcStakingApi.fetchValidatorUnbondingDelegationsNoThrow({\n  validatorAddress,\n  pagination /* optional pagination options */\n})\n\nconsole.log(unbondingDelegations)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-delegations-associated-with-an-injective-address-for-a-specific-validator)    Fetch delegations associated with an injective address for a specific validator\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj...'\nconst validatorAddress = 'injvaloper...'\n\nconst delegation = await chainGrpcStakingApi.fetchDelegation({\n  injectiveAddress,\n  validatorAddress,\n})\n\nconsole.log(delegation)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-delegations-for-an-injective-address)    Fetch delegations for an injective address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj...'\nconst pagination = {...} as PaginationOption\n\nconst delegations = await chainGrpcStakingApi.fetchDelegationsNoThrow({\n  injectiveAddress,\n  pagination /* optional pagination options */\n})\n\nconsole.log(delegations)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-delegators-for-a-validator)    Fetch delegators for a validator\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst validatorAddress = 'injvaloper...'\nconst pagination = {...} as PaginationOption\n\nconst delegators = await chainGrpcStakingApi.fetchDelegatorsNoThrow({\n  validatorAddress,\n  pagination /* optional pagination options */\n})\n\nconsole.log(delegators)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-unbonding-delegations-for-an-injective-address)    Fetch unbonding delegations for an injective address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj...'\nconst pagination = {...} as PaginationOption\n\nconst unbondingDelegations = await chainGrpcStakingApi.fetchUnbondingDelegationsNoThrow({\n  injectiveAddress,\n  pagination /* optional pagination options */\n})\n\nconsole.log(unbondingDelegations)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking\\#fetch-redelegations-for-an-injective-address)    Fetch redelegations for an injective address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcStakingApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcStakingApi = new ChainGrpcStakingApi(endpoints.grpc)\n\nconst injectiveAddress = 'inj...'\nconst pagination = {...} as PaginationOption\n\nconst unbondingDelegations = await chainGrpcStakingApi.fetchReDelegationsNoThrow({\n  injectiveAddress,\n  pagination /* optional pagination options */\n})\n\nconsole.log(unbondingDelegations)\n```\n\n[PreviousPermissions](https://docs.ts.injective.network/querying/querying-chain/querying-chain-permissions) [NextTendermint](https://docs.ts.injective.network/querying/querying-chain/querying-chain-tendermint)\n\nLast updated 12 months ago\n\n<|firecrawl-page-34-lllmstxt|>\n## Querying Chain Data\nExample code snippets to query for chain node related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-tendermint\\#using-http-rest)    Using HTTP REST\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-tendermint\\#fetch-the-latest-block-info)    Fetch the latest block info\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainRestTendermintApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainRestTendermintApi = new ChainRestTendermintApi(endpoints.rest)\n\nconst latestBlock = await chainRestTendermintApi.fetchLatestBlock()\n\nconsole.log(latestBlock)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-tendermint\\#fetch-chain-node-info)    Fetch chain node info\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainRestTendermintApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainRestTendermintApi = new ChainRestTendermintApi(endpoints.rest)\n\nconst nodeInfo = await chainRestTendermintApi.fetchNodeInfo()\n\nconsole.log(nodeInfo)\n```\n\n[PreviousStaking](https://docs.ts.injective.network/querying/querying-chain/querying-chain-staking) [NextWasm](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm)\n\nLast updated 12 months ago\n\n<|firecrawl-page-35-lllmstxt|>\n## Querying Injective WASM\nExample code snippets to query the wasm module on chain\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm\\#fetch-contacts-account-balance-note-that-pagination-parameters-can-be-passed-to-obtain-additional-ac)    Fetch contacts' account balance Note that pagination parameters can be passed to obtain additional accounts.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcWasmApi, PaginationOption } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst contractAddress = 'inj...'\nconst pagination = {...} as PaginationOption\n\nconst contractAccountsBalance = await chainGrpcWasmApi.fetchContractAccountsBalance({\n    contractAddress,\n    pagination /* optional pagination options */\n})\n\nconsole.log(contractAccountsBalance)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm\\#fetch-info-related-to-a-contract)    Fetch info related to a contract\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcWasmApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst contractAddress = 'inj...'\n\nconst contractInfo = await chainGrpcWasmApi.fetchContractInfo(contractAddress)\n\nconsole.log(contractInfo)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm\\#fetch-contract-history)    Fetch contract history\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcWasmApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst contractAddress = 'inj...'\n\nconst contractHistory = await chainGrpcWasmApi.fetchContractHistory(\n  contractAddress,\n)\n\nconsole.log(contractHistory)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm\\#fetch-the-state-of-a-smart-contract)    Fetch the state of a smart contract\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcWasmApi, toBase64 } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst contractAddress = 'inj...'\nconst query = '...'\nconst queryFromObject = toBase64({ get_coin: {} })\n\nconst contractState = await chainGrpcWasmApi.fetchSmartContractState({\n  contractAddress,\n  query /* optional string query - HAS to be in base64 or use queryFromObject */,\n})\n\nconsole.log(contractState)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm\\#fetch-the-raw-state-of-a-smart-contract)    Fetch the raw state of a smart contract\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcWasmApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst contractAddress = 'inj...'\nconst query = '...'\nconst queryFromObject = toBase64({ get_coin: {} })\n\nconst rawContractState = await chainGrpcWasmApi.fetchRawContractState({\n  contractAddress,\n  query /* optional string query - HAS to be in base64 or use queryFromObject */,\n})\n\nconsole.log(rawContractState)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm\\#fetch-the-codes-associated-with-a-contract)    Fetch the codes associated with a contract\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcWasmApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst pagination = {...} as PaginationOption\n\nconst rawContractState = await chainGrpcWasmApi.fetchRawContractState(\npagination /* optional pagination options */\n)\n\nconsole.log(rawContractState)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm\\#fetch-info-associated-with-a-contract-code)    Fetch info associated with a contract code\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcWasmApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst codeId = 1\n\nconst codeDetails = await chainGrpcWasmApi.fetchContractCode(codeId)\n\nconsole.log(codeDetails)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm\\#fetch-the-contracts-associated-with-a-code)    Fetch the contracts associated with a code\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, ChainGrpcWasmApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst codeId = 1\nconst pagination = {...} as PaginationOption\n\nconst contracts = await chainGrpcWasmApi.fetchContractCodeContracts({\n  codeId,\n  pagination /* optional pagination options */\n})\n\nconsole.log(contracts)\n```\n\n[PreviousTendermint](https://docs.ts.injective.network/querying/querying-chain/querying-chain-tendermint) [NextWasmX](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasmx)\n\nLast updated 12 months ago\n\n<|firecrawl-page-36-lllmstxt|>\n## Querying wasmX Module\nExample code snippets to query the wasmX module on chain\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasmx\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasmx\\#fetch-parameters-related-to-the-wasmx-module)    Fetch parameters related to the wasmX module\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcWasmXApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmXApi = new ChainGrpcWasmXApi(endpoints.grpc)\n\nconst moduleParams = await chainGrpcWasmXApi.fetchModuleParams()\n\nconsole.log(moduleParams)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasmx\\#fetch-the-wasmx-module-state)    Fetch the wasmX module state\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcWasmXApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmXApi = new ChainGrpcWasmXApi(endpoints.grpc)\n\nconst moduleState = await chainGrpcWasmXApi.fetchModuleState()\n\nconsole.log(moduleState)\n```\n\n[PreviousWasm](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasm) [NextToken Factory](https://docs.ts.injective.network/querying/querying-chain/token-factory)\n\nLast updated 12 months ago\n\n<|firecrawl-page-37-lllmstxt|>\n## Token Factory Queries\nExample code snippets to query the chain for token factory module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/token-factory\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/token-factory\\#fetch-all-denoms-created-by-creator)    Fetch all denoms created by _creator_\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcTokenFactoryApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcTokenFactoryApi = new ChainGrpcTokenFactoryApi(endpoints.grpc)\n\nconst creator = 'inj...'\nconst denoms = await chainGrpcTokenFactoryApi.fetchDenomsFromCreator(creator)\n\nconsole.log(denoms)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-chain/token-factory\\#fetch-denom-authority-metadata-i.e-fetch-admin-of-a-token)    Fetch denom authority metadata (i.e fetch admin of a token)\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcTokenFactoryApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcTokenFactoryApi = new ChainGrpcTokenFactoryApi(endpoints.grpc)\n\nconst creator = 'inj...'\nconst subdenom = 'NINJA'\nconst metadata = await chainGrpcTokenFactoryApi.fetchDenomAuthorityMetadata(\n  creator,\n  subdenom,\n)\n\nconsole.log(metadata)\n```\n\n[PreviousWasmX](https://docs.ts.injective.network/querying/querying-chain/querying-chain-wasmx) [NextIndexer](https://docs.ts.injective.network/querying/querying-api)\n\nLast updated 12 months ago\n\n<|firecrawl-page-38-lllmstxt|>\n## Querying Injective API\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api\\#querying-the-indexer)    Querying the Indexer\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api\\#topics)    Topics\n\nTopic\n\nDescription\n\n[Account](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account)\n\nQuerying data from the account module\n\n[Auction](https://docs.ts.injective.network/querying/querying-api/querying-indexer-auction)\n\nQuerying data from the auction module\n\n[Derivatives](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives)\n\nQuery data from the derivatives module\n\n[Explorer](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer)\n\nQuery data related to the explorer module\n\n[Leaderboard](https://docs.ts.injective.network/querying/querying-api/querying-indexer-leaderboard)\n\nQuery data related to the leaderboard module\n\n[Insurance Fund](https://docs.ts.injective.network/querying/querying-api/querying-indexer-insurance-funds)\n\nQuery data from the insurance fund module\n\n[Markets](https://docs.ts.injective.network/querying/querying-api/querying-indexer-markets)\n\nQuery data for both spot and derivatives markets\n\n[Mito](https://docs.mito.fi/)\n\nQuery data from the ninja vaults module\n\n[Oracle](https://docs.ts.injective.network/querying/querying-api/querying-indexer-oracle)\n\nQuery data related to the oracle\n\n[Portfolio](https://docs.ts.injective.network/querying/querying-api/querying-indexer-portfolio)\n\nQuery data related to the portfolio module\n\n[Spot](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot)\n\nQuery data from the spot module\n\n[Transaction](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction)\n\nQuery data related to the transaction module\n\n[PreviousToken Factory](https://docs.ts.injective.network/querying/querying-chain/token-factory) [NextAccount](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account)\n\nLast updated 12 months ago\n\n<|firecrawl-page-39-lllmstxt|>\n## Querying Indexer Account\nExample code snippets to query the indexer for subaccount related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account\\#fetch-users-portfolio-details)    Fetch user's portfolio details\n\nThis includes available balance, unrealized Pnl, and portfolio value. Note: **deprecated** -\\> use [Portfolio](https://docs.ts.injective.network/querying/querying-api/querying-indexer-portfolio#using-grpc) instead\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountApi = new IndexerGrpcAccountApi(endpoints.indexer)\n\nconst injectiveAddress = 'inj...'\n\nconst portfolio = await indexerGrpcAccountApi.fetchPortfolio(injectiveAddress)\n\nconsole.log(portfolio)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account\\#fetch-users-trading-rewards-per-epoch)    Fetch user's trading rewards per epoch\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountApi = new IndexerGrpcAccountApi(endpoints.indexer)\n\nconst injectiveAddress = 'inj...'\nconst epoch = -1 // current epoch\n\nconst tradingRewards = await indexerGrpcAccountApi.fetchRewards({\n  address: injectiveAddress,\n  epoch,\n})\n\nconsole.log(tradingRewards)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account\\#fetch-subaccounts-associated-with-an-injective-address)    Fetch subaccounts associated with an injective address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountApi = new IndexerGrpcAccountApi(endpoints.indexer)\n\nconst injectiveAddress = 'inj...'\n\nconst subaccountsList = await indexerGrpcAccountApi.fetchSubaccountsList(\n  injectiveAddress,\n)\n\nconsole.log(subaccountsList)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account\\#fetch-balance-of-a-subaccount-for-a-specific-denom)    Fetch balance of a subaccount for a specific denom\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountApi = new IndexerGrpcAccountApi(endpoints.indexer)\n\nconst subaccountId = '0x...'\nconst denom = 'inj'\n\nconst subaccountBalance = await indexerGrpcAccountApi.fetchSubaccountBalance(\n  subaccountId,\n  denom,\n)\n\nconsole.log(subaccountBalance)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account\\#fetch-of-balances-for-a-subaccount)    Fetch of balances for a subaccount\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountApi = new IndexerGrpcAccountApi(endpoints.indexer)\n\nconst subaccountId = '0x...'\n\nconst subaccountBalanceList =\n  await indexerGrpcAccountApi.fetchSubaccountBalancesList(subaccountId)\n\nconsole.log(subaccountBalanceList)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account\\#fetch-subacount-history)    Fetch subacount history\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, IndexerGrpcAccountApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountApi = new IndexerGrpcAccountApi(endpoints.indexer)\n\nconst subaccountId = '0x...'\nconst denom = 'inj'\nconst pagination = {...} as PaginationOption\n\nconst subaccountHistory = await indexerGrpcAccountApi.fetchSubaccountHistory({\n  subaccountId,\n  denom,\n  pagination /* optional param */\n})\n\nconsole.log(subaccountHistory)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account\\#fetch-a-summary-of-a-subaccounts-orders)    Fetch a summary of a subaccount's orders\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountApi = new IndexerGrpcAccountApi(endpoints.indexer)\n\nconst subaccountId = '0x...'\nconst marketId = '0x'\nconst orderDirection = 'buy'\n\nconst orderSummary = await indexerGrpcAccountApi.fetchSubaccountOrderSummary({\n  subaccountId,\n  marketId,\n  orderDirection,\n})\n\nconsole.log(orderSummary)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account\\#fetch-states-of-spot-or-and-derivatives-orders)    Fetch states of spot or (and) derivatives orders\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountApi = new IndexerGrpcAccountApi(endpoints.indexer)\n\nconst spotOrderHashes = ['0x...']\nconst derivativeOrderHashes = ['0x...']\n\nconst orderStates = await indexerGrpcAccountApi.fetchOrderStates({\n  spotOrderHashes,\n  derivativeOrderHashes,\n})\n\nconsole.log(orderStates)\n```\n\n[PreviousIndexer](https://docs.ts.injective.network/querying/querying-api) [NextAuction](https://docs.ts.injective.network/querying/querying-api/querying-indexer-auction)\n\nLast updated 12 months ago\n\n<|firecrawl-page-40-lllmstxt|>\n## Querying Auction Data\nExample code snippets to query the indexer for auction module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-auction\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-auction\\#fetch-auction-based-off-the-round)    Fetch auction based off the round\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAuctionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAuctionApi = new IndexerGrpcAuctionApi(endpoints.indexer)\n\nconst round = 1\n\nconst auction = await indexerGrpcAuctionApi.fetchAuction(round)\n\nconsole.log(auction)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-auction\\#fetch-auctions)    Fetch auctions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAuctionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAuctionApi = new IndexerGrpcAuctionApi(endpoints.indexer)\n\nconst auction = await indexerGrpcAuctionApi.fetchAuctions()\n\nconsole.log(auction)\n```\n\n[PreviousAccount](https://docs.ts.injective.network/querying/querying-api/querying-indexer-account) [NextDerivatives](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives)\n\nLast updated 12 months ago\n\n<|firecrawl-page-41-lllmstxt|>\n## Querying Derivatives API\nExample code snippets to query the indexer for derivative module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-markets)    Fetch markets\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(\n  endpoints.indexer,\n)\n\nconst markets = await indexerGrpcDerivativesApi.fetchMarkets()\n\nconsole.log(markets)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-market-based-on-a-market-id)    Fetch market based on a market id\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(\n  endpoints.indexer,\n)\n\nconst marketId = '0x...'\n\nconst market = await indexerGrpcDerivativesApi.fetchMarket(marketId)\n\nconsole.log(market)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-binary-options-markets)    Fetch binary options markets\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(\n  endpoints.indexer,\n)\n\nconst binaryOptionsMarket =\n  await indexerGrpcDerivativesApi.fetchBinaryOptionsMarkets()\n\nconsole.log(binaryOptionsMarket)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-binary-options-market-based-on-market-id)    Fetch binary options market based on market id\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(\n  endpoints.indexer,\n)\n\nconst marketId = '0x...'\n\nconst binaryOptionsMarket =\n  await indexerGrpcDerivativesApi.fetchBinaryOptionsMarket(marketId)\n\nconsole.log(binaryOptionsMarket)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-a-markets-orderbook-based-on-market-id)    Fetch a market's orderbook based on market id\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(\n  endpoints.indexer,\n)\n\nconst marketId = '0x...'\n\nconst orderbook = await indexerGrpcDerivativesApi.fetchOrderbook(marketId)\n\nconsole.log(orderbook)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-a-markets-orders)    Fetch a market's orders\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, IndexerGrpcDerivativesApi } from '@injectivelabs/sdk-ts'\nimport { OrderSide } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst orderSide = OrderSide.Buy /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst orders = await indexerGrpcDerivativesApi.fetchOrders({\n  marketId,\n  orderSide,\n  subaccountId,\n  pagination\n})\n\nconsole.log(orders)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-a-markets-order-history)    Fetch a market's order history\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TradeDirection,\n  PaginationOption,\n  TradeExecutionType,\n  IndexerGrpcDerivativesApi\n} from '@injectivelabs/sdk-ts'\nimport { OrderSide } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(endpoints.indexer)\n\nconst marketIds = ['0x...'] /* optional param */\nconst executionTypes = [TradeExecutionType.Market] /* optional param */\nconst orderTypes = OrderSide.StopBuy /* optional param */\nconst direction = TradeDirection.Buy /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst orderHistory = await indexerGrpcDerivativesApi.fetchOrderHistory({\n  marketIds,\n  executionTypes,\n  orderTypes,\n  direction,\n  subaccountId,\n  pagination\n})\n\nconsole.log(orderHistory)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-a-markets-positions)    Fetch a market's positions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TradeDirection,\n  PaginationOption,\n  IndexerGrpcDerivativesApi\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(endpoints.indexer)\n\nconst marketIds = ['0x...'] /* optional param */\nconst direction = TradeDirection.Buy /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst positions = await indexerGrpcDerivativesApi.fetchPositions({\n  marketIds,\n  direction,\n  subaccountId,\n  pagination\n})\n\nconsole.log(positions)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-a-markets-trades)    Fetch a market's trades\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TradeDirection,\n  PaginationOption,\n  TradeExecutionType,\n  IndexerGrpcDerivativesApi\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst executionTypes = [TradeExecutionType.Market] /* optional param */\nconst direction = TradeDirection.Buy /* optional param */\nconst subaccountId = '0x...'/* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst trades = await indexerGrpcDerivativesApi.fetchTrades({\n  marketId,\n  executionTypes,\n  direction,\n  subaccountId,\n  pagination\n})\n\nconsole.log(trades)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-funding-payments-for-a-market)    Fetch funding payments for a market\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  PaginationOption,\n  IndexerGrpcDerivativesApi\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(endpoints.indexer)\n\nconst marketIds = ['0x...'] /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst fundingPayments = await indexerGrpcDerivativesApi.fetchFundingPayments({\n  marketIds,\n  pagination\n})\n\nconsole.log(fundingPayments)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-funding-rates-for-a-market)    Fetch funding rates for a market\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  PaginationOption,\n  IndexerGrpcDerivativesApi\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst fundingRates = await indexerGrpcDerivativesApi.fetchFundingRates({\n  marketId,\n  pagination\n})\n\nconsole.log(fundingRates)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-subaccount-orders)    Fetch subaccount orders\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  PaginationOption,\n  IndexerGrpcDerivativesApi\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst subaccountOrders = await indexerGrpcDerivativesApi.fetchSubaccountOrdersList({\n  marketId,\n  subaccountId,\n  pagination\n})\n\nconsole.log(subaccountOrders)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-subaccount-trades)    Fetch subaccount trades\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TradeDirection,\n  TradeExecutionType,\n  PaginationOption,\n  IndexerGrpcDerivativesApi\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst executionType = TradeExecutionType.LimitFill /* optional param */\nconst direction = TradeDirection.Sell /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst subaccountTrades = await indexerGrpcDerivativesApi.fetchSubaccountTradesList({\n  marketId,\n  subaccountId,\n  executionType,\n  direction,\n  pagination\n})\n\nconsole.log(subaccountTrades)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-orderbooks-for-multiple-markets)    Fetch orderbooks for multiple markets\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(\n  endpoints.indexer,\n)\n\nconst marketIds = ['0x...']\n\nconst orderbooks = await indexerGrpcDerivativesApi.fetchOrderbooksV2(marketIds)\n\nconsole.log(orderbooks)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-orderbook-for-a-market)    Fetch orderbook for a market\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesApi = new IndexerGrpcDerivativesApi(\n  endpoints.indexer,\n)\n\nconst marketId = '0x...'\n\nconst orderbook = await indexerGrpcDerivativesApi.fetchOrderbookV2(marketId)\n\nconsole.log(orderbook)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#using-http-rest)    Using HTTP REST\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-market-summary-such-as-a-history-of-prices-and-24-hr-volume)    Fetch market summary, such as a history of prices and 24 hr volume\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestDerivativesChronosApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestDerivativesChronosApi = new IndexerRestDerivativesChronosApi(\n  `${endpoints.chronos}/api/chronos/v1/derivative`,\n)\n\nconst marketId = '0x...'\n\nconst marketSummary = await indexerRestDerivativesChronosApi.fetchMarketSummary(\n  marketId,\n)\n\nconsole.log(marketSummary)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives\\#fetch-all-markets-summaries-such-as-a-history-of-prices-and-24-hr-volume)    Fetch all markets' summaries, such as a history of prices and 24 hr volume\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestDerivativesChronosApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestDerivativesChronosApi = new IndexerRestDerivativesChronosApi(\n  `${endpoints.chronos}/api/chronos/v1/derivative`,\n)\n\nconst marketSummaries =\n  await indexerRestDerivativesChronosApi.fetchMarketsSummary(marketId)\n\nconsole.log(marketSummaries)\n```\n\n[PreviousAuction](https://docs.ts.injective.network/querying/querying-api/querying-indexer-auction) [NextExplorer](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer)\n\nLast updated 12 months ago\n\n<|firecrawl-page-42-lllmstxt|>\n## Indexer Explorer API\nExample code snippets to query the indexer for explorer module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-transaction-by-hash)    Fetch transaction by hash\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst txsHash = '...'\n\nconst transaction = await indexerGrpcExplorerApi.fetchTxByHash(txsHash)\n\nconsole.log(transaction)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-an-account-transaction-by-address)    Fetch an account transaction by address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst injectiveAddress = 'inj...'\n\nconst account = await indexerGrpcExplorerApi.fetchAccountTx({\n  injectiveAddress,\n})\n\nconsole.log(account)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-a-validator-by-address)    Fetch a validator by address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst validatorAddress = 'injvaloper...'\n\nconst validator = await indexerGrpcExplorerApi.fetchValidator(validatorAddress)\n\nconsole.log(validator)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-a-validators-uptime-by-address)    Fetch a validator's uptime by address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst validatorAddress = 'injvaloper...'\n\nconst validatorUptime = await indexerGrpcExplorerApi.fetchValidatorUptime(\n  validatorAddress,\n)\n\nconsole.log(validatorUptime)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-a-validators-uptime-by-address-1)    Fetch a validator's uptime by address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst validatorAddress = 'injvaloper...'\n\nconst validatorUptime = await indexerGrpcExplorerApi.fetchValidatorUptime(\n  validatorAddress,\n)\n\nconsole.log(validatorUptime)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-peggy-deposit-transactions-from-ethereum)    Fetch Peggy deposit transactions from Ethereum\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst sender = '0x...' /* optional parameter */\nconst receiver = 'inj...' /* optional parameter */\nconst limit = 100 /* optional pagination parameter */\nconst skip = 20 /* optional pagination parameter */\n\nconst peggyDeposits = await indexerGrpcExplorerApi.fetchPeggyDepositTxs({\n  sender,\n  receiver,\n  limit,\n  skip,\n})\n\nconsole.log(peggyDeposits)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-peggy-withdrawal-transactions-to-ethereum)    Fetch Peggy withdrawal transactions to Ethereum\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst receiver = '0x...' /* optional parameter */\nconst sender = 'inj...' /* optional parameter */\nconst limit = 100 /* optional pagination parameter */\nconst skip = 20 /* optional pagination parameter */\n\nconst peggyWithdrawals = await indexerGrpcExplorerApi.fetchPeggyWithdrawalTxs({\n  sender,\n  receiver,\n  limit,\n  skip,\n})\n\nconsole.log(peggyWithdrawals)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-blocks)    Fetch blocks\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst after = 30 /* optional pagination parameter */\nconst limit = 100 /* optional pagination parameter */\n\nconst blocks = await indexerGrpcExplorerApi.fetchBlocks({\n  after,\n  limit,\n})\n\nconsole.log(blocks)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-block-by-height)    Fetch block by height\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst height = 123456\nconst block = await indexerGrpcExplorerApi.fetchBlock(height)\n\nconsole.log(block)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-transactions)    Fetch transactions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst after = 20 /* optional pagination parameter */\nconst limit = 100 /* optional pagination parameter */\n\nconst transactions = await indexerGrpcExplorerApi.fetchTxs({\n  after,\n  limit,\n})\n\nconsole.log(transactions)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-ibc-transfer-transactions)    Fetch IBC transfer transactions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerGrpcExplorerApi(endpoints.explorer)\n\nconst sender = 'osmo...'\nconst receiver = 'inj...'\n\nconst ibcTransactions = await indexerGrpcExplorerApi.fetchIBCTransferTxs({\n  sender,\n  receiver,\n})\n\nconsole.log(ibcTransactions)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#using-http-rest)    Using HTTP REST\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-a-block-and-details)    Fetch a block and details\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst blockHashHeight = 1\n\nconst block = await indexerRestExplorerApi.fetchBlock(blockHashHeight)\n\nconsole.log(block)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-blocks-and-details)    Fetch blocks and details\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst before = 200 /* optional pagination param */\nconst limit = 100 /* optional pagination param */\n\nconst blocks = await indexerRestExplorerApi.fetchBlocks({\n  before,\n  limit,\n})\n\nconsole.log(blocks)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-blocks-with-transaction-details)    Fetch blocks with transaction details\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst before = 200 /* optional pagination param */\nconst limit = 100 /* optional pagination param */\n\nconst blocks = await indexerRestExplorerApi.fetchBlocksWithTx({\n  before,\n  limit,\n})\n\nconsole.log(blocks)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-transactions-1)    Fetch transactions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst after = 200 /* optional pagination param */\nconst limit = 100 /* optional pagination param */\nconst fromNumber = 1 /* optional param */\nconst toNumber = 100 /* optional param */\n\nconst transactions = await indexerRestExplorerApi.fetchTransactions({\n  after,\n  limit,\n  fromNumber,\n  toNumber,\n})\n\nconsole.log(transactions)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-transactions-for-an-address)    Fetch transactions for an address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst account = 'inj...'\nconst after = 200 /* optional pagination param */\nconst limit = 100 /* optional pagination param */\nconst fromNumber = 1 /* optional param */\nconst toNumber = 100 /* optional param */\n\nconst accountTransactions =\n  await indexerRestExplorerApi.fetchAccountTransactions({\n    account,\n    params: {\n      account,\n      after,\n      limit,\n      fromNumber,\n      toNumber,\n    },\n  })\n\nconsole.log(accountTransactions)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-transaction-using-transaction-hash)    Fetch transaction using transaction hash\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst txsHash = '...'\n\nconst transaction = await indexerRestExplorerApi.fetchTransaction(txsHash)\n\nconsole.log(transaction)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-validators)    Fetch validators\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst validators = await indexerRestExplorerApi.fetchValidators()\n\nconsole.log(validators)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-validator-uptime)    Fetch validator uptime\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst validatorAddress = 'injvalcons'\n\nconst validatorUptime = await indexerRestExplorerApi.fetchValidatorUptime(\n  validatorAddress,\n)\n\nconsole.log(validatorUptime)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-a-contract-by-contract-address)    Fetch a contract by contract address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst contractAddress = 'inj...'\n\nconst contract = await indexerRestExplorerApi.fetchContract(contractAddress)\n\nconsole.log(contract)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-contracts)    Fetch contracts\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst limit = 100 /* optional pagination param */\nconst skip = 50 /* optional pagination param */\n\nconst contracts = await indexerRestExplorerApi.fetchContracts({\n  limit,\n  skip,\n})\n\nconsole.log(contracts)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-contract-transactions)    Fetch contract transactions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst contractAddress = 'inj...'\nconst limit = 100 /* optional pagination param */\nconst skip = 50 /* optional pagination param */\n\nconst transactions = await indexerRestExplorerApi.fetchContractTransactions({\n  contractAddress,\n  params: {\n    limit,\n    skip,\n  },\n})\n\nconsole.log(transactions)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-cosmwasm-code-details)    Fetch cosmwasm code details\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst codeId = 1\n\nconst codeDetails = await indexerRestExplorerApi.fetchWasmCode(codeId)\n\nconsole.log(codeDetails)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-wasm-codes-and-details)    Fetch wasm codes and details\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst limit = 100 /* optional pagination param */\nconst fromNumber = 50 /* optional pagination param */\nconst toNumber = 150 /* optional pagination param */\n\nconst codes = await indexerRestExplorerApi.fetchWasmCodes({\n  limit,\n  fromNumber,\n  toNumber,\n})\n\nconsole.log(codes)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer\\#fetch-cw20-balances)    Fetch cw20 balances\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestExplorerApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestExplorerApi = new IndexerRestExplorerApi(\n  `${endpoints.explorer}/api/explorer/v1`,\n)\n\nconst address = 'inj...'\n\nconst cw20Balances = await indexerRestExplorerApi.fetchCW20BalancesNoThrow(\n  address,\n)\n\nconsole.log(cw20Balances)\n```\n\n[PreviousDerivatives](https://docs.ts.injective.network/querying/querying-api/querying-indexer-derivatives) [NextInsurance Funds](https://docs.ts.injective.network/querying/querying-api/querying-indexer-insurance-funds)\n\nLast updated 12 months ago\n\n<|firecrawl-page-43-lllmstxt|>\n## Querying Insurance Funds\nExample code snippets to query the indexer for insurance fund module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-insurance-funds\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-insurance-funds\\#fetch-redemptions-for-an-injective-address)    Fetch redemptions for an injective address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcInsuranceFundApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcInsuranceFundApi = new IndexerGrpcInsuranceFundApi(\n  endpoints.indexer,\n)\n\nconst injectiveAddress = 'inj...'\n\nconst redemptions = await indexerGrpcInsuranceFundApi.fetchRedemptions({\n  injectiveAddress,\n})\n\nconsole.log(redemptions)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-insurance-funds\\#fetch-insurance-funds)    Fetch insurance funds\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcInsuranceFundApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcInsuranceFundApi = new IndexerGrpcInsuranceFundApi(\n  endpoints.indexer,\n)\n\nconst insuranceFunds = await indexerGrpcInsuranceFundApi.fetchInsuranceFunds()\n\nconsole.log(insuranceFunds)\n```\n\n[PreviousExplorer](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer) [NextMarkets](https://docs.ts.injective.network/querying/querying-api/querying-indexer-markets)\n\nLast updated 12 months ago\n\n<|firecrawl-page-44-lllmstxt|>\n## Querying Indexer Markets\nExample code snippets to query the indexer for all markets data\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-markets\\#using-http-rest)    Using HTTP REST\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-markets\\#fetch-markets-history)    Fetch markets History\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestMarketChronosApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestMarketChronosApi = new IndexerRestMarketChronosApi(\n  `${endpoints.chronos}/api/chronos/v1/market`,\n)\n\nconst SelectList = {\n  Hour: '60',\n  Day: '1d',\n  Week: '7d',\n}\n// const resolution = MARKETS_HISTORY_CHART_ONE_HOUR\n// const countback = MARKETS_HISTORY_CHART_SEVEN_DAYS\n\nconst marketIds = ['0x']\nconst countback = 154 // in unit of hours\nconst resolution = SelectList.Day\n\nconst marketsHistory = await indexerRestMarketChronosApi.fetchMarketsHistory({\n  marketIds,\n  resolution,\n  countback,\n})\n\nconsole.log(marketsHistory)\n```\n\n[PreviousInsurance Funds](https://docs.ts.injective.network/querying/querying-api/querying-indexer-insurance-funds) [NextLeaderboard](https://docs.ts.injective.network/querying/querying-api/querying-indexer-leaderboard)\n\nLast updated 12 months ago\n\n<|firecrawl-page-45-lllmstxt|>\n## Indexer Leaderboard API\nExample code snippets to query the indexer for leaderboard module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-leaderboard\\#using-http-rest)    Using HTTP REST\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-leaderboard\\#fetch-leaderboard)    Fetch leaderboard\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestLeaderboardChronosApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerApi = new IndexerRestLeaderboardChronosApi(\n  `${endpoints.chronos}/api/chronos/v1/leaderboard`,\n)\n\nconst SelectList = {\n  Day: '1d',\n  Week: '7d',\n}\n\nconst resolution = SelectList.Day\n\nconst leaderboard = await indexerGrpcExplorerApi.fetchLeaderboard(resolution)\n\nconsole.log(leaderboard)\n```\n\n[PreviousMarkets](https://docs.ts.injective.network/querying/querying-api/querying-indexer-markets) [NextMito](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito)\n\nLast updated 12 months ago\n\n<|firecrawl-page-46-lllmstxt|>\n## Mito API Querying\nExample code snippets to query the indexer for the Mito vault module related data.\n\nMito Documentation has been moved here visit [Mito's Docs](https://docs.mito.fi/).\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito\\#outdated-using-grpc)    \\[Outdated\\] Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito\\#fetch-a-vault-based-off-its-contract-address-such-as-the-vaults-tvl-or-profits)    Fetch a vault based off it's contract address, such as the vault's tvl or profits\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcNinjaApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcNinjaApi = new IndexerGrpcNinjaApi(endpoints.ninjaApi)\n\nconst contractAddress = '0x...' /* optional param */\nconst slug = 'derivative-vault' /* optional param */\n\nconst vault = await indexerGrpcNinjaApi.fetchVault({\n  contractAddress,\n  slug,\n})\n\nconsole.log(vault)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito\\#fetch-vaults-and-associated-details)    Fetch vaults and associated details\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcNinjaApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcNinjaApi = new IndexerGrpcNinjaApi(endpoints.ninjaApi)\n\nconst vault = await indexerGrpcNinjaApi.fetchVaults()\n\nconsole.log(vault)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito\\#fetch-the-lp-token-price-chart-for-a-vault-based-on-the-vault-address)    Fetch the lp token price chart for a vault based on the vault address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcNinjaApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcNinjaApi = new IndexerGrpcNinjaApi(endpoints.ninjaApi)\n\nconst vaultAddress = 'inj...'\nconst from = 50 /* optional pagination params */\nconst to = 150 /* optional pagination params */\n\nconst lpTokenPriceChart = await indexerGrpcNinjaApi.fetchLpTokenPriceChart({\n  vaultAddress,\n  from,\n  to,\n})\n\nconsole.log(lpTokenPriceChart)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito\\#fetch-the-tvl-token-chart-for-a-vault-based-on-the-vault-address)    Fetch the tvl token chart for a vault based on the vault address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcNinjaApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcNinjaApi = new IndexerGrpcNinjaApi(endpoints.ninjaApi)\n\nconst vaultAddress = 'inj...'\nconst from = 50 /* optional pagination params */\nconst to = 150 /* optional pagination params */\n\nconst tvlChart = await indexerGrpcNinjaApi.fetchTVLChartRequest({\n  vaultAddress,\n  from,\n  to,\n})\n\nconsole.log(tvlChart)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito\\#fetch-the-vaults-associated-with-a-holder-of-its-lp-tokens)    Fetch the vaults associated with a holder of its lp tokens\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcNinjaApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcNinjaApi = new IndexerGrpcNinjaApi(endpoints.ninjaApi)\n\nconst holderAddress = 'inj...'\n\nconst vaults = await indexerGrpcNinjaApi.fetchVaultsByHolderAddress({\n  holderAddress,\n})\n\nconsole.log(vaults)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito\\#fetch-the-lp-token-holders-from-the-vault-address)    Fetch the lp token holders from the vault address\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcNinjaApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcNinjaApi = new IndexerGrpcNinjaApi(endpoints.ninjaApi)\n\nconst vaultAddress = 'inj...'\n\nconst holders = await indexerGrpcNinjaApi.fetchLPHolders({\n  vaultAddress,\n})\n\nconsole.log(holders)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito\\#fetch-the-lp-holders-portfolio)    Fetch the lp holder's portfolio\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcNinjaApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcNinjaApi = new IndexerGrpcNinjaApi(endpoints.ninjaApi)\n\nconst holderAddress = 'inj...'\n\nconst portfolio = await indexerGrpcNinjaApi.fetchHolderPortfolio(holderAddress)\n\nconsole.log(portfolio)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito\\#fetch-the-leaderboard-to-see-pnl-rankings)    Fetch the leaderboard to see Pnl rankings\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcNinjaApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcNinjaApi = new IndexerGrpcNinjaApi(endpoints.ninjaApi)\n\nconst leaderboard = await indexerGrpcNinjaApi.fetchLeaderboard()\n\nconsole.log(leaderboard)\n```\n\n[PreviousLeaderboard](https://docs.ts.injective.network/querying/querying-api/querying-indexer-leaderboard) [NextOracle](https://docs.ts.injective.network/querying/querying-api/querying-indexer-oracle)\n\nLast updated 12 months ago\n\n<|firecrawl-page-47-lllmstxt|>\n## Querying Oracle Data\nExample code snippets to query the indexer for oracle module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-oracle\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-oracle\\#fetch-list-of-oracles)    Fetch list of oracles\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcOracleApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcOracleApi = new IndexerGrpcOracleApi(endpoints.indexer)\n\nconst oracleList = await indexerGrpcOracleApi.fetchOracleList()\n\nconsole.log(oracleList)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-oracle\\#fetch-price-from-the-oracle)    Fetch price from the oracle\n\nBase and Quote oracle symbols are always fetched from the market itself. They can be in a different representation than plain symbols (i.e hashes for `pyth` oracle).\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  IndexerGrpcOracleApi,\n  IndexerGrpcDerivativeApi,\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst markets = new IndexerGrpcDerivativeApi(endpoints.indexer)\nconst indexerGrpcOracleApi = new IndexerGrpcOracleApi(endpoints.indexer)\n\nconst market = markets.find((market) => market.ticker === 'INJ/USDT PERP')\n\n// These values are a part of the market object\n// fetched from the chain i.e `oracle_base` and `oracle_quote`\nconst baseSymbol = market.oracle_base\nconst quoteSymbol = market.oracle_quote\nconst oracleType = market.oracle_type\n\nconst oraclePrice = await indexerGrpcOracleApi.fetchOraclePriceNoThrow({\n  baseSymbol,\n  quoteSymbol,\n  oracleType,\n})\n\nconsole.log(oraclePrice)\n```\n\n[PreviousMito](https://docs.ts.injective.network/querying/querying-api/querying-indexer-mito) [NextPortfolio](https://docs.ts.injective.network/querying/querying-api/querying-indexer-portfolio)\n\nLast updated 12 months ago\n\n<|firecrawl-page-48-lllmstxt|>\n## Querying Indexer Portfolio\nExample code snippets to query the indexer for portfolio module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-portfolio\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-portfolio\\#fetch-portfolio-based-on-injective-address-such-as-bank-balances-and-subaccount-balances)    Fetch portfolio based on injective address, such as bank balances and subaccount balances\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountPortfolioApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountPortfolioApi = new IndexerGrpcAccountPortfolioApi(\n  endpoints.indexer,\n)\n\nconst injectiveAddress = 'inj...'\n\nconst portfolio = await indexerGrpcAccountPortfolioApi.fetchAccountPortfolioBalances(\n  injectiveAddress,\n)\n\nconsole.log(portfolio)\n```\n\n[PreviousOracle](https://docs.ts.injective.network/querying/querying-api/querying-indexer-oracle) [NextSpot](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot)\n\nLast updated 12 months ago\n\n<|firecrawl-page-49-lllmstxt|>\n## Querying Spot Market\nExample code snippets to query the indexer for spot market module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-markets)    Fetch markets\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcSpotApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer)\n\nconst markets = await indexerGrpcSpotApi.fetchMarkets()\n\nconsole.log(markets)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-market-based-on-market-id)    Fetch market based on market id\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcSpotApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer)\n\nconst marketId = '0x...'\n\nconst market = await indexerGrpcSpotApi.fetchMarket(marketId)\n\nconsole.log(market)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-markets-orders)    Fetch market's orders\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PaginationOption, IndexerGrpcSpotApi } from '@injectivelabs/sdk-ts'\nimport { OrderSide } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst orderSide = OrderSide.Buy /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst orders = await indexerGrpcSpotApi.fetchOrders({\n  marketId,\n  orderSide,\n  subaccountId,\n  pagination\n})\n\nconsole.log(orders)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-markets-order-history)    Fetch market's order history\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TradeDirection,\n  PaginationOption,\n  TradeExecutionType,\n  IndexerGrpcSpotApi\n} from '@injectivelabs/sdk-ts'\nimport { OrderSide } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer)\n\nconst marketIds = ['0x...'] /* optional param */\nconst executionTypes = [TradeExecutionType.Market] /* optional param */\nconst orderTypes = OrderSide.Buy /* optional param */\nconst direction = TradeDirection.Buy /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst orderHistory = await indexerGrpcSpotApi.fetchOrderHistory({\n  marketIds,\n  executionTypes,\n  orderTypes,\n  direction,\n  subaccountId,\n  pagination\n})\n\nconsole.log(orderHistory)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-markets-trades)    Fetch market's trades\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TradeDirection,\n  PaginationOption,\n  TradeExecutionType,\n  IndexerGrpcSpotApi\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst executionTypes = [TradeExecutionType.Market] /* optional param */\nconst direction = TradeDirection.Buy /* optional param */\nconst subaccountId = '0x...'/* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst trades = await indexerGrpcSpotApi.fetchTrades({\n  marketId,\n  executionTypes,\n  direction,\n  subaccountId,\n  pagination\n})\n\nconsole.log(trades)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-list-of-subaccount-orders)    Fetch list of subaccount orders\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  PaginationOption,\n  IndexerGrpcSpotApi\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst subaccountOrders = await indexerGrpcSpotApi.fetchSubaccountOrdersList({\n  marketId,\n  subaccountId,\n  pagination\n})\n\nconsole.log(subaccountOrders)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-list-of-subaccount-trades)    Fetch list of subaccount trades\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TradeDirection,\n  TradeExecutionType,\n  PaginationOption,\n  IndexerGrpcSpotApi\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst executionType = TradeExecutionType.LimitFill /* optional param */\nconst direction = TradeDirection.Sell /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst subaccountTrades = await indexerGrpcSpotApi.fetchSubaccountTradesList({\n  marketId,\n  subaccountId,\n  executionType,\n  direction,\n  pagination\n})\n\nconsole.log(subaccountTrades)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-orderbooks-for-multiple-markets)    Fetch orderbooks for multiple markets\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcSpotApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer)\n\nconst marketIds = ['0x...']\n\nconst orderbooks = await indexerGrpcSpotApi.fetchOrderbooksV2(marketIds)\n\nconsole.log(orderbooks)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-orderbook-for-a-market)    Fetch orderbook for a market\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcSpotApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotApi = new IndexerGrpcSpotApi(endpoints.indexer)\n\nconst marketId = '0x...'\n\nconst orderbook = await indexerGrpcSpotApi.fetchOrderbookV2(marketId)\n\nconsole.log(orderbook)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#using-http-rest)    Using HTTP REST\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-market-summary-such-as-a-history-of-prices-and-24-hr-volume)    Fetch market summary, such as a history of prices and 24 hr volume\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestSpotChronosApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestSpotChronosApi = new IndexerRestSpotChronosApi(\n  `${endpoints.chronos}/api/chronos/v1/spot`,\n)\n\nconst marketId = '0x...'\n\nconst marketSummary = await indexerRestSpotChronosApi.fetchMarketSummary(\n  marketId,\n)\n\nconsole.log(marketSummary)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot\\#fetch-all-markets-summaries-such-as-a-history-of-prices-and-24-hr-volume)    Fetch all markets summaries, such as a history of prices and 24 hr volume\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerRestSpotChronosApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerRestSpotChronosApi = new IndexerRestSpotChronosApi(\n  `${endpoints.chronos}/api/chronos/v1/spot`,\n)\n\nconst marketSummaries = await indexerRestSpotChronosApi.fetchMarketsSummary(\n  marketId,\n)\n\nconsole.log(marketSummaries)\n```\n\n[PreviousPortfolio](https://docs.ts.injective.network/querying/querying-api/querying-indexer-portfolio) [NextWeb3Gw Transactions](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction)\n\nLast updated 12 months ago\n\n<|firecrawl-page-50-lllmstxt|>\n## Querying Indexer Transactions\nExample code snippets to query the indexer for transaction module related data. Used only when interacting with the [Web3Gateway](https://docs.ts.injective.network/transactions/web3-gateway)\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction\\#using-grpc)    Using gRPC\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction\\#fetch-response-for-preparing-a-transaction)    Fetch response for preparing a transaction\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { Msgs, IndexerGrpcTransactionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\nimport { EthereumChainId } from '@injectivelabs/ts-types'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcTransactionApi = new IndexerGrpcTransactionApi(endpoints.indexer)\n\nconst address = '0x...' // ethereum address\nconst chainId = EthereumChainId.Goerli\nconst message = { ... } as Msgs\nconst memo = '...'\n\nconst prepareTxResponse = await indexerGrpcTransactionApi.prepareTxRequest({\n  address,\n  chainId,\n  message,\n  memo\n})\n\nconsole.log(prepareTxResponse)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction\\#fetch-response-for-preparing-a-cosmos-transaction)    Fetch response for preparing a cosmos transaction\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcTransactionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcTransactionApi = new IndexerGrpcTransactionApi(endpoints.indexer)\n\nconst address = 'inj...'\nconst message = { ... }\n\nconst prepareCosmosTxResponse = await indexerGrpcTransactionApi.prepareCosmosTxRequest({\n  address,\n  message\n})\n\nconsole.log(prepareCosmosTxResponse)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction\\#fetch-response-for-broadcasting-transactions-using-the-web3gateway)    Fetch response for broadcasting transactions using the Web3Gateway\n\nUse `MsgBroadcasterWithPk` to broadcast transactions within a node/CLI environment, which can be found in `@injectivelabs/sdk-ts`.\n\nUse `@injectivelabs/wallet-core`'s `MsgBroadcaster` class for more details on broadcasting a transactions in a browser environment.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { Msgs, IndexerGrpcTransactionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\nimport { ChainId, EthereumChainId } from '@injectivelabs/ts-types'\nimport { WalletStrategy, CosmosWalletStrategy } from '@injectivelabs/wallet-strategy'\nimport { Wallet } from '@injectivelabs/wallet-base'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcTransactionApi = new IndexerGrpcTransactionApi(endpoints.indexer)\n\nconst chainId = ChainId.Testnet // The Injective Chain chainId\nconst ethereumChainId = EthereumChainId.Goerli // The Ethereum Chain ID\n\nexport const alchemyRpcEndpoint = `https://eth-goerli.alchemyapi.io/v2/${process.env.APP_ALCHEMY_GOERLI_KEY}`\n\nconst rpcUrl = `https://eth-goerli.alchemyapi.io/v2/${process.env.APP_ALCHEMY_GOERLI_KEY}`\n\nconst wsRpcUrl = `wss://eth-goerli.ws.alchemyapi.io/v2/${process.env.APP_ALCHEMY_GOERLI_KEY}`\n\nconst alchemyKey =  process.env.APP_ALCHEMY_GOERLI_KEY as string\n\nconst walletStrategy = new WalletStrategy({\n  chainId: CHAIN_ID,\n  ethereumOptions: {\n    rpcUrl,\n    wsRpcUrl,\n    ethereumChainId: ETHEREUM_CHAIN_ID,\n    disabledWallets: [Wallet.WalletConnect]\n  }\n})\n\nconst address = '0x...' // ethereum address\nconst message = { ... } as Msgs\nconst memo = '...'\nconst response = { ... } // response from  prepareTxRequest\nconst signature = await walletStrategy.signEip712TypedData(\n      response.getData(),\n      address,\n    ) /* see injective-ts/wallet-ts implementation of WalletStrategy. Essentially, you use the signEip712TypedData method of the wallet, if the wallet supports signing ethereum transactions */\n\nconst broadcastTxResponse = await indexerGrpcTransactionApi.broadcastTxRequest({\n  signature,\n  chainId,\n  message,\n  txResponse: response\n})\n\nconsole.log(broadcastTxResponse)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction\\#fetch-response-for-broadcasting-a-cosmos-transactions)    Fetch response for broadcasting a cosmos transactions.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcTransactionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\nimport { TxRaw } from '@injectivelabs/chain-api'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcTransactionApi = new IndexerGrpcTransactionApi(endpoints.indexer)\n\nconst address = 'inj...' // ethereum address\nconst signature = '...' // base64\nconst txRaw = { ... } as TxRaw\nconst pubKey = {\n  type: string,\n  value: string // base64\n}\n\nconst broadcastCosmosTxResponse = await indexerGrpcTransactionApi.broadcastCosmosTxRequest({\n  address,\n  signature,\n  txRaw,\n  pubKey\n})\n\nconsole.log(broadcastCosmosTxResponse)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction\\#fetch-web3gateway-fee-payer)    Fetch Web3Gateway Fee Payer\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcTransactionApi } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcTransactionApi = new IndexerGrpcTransactionApi(\n  endpoints.indexer,\n)\n\nconst feePayer = await indexerGrpcTransactionApi.fetchFeePayer()\n\nconsole.log(feePayer)\n```\n\n[PreviousSpot](https://docs.ts.injective.network/querying/querying-api/querying-indexer-spot) [NextStreaming](https://docs.ts.injective.network/querying/querying-api/streaming)\n\nLast updated 11 days ago\n\n<|firecrawl-page-51-lllmstxt|>\n## Streaming Data Modules\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming\\#streaming-the-indexer)    Streaming the Indexer\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming\\#topics)    Topics\n\nTopic\n\nDescription\n\nAccount Module\n\nStreaming data from the account module\n\nAuction Module\n\nStreaming data from the auction module\n\nDerivatives Module\n\nStream data from the derivatives module\n\nExplorer Module\n\nStream data from the explorer module\n\nOracle Module\n\nStream data from the oracle\n\nPortfolio Module\n\nStream data from the portfolio module\n\nSpot Module\n\nStream data from the spot module\n\n[PreviousWeb3Gw Transactions](https://docs.ts.injective.network/querying/querying-api/querying-indexer-transaction) [NextAccount](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-account)\n\nLast updated 12 months ago\n\n<|firecrawl-page-52-lllmstxt|>\n## Streaming Subaccount Balance\nExample code snippets to stream from the indexer for subaccount related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-account\\#using-grpc-stream)    Using gRPC stream\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-account\\#stream-subaccount-balance)    Stream subaccount balance\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountStream = new IndexerGrpcAccountStream(endpoints.indexer)\n\nconst subaccountId = '0x...'\n\nconst streamFn = indexerGrpcAccountStream.streamSubaccountBalance.bind(\n  indexerGrpcAccountStream,\n)\n\nconst callback = (subaccountBalance) => {\n  console.log(subaccountBalance)\n}\n\nconst streamFnArgs = {\n  subaccountId,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n[PreviousStreaming](https://docs.ts.injective.network/querying/querying-api/streaming) [NextAuction](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-auction)\n\nLast updated 12 months ago\n\n<|firecrawl-page-53-lllmstxt|>\n## Streaming Auction Data\nExample code snippets to stream from the indexer for auction module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-auction\\#using-grpc-stream)    Using gRPC Stream\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-auction\\#stream-auction-bids)    Stream auction bids\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAuctionStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAuctionStream = new IndexerGrpcAuctionStream(endpoints.indexer)\n\nconst streamFn = indexerGrpcAuctionStream.streamBids.bind(\n  indexerGrpcAuctionStream,\n)\n\nconst callback = (bids) => {\n  console.log(bids)\n}\n\nconst streamFnArgs = {\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n[PreviousAccount](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-account) [NextDerivatives](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives)\n\nLast updated 12 months ago\n\n<|firecrawl-page-54-lllmstxt|>\n## Streaming Derivatives API\nExample code snippets to query the indexer for derivative module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives\\#using-grpc-stream)    Using gRPC Stream\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives\\#stream-derivatives-orderbook)    Stream derivatives orderbook\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesStream = new IndexerGrpcDerivativesStream(\n  endpoints.indexer,\n)\n\nconst marketIds = ['0x...']\n\nconst streamFn = indexerGrpcDerivativesStream.streamDerivativeOrderbookV2.bind(\n  indexerGrpcDerivativesStream,\n)\n\nconst callback = (orderbooks) => {\n  console.log(orderbooks)\n}\n\nconst streamFnArgs = {\n  marketIds,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives\\#stream-derivative-orders)    Stream derivative orders\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesStream } from '@injectivelabs/sdk-ts'\nimport { OrderSide } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesStream = new IndexerGrpcDerivativesStream(\n  endpoints.indexer,\n)\n\nconst marketId = '0x...'\nconst subaccountId = '0x...' /* optional param */\nconst orderSide = OrderSide.Buy /* optional param */\n\nconst streamFn = indexerGrpcDerivativesStream.streamDerivativeOrders.bind(\n  indexerGrpcDerivativesStream,\n)\n\nconst callback = (orders) => {\n  console.log(orders)\n}\n\nconst streamFnArgs = {\n  marketId,\n  subaccountId,\n  orderside,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives\\#stream-derivative-order-history)    Stream derivative order history\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TradeDirection,\n  TradeExecutionType,\n  IndexerGrpcDerivativesStream,\n} from '@injectivelabs/sdk-ts'\nimport { OrderSide } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesStream = new IndexerGrpcDerivativesStream(\n  endpoints.indexer,\n)\n\nconst marketId = '0x...' /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst orderTypes = [OrderSide.Buy] /* optional param */\nconst executionTypes = [TradeExecutionType.Market] /* optional param */\nconst direction = TradeDirection.Buy /* optional param*/\n\nconst streamFn = indexerGrpcDerivativesStream.streamDerivativeOrderHistory.bind(\n  indexerGrpcDerivativesStream,\n)\n\nconst callback = (orderHistory) => {\n  console.log(orderHistory)\n}\n\nconst streamFnArgs = {\n  marketId,\n  subaccountId,\n  orderTypes,\n  executionTypes,\n  direction,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives\\#stream-derivative-trades)    Stream derivative trades\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  PaginationOption,\n  TradeDirection,\n  IndexerGrpcDerivativesStream\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesStream = new IndexerGrpcDerivativesStream(endpoints.indexer)\n\nconst marketIds = ['0x...'] /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst direction = TradeDirection.Buy /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst streamFn = indexerGrpcDerivativesStream.streamDerivativeTrades.bind(indexerGrpcDerivativesStream)\n\nconst callback = (trades) => {\n  console.log(trades)\n}\n\nconst streamFnArgs = {\n  marketIds,\n  subaccountId,\n  orderTypes,\n  direction,\n  pagination,\n  callback\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives\\#stream-derivative-positions)    Stream derivative positions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesStream = new IndexerGrpcDerivativesStream(\n  endpoints.indexer,\n)\n\nconst marketId = '0x...' /* optional param */\nconst subaccountId = '0x...' /* optional param */\n\nconst streamFn = indexerGrpcDerivativesStream.streamDerivativePositions.bind(\n  indexerGrpcDerivativesStream,\n)\n\nconst callback = (positions) => {\n  console.log(positions)\n}\n\nconst streamFnArgs = {\n  marketId,\n  subaccountId,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives\\#stream-markets)    Stream markets\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesStream = new IndexerGrpcDerivativesStream(\n  endpoints.indexer,\n)\n\nconst marketIds = ['0x...'] /* optional param */\n\nconst streamFn = indexerGrpcDerivativesStream.streamDerivativeMarket.bind(\n  indexerGrpcDerivativesStream,\n)\n\nconst callback = (markets) => {\n  console.log(markets)\n}\n\nconst streamFnArgs = {\n  marketIds,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives\\#stream-orderbook-updates)    Stream orderbook updates\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcDerivativesStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcDerivativesStream = new IndexerGrpcDerivativesStream(\n  endpoints.indexer,\n)\n\nconst marketIds = ['0x...']\n\nconst streamFn =\n  indexerGrpcDerivativesStream.streamDerivativeOrderbookUpdate.bind(\n    indexerGrpcDerivativesStream,\n  )\n\nconst callback = (orderbookUpdates) => {\n  console.log(orderbookUpdates)\n}\n\nconst streamFnArgs = {\n  marketIds,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n[PreviousAuction](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-auction) [NextOracle](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-oracle)\n\nLast updated 12 months ago\n\n<|firecrawl-page-55-lllmstxt|>\n## Streaming Oracle Prices\nExample code snippets to query the indexer for oracle module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-oracle\\#using-grpc-stream)    Using gRPC Stream\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-oracle\\#stream-oracle-prices)    Stream oracle prices\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcOracleStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcOracleStream = new IndexerGrpcOracleStream(endpoints.indexer)\n\nconst streamFn = indexerGrpcOracleStream.streamOraclePrices.bind(\n  indexerGrpcOracleStream,\n)\n\nconst callback = (oraclePrices) => {\n  console.log(oraclePrices)\n}\n\nconst streamFnArgs = {\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-oracle\\#stream-oracle-prices-by-market)    Stream oracle prices by market\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcOracleStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcOracleStream = new IndexerGrpcOracleStream(endpoints.indexer)\n\nconst marketIds = ['0x...'] /* optional param */\n\nconst streamFn = indexerGrpcOracleStream.streamOraclePricesByMarkets.bind(\n  indexerGrpcOracleStream,\n)\n\nconst callback = (oraclePrices) => {\n  console.log(oraclePrices)\n}\n\nconst streamFnArgs = {\n  marketIds,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n[PreviousDerivatives](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-derivatives) [NextPortfolio](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-portfolio)\n\nLast updated 12 months ago\n\n<|firecrawl-page-56-lllmstxt|>\n## Streaming Indexer Portfolio\nExample code snippets to stream from the indexer for portfolio module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-portfolio\\#using-grpc-stream)    Using gRPC Stream\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-portfolio\\#stream-an-accounts-portfolio)    Stream an account's portfolio\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcAccountPortfolioStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcAccountPortfolioStream = new IndexerGrpcAccountPortfolioStream(\n  endpoints.indexer,\n)\n\nconst accountAddress = 'inj...'\n\nconst streamFn = indexerGrpcAccountPortfolioStream.streamAccountPortfolio.bind(\n  indexerGrpcAccountPortfolioStream,\n)\n\nconst callback = (portfolioResults) => {\n  console.log(portfolioResults)\n}\n\nconst streamFnArgs = {\n  accountAddress,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n[PreviousOracle](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-oracle) [NextSpot](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot)\n\nLast updated 12 months ago\n\n<|firecrawl-page-57-lllmstxt|>\n## Streaming Spot Market\nExample code snippets to stream from the indexer for spot market module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot\\#using-grpc-stream)    Using gRPC Stream\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot\\#stream-the-spot-orderbook)    Stream the spot orderbook\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcSpotStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotStream = new IndexerGrpcSpotStream(endpoints.indexer)\n\nconst marketIds = ['0x...']\n\nconst streamFn = indexerGrpcSpotStream.streamSpotOrderbookV2.bind(\n  indexerGrpcSpotStream,\n)\n\nconst callback = (orderbooks) => {\n  console.log(orderbooks)\n}\n\nconst streamFnArgs = {\n  marketIds,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot\\#stream-spot-orders)    Stream spot orders\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcSpotsStream } from '@injectivelabs/sdk-ts'\nimport { OrderSide } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotStream = new IndexerGrpcSpotsStream(endpoints.indexer)\n\nconst marketId = '0x...'\nconst subaccountId = '0x...' /* optional param */\nconst orderSide = OrderSide.Buy /* optional param */\n\nconst streamFn = indexerGrpcSpotStream.streamSpotOrders.bind(\n  indexerGrpcSpotStream,\n)\n\nconst callback = (orders) => {\n  console.log(orders)\n}\n\nconst streamFnArgs = {\n  marketId,\n  subaccountId,\n  orderside,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot\\#stream-spot-order-history)    Stream spot order history\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TradeDirection,\n  TradeExecutionType,\n  IndexerGrpcSpotStream,\n} from '@injectivelabs/sdk-ts'\nimport { OrderSide } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotStream = new IndexerGrpcSpotStream(endpoints.indexer)\n\nconst marketId = '0x...' /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst orderTypes = [OrderSide.Buy] /* optional param */\nconst executionTypes = [TradeExecutionType.Market] /* optional param */\nconst direction = TradeDirection.Buy /* optional param*/\n\nconst streamFn = indexerGrpcSpotStream.streamSpotOrderHistory.bind(\n  indexerGrpcSpotStream,\n)\n\nconst callback = (orderHistory) => {\n  console.log(orderHistory)\n}\n\nconst streamFnArgs = {\n  marketId,\n  subaccountId,\n  orderTypes,\n  executionTypes,\n  direction,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot\\#stream-spot-trades)    Stream spot trades\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  PaginationOption,\n  TradeDirection,\n  IndexerGrpcSpotStream\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotStream = new IndexerGrpcSpotStream(endpoints.indexer)\n\nconst marketIds = ['0x...'] /* optional param */\nconst subaccountId = '0x...' /* optional param */\nconst direction = TradeDirection.Buy /* optional param */\nconst pagination = {...} as PaginationOption /* optional param */\n\nconst streamFn = indexerGrpcSpotStream.streamSpotTrades.bind(indexerGrpcSpotStream)\n\nconst callback = (trades) => {\n  console.log(trades)\n}\n\nconst streamFnArgs = {\n  marketIds,\n  subaccountId,\n  orderTypes,\n  direction,\n  pagination,\n  callback\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot\\#stream-markets)    Stream markets\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcSpotStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotStream = new IndexerGrpcSpotStream(endpoints.indexer)\n\nconst marketIds = ['0x...'] /* optional param */\n\nconst streamFn = indexerGrpcSpotStream.streamSpotMarket.bind(\n  indexerGrpcSpotStream,\n)\n\nconst callback = (markets) => {\n  console.log(markets)\n}\n\nconst streamFnArgs = {\n  marketIds,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot\\#stream-orderbook-updates)    Stream orderbook updates\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcSpotStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcSpotStream = new IndexerGrpcSpotStream(endpoints.indexer)\n\nconst marketIds = ['0x...']\n\nconst streamFn = indexerGrpcSpotStream.streamDerivativeOrderbookUpdate.bind(\n  indexerGrpcSpotStream,\n)\n\nconst callback = (orderbookUpdates) => {\n  console.log(orderbookUpdates)\n}\n\nconst streamFnArgs = {\n  marketIds,\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n[PreviousPortfolio](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-portfolio) [NextExplorer](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-explorer)\n\nLast updated 12 months ago\n\n<|firecrawl-page-58-lllmstxt|>\n## Streaming Indexer Explorer\nExample code snippets to stream from the indexer for explorer module related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-explorer\\#using-grpc-stream)    Using gRPC Stream\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-explorer\\#stream-blocks)    Stream blocks\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerStream = new IndexerGrpcExplorerStream(\n  endpoints.indexer,\n)\n\nconst streamFn = indexerGrpcExplorerStream.blocks.bind(\n  indexerGrpcExplorerStream,\n)\n\nconst callback = (blocks) => {\n  console.log(blocks)\n}\n\nconst streamFnArgs = {\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-explorer\\#stream-blocks-with-transactions)    Stream blocks with transactions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerStream = new IndexerGrpcExplorerStream(\n  endpoints.indexer,\n)\n\nconst streamFn = indexerGrpcExplorerStream.blocksWithTxs.bind(\n  indexerGrpcExplorerStream,\n)\n\nconst callback = (blocksWithTransactions) => {\n  console.log(blocksWithTransactions)\n}\n\nconst streamFnArgs = {\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-explorer\\#stream-transactions)    Stream transactions\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { IndexerGrpcExplorerStream } from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst indexerGrpcExplorerStream = new IndexerGrpcExplorerStream(\n  endpoints.indexer,\n)\n\nconst streamFn = indexerGrpcExplorerStream.streamTransactions.bind(\n  indexerGrpcExplorerStream,\n)\n\nconst callback = (transactions) => {\n  console.log(transactions)\n}\n\nconst streamFnArgs = {\n  callback,\n}\n\nstreamFn(streamFnArgs)\n```\n\n[PreviousSpot](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-spot) [NextEthereum (GraphQL)](https://docs.ts.injective.network/querying/querying-ethereum)\n\nLast updated 12 months ago\n\n<|firecrawl-page-59-lllmstxt|>\n## Querying Ethereum Data\nExample code snippets to query data from Ethereum.\n\n### [Direct link to heading](https://docs.ts.injective.network/querying/querying-ethereum\\#using-graphql)    Using GraphQL\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-ethereum\\#fetch-users-deposits-on-ethereum-chain)    Fetch user's deposits on Ethereum chain\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ApolloConsumer } from '@injectivelabs/sdk-ts'\nimport {\n  Network,\n  getNetworkEndpoints,\n  getPeggyGraphQlEndpointForNetwork,\n} from '@injectivelabs/networks'\n\nconst apolloConsumer = new ApolloConsumer(\n  getPeggyGraphQlEndpointForNetwork(Network.Testnet),\n)\n\nconst ethereumAddress = '0x...'\n\nconst userDeposits = apolloConsumer.fetchUserDeposits(ethereumAddress)\n\nconsole.log(userDeposits)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/querying/querying-ethereum\\#fetch-users-deposits-on-ethereum-chain-at-a-specific-time)    Fetch user's deposits on Ethereum chain at a specific time\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ApolloConsumer } from '@injectivelabs/sdk-ts'\nimport {\n  Network,\n  getNetworkEndpoints,\n  getPeggyGraphQlEndpointForNetwork,\n} from '@injectivelabs/networks'\n\nconst apolloConsumer = new ApolloConsumer(\n  getPeggyGraphQlEndpointForNetwork(Network.Testnet),\n)\n\nconst ethereumAddress = '0x...'\nconst timestamp = 13434333\n\nconst userDeposits = apolloConsumer.fetchUserBridgeDeposits(\n  ethereumAddress,\n  timestamp,\n)\n\nconsole.log(userDeposits)\n```\n\n[PreviousExplorer](https://docs.ts.injective.network/querying/querying-api/streaming/streaming-indexer-explorer) [NextGetting Started](https://docs.ts.injective.network/transactions/transactions)\n\nLast updated 9 months ago\n\n<|firecrawl-page-60-lllmstxt|>\n## Injective Transactions Guide\n_Pre-requisite reading:_ [Cosmos SDK Transactions](https://docs.cosmos.network/main/learn/advanced/transactions)\n\nState changes on Injective can be done through transactions. Users create transactions, sign them and broadcast them to Injective.\n\nWhen broadcasted and only after every validation is successfully passed (these validations include signature validation, parameters validations, etc) the transaction is included within a block which is approved by the network through a consensus process.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions\\#messages)    Messages\n\nMessages are the instructions included in transactions to specify the state change the user want to do. Every transaction has to have at least one message. Messages are module-specific objects that trigger state transitions within the scope of the module they belong to. We can pack multiple messages within the same transaction.\n\nThere is an abstraction class ( _MsgBase_) that we export from the `@injectivelabs/sdk-ts` and every message extends the `MsgBase` interface, which has couple of mapping functionalities:\n\n- `toData` -\\> Converts the Message to a simple Object representation,\n\n- `toProto` -\\> Returns a proto representation of the Message,\n\n- `toDirectSign` -\\> Converts the Message to a proto representation,\n\n- `toAmino` -\\> Converts the Message to a amino representation + type,\n\n- `toWeb3` -\\> alternative for `toAmino`, with the difference of the Message path type,\n\n- `toEip712Types` -\\> Generates the EIP712 types for the Message,\n\n- `toEip712` -\\> Generates the Message EIP712 value\n\n- `toJSON` -\\> Converts the message to a JSON representation,\n\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions\\#transaction-context)    Transaction Context\n\nBesides Message(s), every transaction has context. These details include `fees`, `accountDetails`, `memo`, `signatures`, etc.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions\\#transaction-flow)    Transaction Flow\n\nEvery transaction we want to broadcast to Injective has the same flow. The flow consists of three steps: preparing, signing and broadcasting the transaction.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions\\#topics)    Topics\n\nTopic\n\nDescription\n\n[Using the Ethereum approach](https://docs.ts.injective.network/transactions/ethereum)\n\nPrepare/Sign EIP712 typed data then broadcast\n\n[Using the Cosmos approach](https://docs.ts.injective.network/transactions/transactions-cosmos)\n\nPrepare/Sign/Broadcast Cosmos transactions\n\n[Using a Private Key](https://docs.ts.injective.network/transactions/private-key)\n\nPrepare/Sign/Broadcast Cosmos transaction with private key\n\n[Web3Gateway Microservice](https://docs.ts.injective.network/transactions/web3-gateway)\n\nA microservice for supporting fee Delegation\n\n[Msg Broadcaster](https://docs.ts.injective.network/transactions/msgbroadcaster)\n\nAbstraction for broadcasting messages\n\n**The messages that are available (and examples) can be found in Core Modules section of the Wiki.**\n\n[PreviousEthereum (GraphQL)](https://docs.ts.injective.network/querying/querying-ethereum) [NextCosmos](https://docs.ts.injective.network/transactions/transactions-cosmos)\n\nLast updated 3 months ago\n\n<|firecrawl-page-61-lllmstxt|>\n## Transaction Flow Overview\nEvery transaction on Injective follows the same flow. The flow consists of three steps: preparing, signing and broadcasting the transaction. Let's dive into each step separately and explain the process in-depth (including examples) so we can understand the whole transaction flow.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions-cosmos\\#preparing-a-transaction)    Preparing a transaction\n\nFirst of, we need to prepare the transaction for signing.\n\nAt this point you **can't** use some online abstractions that provide a quick way to prepare the transaction for you based on the provided Message and the signer (ex. using the `@cosmjs/stargate` package). The reason why is that these packages don't support Injective's publicKey typeUrl, so we have to do the preparation of the address on the client side.\n\nTo resolve this, we have provided functions which can prepare the `txRaw` transaction within out `@injectivelabs/sdk-ts` package. `txRaw` is the transaction interface used in Cosmos that contains details about the transaction and the signer itself.\n\nGetting a private key from cosmos wallets is usually done by taking the current key for the chainId and accessing the pubKey from there (ex: `const key = await window.keplr.getKey(chainId)` =\\> `const pubKey = key.publicKey`).\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgSend,\n  BaseAccount,\n  ChainRestAuthApi,\n  createTransaction,\n  ChainRestTendermintApi,\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { getStdFee, DEFAULT_BLOCK_TIMEOUT_HEIGHT } from \"@injectivelabs/utils\";\n\n(async () => {\n  const injectiveAddress = \"inj1\";\n  const chainId = \"injective-1\"; /* ChainId.Mainnet */\n  const restEndpoint =\n    \"https://sentry.lcd.injective.network\"; /* getNetworkEndpoints(Network.MainnetSentry).rest */\n  const amount = {\n    amount: new BigNumberInBase(0.01).toWei().toFixed(),\n    denom: \"inj\",\n  };\n\n  /** Account Details **/\n  const chainRestAuthApi = new ChainRestAuthApi(restEndpoint);\n  const accountDetailsResponse = await chainRestAuthApi.fetchAccount(\n    injectiveAddress\n  );\n  const baseAccount = BaseAccount.fromRestApi(accountDetailsResponse);\n\n  /** Block Details */\n  const chainRestTendermintApi = new ChainRestTendermintApi(restEndpoint);\n  const latestBlock = await chainRestTendermintApi.fetchLatestBlock();\n  const latestHeight = latestBlock.header.height;\n  const timeoutHeight = new BigNumberInBase(latestHeight).plus(\n    DEFAULT_BLOCK_TIMEOUT_HEIGHT\n  );\n\n  /** Preparing the transaction */\n  const msg = MsgSend.fromJSON({\n    amount,\n    srcInjectiveAddress: injectiveAddress,\n    dstInjectiveAddress: injectiveAddress,\n  });\n\n  /** Get the PubKey of the Signer from the Wallet/Private Key */\n  const pubKey = await getPubKey();\n\n  /** Prepare the Transaction **/\n  const { txRaw, signDoc } = createTransaction({\n    pubKey,\n    chainId,\n    fee: getStdFee({}),\n    message: msg,\n    sequence: baseAccount.sequence,\n    timeoutHeight: timeoutHeight.toNumber(),\n    accountNumber: baseAccount.accountNumber,\n  });\n})();\n\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions-cosmos\\#signing-a-transaction)    Signing a transaction\n\nOnce we have prepared the transaction, we proceed to signing. Once you get the `txRaw` transaction from the previous step use any Cosmos native wallet to sign (ex: Keplr),\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainId } from '@injectivelabs/ts-types'\nimport { SignDoc } from '@keplr-wallet/types'\n\nconst getKeplr = async (chainId: string) => {\n  await window.keplr.enable(chainId);\n\n  const offlineSigner = window.keplr.getOfflineSigner(chainId);\n  const accounts = await offlineSigner.getAccounts();\n  const key = await window.keplr.getKey(chainId);\n\n  return { offlineSigner, accounts, key }\n}\n\nconst { offlineSigner } = await getKeplr(ChainId.Mainnet)\n\n/* Sign the Transaction */\nconst address = 'inj1...'\nconst signDoc = /* From the previous step */\nconst directSignResponse = await offlineSigner.signDirect(address, signDoc as SignDoc)\n```\n\nYou can also use our `@injectivelabs/wallet-strategy` package to get out-of-the-box wallet provides that will give you abstracted methods that you can use to sign transactions. Refer to the documentation of the package, its straightforward to setup and use. **This is the recommended way as you have access to more than one wallet to use in your dApp. The** `WalletStrategy` **provides more than just signing transaction abstractions.**\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions-cosmos\\#broadcasting-a-transaction)    Broadcasting a transaction\n\nOnce we have the signature ready, we need to broadcast the transaction to the Injective chain itself. After getting the signature from the second step, we need to include it in the signed transaction and broadcast it to the chain.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainId } from '@injectivelabs/ts-types'\nimport {\n  TxRestApi,\n  CosmosTxV1Beta1Tx,\n  BroadcastModeKeplr,\n  getTxRawFromTxRawOrDirectSignResponse,\n  TxRaw,\n} from '@injectivelabs/sdk-ts'\nimport { TransactionException } from '@injectivelabs/exceptions'\n\n/**\n * IMPORTANT NOTE:\n * If we use Keplr/Leap wallets\n * after signing the transaction we get a `directSignResponse`,\n * and instead of adding the signature to the `txRaw` we create\n * using the `createTransaction` function we need to append the\n * signature from the `directSignResponse` to the transaction that\n * got actually signed (i.e `directSignResponse.signed`) and\n * the reason why is that the user can make some changes on the original\n * transaction (i.e change gas limit or gas prices) and the transaction\n * that get's signed and the one that gets broadcasted are not the same.\n */\nconst directSignResponse = /* From the second step above */;\nconst txRaw = getTxRawFromTxRawOrDirectSignResponse(directSignResponse)\n\nconst broadcastTx = async (chainId: String, txRaw: TxRaw) => {\n  const getKeplr = async (chainId: string) => {\n    await window.keplr.enable(chainId);\n\n    return window.keplr\n  }\n\n  const keplr = await getKeplr(ChainId.Mainnet)\n  const result = await keplr.sendTx(\n    chainId,\n    CosmosTxV1Beta1Tx.TxRaw.encode(txRaw).finish(),\n    BroadcastModeKeplr.Sync,\n  )\n\n  if (!result || result.length === 0) {\n    throw new TransactionException(\n      new Error('Transaction failed to be broadcasted'),\n      { contextModule: 'Keplr' },\n    )\n  }\n\n  return Buffer.from(result).toString('hex')\n}\n\nconst txHash = await broadcastTx(ChainId.Mainnet, txRaw)\n\n/**\n * Once we get the txHash, because we use the Sync mode we\n * are not sure that the transaction is included in the block,\n * it can happen that it's still in the mempool so we need to query\n * the chain to see when the transaction will be included\n */\nconst restEndpoint = 'https://sentry.lcd.injective.network' /* getNetworkEndpoints(Network.MainnetSentry).rest */\nconst txRestApi = new TxRestApi(restEndpoint)\n\n /** This will poll querying the transaction and await for it's inclusion in the block */\nconst response = await txRestApi.fetchTxPoll(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions-cosmos\\#example-prepare--sign--broadcast)    Example (Prepare + Sign + Broadcast)\n\nLet's have a look at the whole flow (using Keplr as a signing wallet)\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TxRaw,\n  MsgSend,\n  BaseAccount,\n  TxRestApi,\n  ChainRestAuthApi,\n  createTransaction,\n  CosmosTxV1Beta1Tx,\n  BroadcastModeKeplr,\n  ChainRestTendermintApi,\n  getTxRawFromTxRawOrDirectSignResponse,\n} from \"@injectivelabs/sdk-ts\";\nimport { getStdFee, DEFAULT_BLOCK_TIMEOUT_HEIGHT } from \"@injectivelabs/utils\";\nimport { ChainId } from \"@injectivelabs/ts-types\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { TransactionException } from \"@injectivelabs/exceptions\";\nimport { SignDoc } from \"@keplr-wallet/types\";\n\nconst getKeplr = async (chainId: string) => {\n  await window.keplr.enable(chainId);\n\n  const offlineSigner = window.keplr.getOfflineSigner(chainId);\n  const accounts = await offlineSigner.getAccounts();\n  const key = await window.keplr.getKey(chainId);\n\n  return { offlineSigner, accounts, key };\n};\n\nconst broadcastTx = async (chainId: string, txRaw: TxRaw) => {\n  const keplr = await getKeplr(ChainId.Mainnet);\n  const result = await keplr.sendTx(\n    chainId,\n    CosmosTxV1Beta1Tx.TxRaw.encode(txRaw).finish(),\n    BroadcastModeKeplr.Sync\n  );\n\n  if (!result || result.length === 0) {\n    throw new TransactionException(\n      new Error(\"Transaction failed to be broadcasted\"),\n      { contextModule: \"Keplr\" }\n    );\n  }\n\n  return Buffer.from(result).toString(\"hex\");\n};\n\n(async () => {\n  const chainId = \"injective-1\"; /* ChainId.Mainnet */\n  const { key, offlineSigner } = await getKeplr(chainId);\n  const pubKey = Buffer.from(key.pubKey).toString(\"base64\");\n  const injectiveAddress = key.bech32Address;\n  const restEndpoint =\n    \"https://sentry.lcd.injective.network\"; /* getNetworkEndpoints(Network.MainnetSentry).rest */\n  const amount = {\n    amount: new BigNumberInBase(0.01).toWei().toFixed(),\n    denom: \"inj\",\n  };\n\n  /** Account Details **/\n  const chainRestAuthApi = new ChainRestAuthApi(restEndpoint);\n  const accountDetailsResponse = await chainRestAuthApi.fetchAccount(\n    injectiveAddress\n  );\n  const baseAccount = BaseAccount.fromRestApi(accountDetailsResponse);\n\n  /** Block Details */\n  const chainRestTendermintApi = new ChainRestTendermintApi(restEndpoint);\n  const latestBlock = await chainRestTendermintApi.fetchLatestBlock();\n  const latestHeight = latestBlock.header.height;\n  const timeoutHeight = new BigNumberInBase(latestHeight).plus(\n    DEFAULT_BLOCK_TIMEOUT_HEIGHT\n  );\n\n  /** Preparing the transaction */\n  const msg = MsgSend.fromJSON({\n    amount,\n    srcInjectiveAddress: injectiveAddress,\n    dstInjectiveAddress: injectiveAddress,\n  });\n\n  /** Prepare the Transaction **/\n  const { signDoc } = createTransaction({\n    pubKey,\n    chainId,\n    fee: getStdFee({}),\n    message: msg,\n    sequence: baseAccount.sequence,\n    timeoutHeight: timeoutHeight.toNumber(),\n    accountNumber: baseAccount.accountNumber,\n  });\n\n  const directSignResponse = await offlineSigner.signDirect(\n    injectiveAddress,\n    signDoc as SignDoc\n  );\n  const txRaw = getTxRawFromTxRawOrDirectSignResponse(directSignResponse);\n  const txHash = await broadcastTx(ChainId.Mainnet, txRaw);\n  const response = await new TxRestApi(restEndpoint).fetchTxPoll(txHash);\n\n  console.log(response);\n})();\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions-cosmos\\#example-with-walletstrategy-prepare--sign--broadcast)    Example with WalletStrategy (Prepare + Sign + Broadcast)\n\nExample can be found [here](https://github.com/InjectiveLabs/injective-ts/blob/862e7c30d96120947b056abffbd01b4f378984a1/packages/wallet-ts/src/broadcaster/MsgBroadcaster.ts#L301-L365).\n\n[PreviousGetting Started](https://docs.ts.injective.network/transactions/transactions) [NextLedger through Keplr Wallet](https://docs.ts.injective.network/transactions/transactions-cosmos/ledger-through-keplr-wallet)\n\nLast updated 11 days ago\n\n<|firecrawl-page-62-lllmstxt|>\n## Ledger with Keplr\nOn this page, we are going to have a look at the implementation for Injective when your users are using a Ledger device through the Keplr wallet.\n\nAs explained before, Injective uses a different derivation curve from the rest of the Cosmos chains which means that the users have to use the Ethereum app (for now) to interact with Injective.\n\nThe easiest way all of the edge cases covered and a full out-of-the-box solution for all of the supported wallets on Injective I suggest you have a look at the [MsgBroadcaster + WalletStrategy](https://docs.ts.injective.network/transactions/msgbroadcaster#msgbroadcaster-+-wallet-strategy) abstraction. If you want to do your own implementation, let's go through the code example together.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions-cosmos/ledger-through-keplr-wallet\\#overview)    Overview\n\nKeplr exposes a `experimentalSignEIP712CosmosTx_v0` method which can be utilized to sign EIP712 typed data (automatically generated on the Keplr side by passing a Cosmos StdSignDoc to the method above) and allow EVM-compatible chains to get proper signatures when we have Ledger devices connected through Keplr.\n\nHere is the function's signature:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n/**\n * Sign the sign doc with ethermint's EIP-712 format.\n * The difference from signEthereum(..., EthSignType.EIP712) is that this api returns a new sign doc changed by the user's fee setting and the signature for that sign doc.\n * Encoding tx to EIP-712 format should be done on the side using this api.\n * Not compatible with cosmjs.\n * The returned signature is (r | s | v) format which used in ethereum.\n * v should be 27 or 28 which is used in the ethereum mainnet regardless of chain.\n * @param chainId\n * @param signer\n * @param eip712\n * @param signDoc\n * @param signOptions\n */\nexperimentalSignEIP712CosmosTx_v0(chainId: string, signer: string, eip712: {\n    types: Record<string, {\n        name: string;\n        type: string;\n    }[] | undefined>;\n    domain: Record<string, any>;\n    primaryType: string;\n}, signDoc: StdSignDoc, signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;\n\n```\n\nWhat we need to do now is generate the `eip712` and the `signDoc`, pass them to this function and Keplr will ask the user to sign the transaction using the Ethereum app on their Ledger device.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/transactions-cosmos/ledger-through-keplr-wallet\\#example-implementation)    Example Implementation\n\nBased on the overview above, let's now showcase a full example of how to implement signing transactions on Injective using Ledger + Keplr. Keep in mind that the example below takes into consideration that you are using the [Msgs](https://github.com/InjectiveLabs/injective-ts/blob/master/packages/sdk-ts/src/core/modules/msgs.ts#L60) interface exported from the `@injectivelabs/sdk-ts` package.\n\nCopy\n\n````inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n ChainRestAuthApi,\n BaseAccount,\n createTransaction,\n createWeb3Extension,\n SIGN_AMINO,\n TxGrpcApi,\n createTxRawEIP712,\n ChainRestTendermintApi,\n getGasPriceBasedOnMessage,\n getEip712TypedData\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, NetworkEndpoints, Network } from '@injectivelabs/networks'\nimport { GeneralException, TransactionException } from '@injectivelabs/exceptions'\nimport { BigNumberInBase, getStdFee } from '@injectivelabs/utils'\n\nexport interface Options {\n  ethereumChainId: number /* 1 for Injective mainnet, 5 for Injective testnet */\n  chainId: string; /* Injective chain id */\n  endpoints: NetworkEndpoints /* can be fetched from @injectivelabs/networks based on the Network */\n}\n\nexport interface Transaction {\n  memo?: string\n  injectiveAddress?: string\n  msgs: Msgs | Msgs[]\n\n  // In case we manually want to set gas options\n  gas?: {\n    gasPrice?: string\n    gas?: number /** gas limit */\n    feePayer?: string\n    granter?: string\n  }\n}\n\n/** Converting EIP712 tx details to Cosmos Std Sign Doc */\nexport const createEip712StdSignDoc = ({\n  memo,\n  chainId,\n  accountNumber,\n  timeoutHeight,\n  sequence,\n  gas,\n  msgs,\n}: {\n  memo?: string\n  chainId: ChainId\n  timeoutHeight?: string\n  accountNumber: number\n  sequence: number\n  gas?: string\n  msgs: Msgs[]\n}) => ({\n  chain_id: chainId,\n  timeout_height: timeoutHeight || '',\n  account_number: accountNumber.toString(),\n  sequence: sequence.toString(),\n  fee: getStdFee({ gas }),\n  msgs: msgs.map((m) => m.toEip712()),\n  memo: memo || '',\n})\n\n```\n\n/**\n* We use this method only when we want to broadcast a transaction using Ledger on Keplr for Injective\n*\n* Note: Gas estimation not available\n* @param tx the transaction that needs to be broadcasted\n*/\nexport const experimentalBroadcastKeplrWithLedger = async (\ntx: Transaction,\noptions: Options\n) => {\nconst { endpoints, chainId, ethereumChainId } = options\nconst msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs]\nconst DEFAULT_BLOCK_TIMEOUT_HEIGHT = 60\n\n/**\n* You choose to perform a check if\n* the user is indeed connected with Ledger + Keplr\n*/\nif (/* your condition here */) {\n    throw new GeneralException(\n        new Error(\n          'This method can only be used when Keplr is connected with Ledger',\n        ),\n      )\n}\n\n/** Account Details * */\nconst chainRestAuthApi = new ChainRestAuthApi(endpoints.rest)\nconst accountDetailsResponse = await chainRestAuthApi.fetchAccount(\n    tx.injectiveAddress,\n)\nconst baseAccount = BaseAccount.fromRestApi(accountDetailsResponse)\nconst accountDetails = baseAccount.toAccountDetails()\n\n/** Block Details */\nconst chainRestTendermintApi = new ChainRestTendermintApi(endpoints.rest)\nconst latestBlock = await chainRestTendermintApi.fetchLatestBlock()\nconst latestHeight = latestBlock.header.height\nconst timeoutHeight = new BigNumberInBase(latestHeight).plus(\n    DEFAULT_BLOCK_TIMEOUT_HEIGHT,\n)\n\nconst key = await window.keplr.getKey(chainId)\nconst pubKey = Buffer.from(key.pubKey).toString('base64')\nconst gas = (tx.gas?.gas || getGasPriceBasedOnMessage(msgs)).toString()\n\n/** EIP712 for signing on Ethereum wallets */\nconst eip712TypedData = getEip712TypedData({\n    msgs,\n    fee: getStdFee({ ...tx.gas, gas }),\n    tx: {\n      memo: tx.memo,\n      accountNumber: accountDetails.accountNumber.toString(),\n      sequence: accountDetails.sequence.toString(),\n      timeoutHeight: timeoutHeight.toFixed(),\n      chainId,\n    },\n    ethereumChainId,\n})\n\nconst aminoSignResponse = await window.keplr.experimentalSignEIP712CosmosTx_v0(\n    chainId,\n    tx.injectiveAddress,\n    eip712TypedData,\n    createEip712StdSignDoc({\n      ...tx,\n      ...baseAccount,\n      msgs,\n      chainId,\n      gas: gas || tx.gas?.gas?.toString(),\n      timeoutHeight: timeoutHeight.toFixed(),\n    }\n)\n\n/**\n* Create TxRaw from the signed tx that we\n* get as a response in case the user changed the fee/memo\n* on the Keplr popup\n*/\nconst { txRaw } = createTransaction({\n    pubKey,\n    message: msgs,\n    memo: aminoSignResponse.signed.memo,\n    signMode: SIGN_AMINO,\n    fee: aminoSignResponse.signed.fee,\n    sequence: parseInt(aminoSignResponse.signed.sequence, 10),\n    timeoutHeight: parseInt(\n      (aminoSignResponse.signed as any).timeout_height,\n      10,\n    ),\n    accountNumber: parseInt(aminoSignResponse.signed.account_number, 10),\n    chainId,\n})\n\n/** Preparing the transaction for client broadcasting */\nconst web3Extension = createWeb3Extension({\n    ethereumChainId,\n})\nconst txRawEip712 = createTxRawEIP712(txRaw, web3Extension)\n\n/** Append Signatures */\nconst signatureBuff = Buffer.from(\n    aminoSignResponse.signature.signature,\n    'base64',\n)\ntxRawEip712.signatures = [signatureBuff]\n\n/** Broadcast the transaction */\nconst response = await new TxGrpcApi(endpoints.grpc).broadcast(txRawEip712)\n\nif (response.code !== 0) {\n    throw new TransactionException(new Error(response.rawLog), {\n      code: UnspecifiedErrorCode,\n      contextCode: response.code,\n      contextModule: response.codespace,\n    })\n}\n\nreturn response\n}\n````\n\n[PreviousCosmos](https://docs.ts.injective.network/transactions/transactions-cosmos) [NextEthereum](https://docs.ts.injective.network/transactions/ethereum)\n\nLast updated 4 months ago\n\n<|firecrawl-page-63-lllmstxt|>\n## Ethereum Transaction Flow\nEvery transaction on Injective follows the same flow. The flow consists of three steps: preparing, signing and broadcasting the transaction. Let's dive into each step separately and explain the process in-depth (including examples) so we can understand the whole transaction flow.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum\\#preparing-a-transaction)    Preparing a transaction\n\nFirst of, we need to prepare the transaction for signing. To use Ethereum native wallets, we have to convert the transaction to EIP712 typed data and use the wallet to sign this typed data.\n\nUsing our custom abstraction for the Messages which allows the developer to get EIP712 TypedData straight from the proto file of the particular message.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgSend,\n  ChainRestAuthApi,\n  ChainRestTendermintApi,\n  BaseAccount,\n  DEFAULT_STD_FEE,\n  getEip712TypedData,\n} from '@injectivelabs/sdk-ts'\nimport {\n  DEFAULT_STD_FEE,\n  DEFAULT_BLOCK_TIMEOUT_HEIGHT,\n} from '@injectivelabs/utils'\nimport { ChainId } from '@injectivelabs/ts-types'\nimport { Network, getNetworkEndpoints } from '@injectivelabs/networks'\n\nconst injectiveAddress = 'inj1'\nconst chainId = 'injective-1' /* ChainId.Mainnet */\nconst restEndpoint =\n  'https://lcd.injective.network' /* getNetworkEndpoints(Network.Mainnet).rest */\nconst amount = {\n  amount: new BigNumberInBase(0.01).toWei().toFixed(),\n  denom: 'inj',\n}\n\n/** Account Details **/\nconst chainRestAuthApi = new ChainRestAuthApi(restEndpoint)\nconst accountDetailsResponse = await chainRestAuthApi.fetchAccount(\n  injectiveAddress,\n)\nconst baseAccount = BaseAccount.fromRestApi(accountDetailsResponse)\nconst accountDetails = baseAccount.toAccountDetails()\n\n/** Block Details */\nconst chainRestTendermintApi = new ChainRestTendermintApi(restEndpoint)\nconst latestBlock = await chainRestTendermintApi.fetchLatestBlock()\nconst latestHeight = latestBlock.header.height\nconst timeoutHeight = new BigNumberInBase(latestHeight).plus(\n  DEFAULT_BLOCK_TIMEOUT_HEIGHT,\n)\n\n/** Preparing the transaction */\nconst msg = MsgSend.fromJSON({\n  amount,\n  srcInjectiveAddress: injectiveAddress,\n  dstInjectiveAddress: injectiveAddress,\n})\n\n/** EIP712 for signing on Ethereum wallets */\nconst eip712TypedData = getEip712TypedData({\n  msgs: [msg],\n  tx: {\n    accountNumber: accountDetails.accountNumber.toString(),\n    sequence: accountDetails.sequence.toString(),\n    timeoutHeight: timeoutHeight.toFixed(),\n    chainId: chainId,\n  },\n  ethereumChainId: ethereumChainId,\n})\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum\\#signing-a-transaction)    Signing a transaction\n\nOnce we have prepared the EIP712 typed data, we proceed to signing.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n/** Use your preferred approach to sign EIP712 TypedData, example with Metamask */\nconst signature = await window.ethereum.request({\n  method: 'eth_signTypedData_v4',\n  params: [\\\n    ethereumAddress,\\\n    JSON.stringify(eip712TypedData /* from previous step */),\\\n  ],\n})\n\n/** Get Public Key of the signer */\nconst publicKeyHex = recoverTypedSignaturePubKey(eip712TypedData, signature)\nconst publicKeyBase64 = hexToBase64(publicKeyHex)\n```\n\nYou can also use our `@injectivelabs/wallet-strategy` package to get out-of-the-box wallet provides that will give you abstracted methods which you can use to sign transaction. Refer to the documentation of the package, its really simple to setup and use. **This is the recommended way as you have access to more than one wallet to use in your dApp. The** `WalletStrategy` **provides more than just signing transaction abstractions.**\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum\\#broadcasting-a-transaction)    Broadcasting a transaction\n\nOnce we have the signature ready, we need to broadcast the transaction to the Injective chain itself. After getting the signature from the second step, we need to include that signature in the signed transaction and broadcast it to the chain.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainId } from '@injectivelabs/ts-types'\nimport { createTransaction, TxRestApi } from '@injectivelabs/sdk-ts'\nimport {\n  SIGN_AMINO,\n  Network,\n  getNetworkEndpoints,\n} from '@injectivelabs/networks'\n\nconst { txRaw } = createTransaction({\n  message: msgs,\n  memo: memo,\n  signMode: SIGN_AMINO,\n  fee: DEFAULT_STD_FEE,\n  pubKey: publicKeyBase64 /* From previous step */,\n  sequence: baseAccount.sequence,\n  timeoutHeight: timeoutHeight.toNumber(),\n  accountNumber: baseAccount.accountNumber,\n  chainId: chainId,\n})\nconst web3Extension = createWeb3Extension({\n  ethereumChainId,\n})\nconst txRawEip712 = createTxRawEIP712(txRaw, web3Extension)\n\n/** Append Signatures */\ntxRawEip712.signatures = [signatureBuff /* From previous step */]\n\n/** Broadcast the Transaction */\nconst restEndpoint =\n  'https://lcd.injective.network' /* getNetworkEndpoints(Network.Mainnet).rest */\nconst txRestApi = new TxRestApi(restEndpoint)\n\nconst txHash = await txRestApi.broadcast(txRawEip712)\n\n/**\n * Once we get the txHash, because we use the Sync mode we\n * are not sure that the transaction is included in the block,\n * it can happen that it's still in the mempool so we need to query\n * the chain to see when the transaction will be included\n */\n\n/** This will poll querying the transaction and await for it's inclusion in the block */\nconst response = await txRestApi.fetchTxPoll(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum\\#example-without-walletstrategy-prepare--sign--broadcast)    Example without WalletStrategy (Prepare + Sign + Broadcast)\n\nLet's have a look at the whole flow (using Metamask as a signing wallet)\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgSend,\n  ChainRestAuthApi,\n  ChainRestTendermintApi,\n  BaseAccount,\n  getEip712TypedData,\n  getEthereumAddress,\n  recoverTypedSignaturePubKey,\n  hexToBase64,\n  createTransaction,\n  SIGN_AMINO,\n  createWeb3Extension,\n  createTxRawEIP712,\n  TxRestApi,\n} from \"@injectivelabs/sdk-ts\";\nimport {\n  BigNumberInBase,\n  DEFAULT_STD_FEE,\n  DEFAULT_BLOCK_TIMEOUT_HEIGHT,\n} from \"@injectivelabs/utils\";\nimport { ChainId } from \"@injectivelabs/ts-types\";\nimport { Network, getNetworkEndpoints } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1\";\nconst ethereumAddress = getEthereumAddress(injectiveAddress)\nconst chainId = \"injective-1\"; /* ChainId.Mainnet */\nconst ethereumChainId = 1; /* ChainId.EthereumMainnet */\nconst restEndpoint = getNetworkEndpoints(Network.MainnetSentry).rest;\nconst amount = {\n  amount: new BigNumberInBase(0.01).toWei().toFixed(),\n  denom: \"inj\",\n};\n\n/** Account Details **/\nconst chainRestAuthApi = new ChainRestAuthApi(restEndpoint);\nconst accountDetailsResponse = await chainRestAuthApi.fetchAccount(\n  injectiveAddress\n);\nconst baseAccount = BaseAccount.fromRestApi(accountDetailsResponse);\nconst accountDetails = baseAccount.toAccountDetails();\n\n/** Block Details */\nconst chainRestTendermintApi = new ChainRestTendermintApi(restEndpoint);\nconst latestBlock = await chainRestTendermintApi.fetchLatestBlock();\nconst latestHeight = latestBlock.header.height;\nconst timeoutHeight = new BigNumberInBase(latestHeight).plus(\n  DEFAULT_BLOCK_TIMEOUT_HEIGHT\n);\n\n/** Preparing the transaction */\nconst msg = MsgSend.fromJSON({\n  amount,\n  srcInjectiveAddress: injectiveAddress,\n  dstInjectiveAddress: injectiveAddress,\n});\n\n/** EIP712 for signing on Ethereum wallets */\nconst eip712TypedData = getEip712TypedData({\n  msgs: [msg],\n  tx: {\n    accountNumber: accountDetails.accountNumber.toString(),\n    sequence: accountDetails.sequence.toString(),\n    timeoutHeight: timeoutHeight.toFixed(),\n    chainId: chainId,\n  },\n  ethereumChainId: ethereumChainId,\n});\n\n/** Use your preferred approach to sign EIP712 TypedData, example with Metamask */\nconst signature = await window.ethereum.request({\n  method: \"eth_signTypedData_v4\",\n  params: [ethereumAddress, JSON.stringify(eip712TypedData)],\n});\n\n/** Get Public Key of the signer */\nconst publicKeyHex = recoverTypedSignaturePubKey(eip712TypedData, signature);\nconst publicKeyBase64 = hexToBase64(publicKeyHex);\nconst signatureBuff = Buffer.from(signature.replace('0x', ''), \"hex\");\n\nconst { txRaw } = createTransaction({\n  message: [msg],\n  memo: '',\n  signMode: SIGN_AMINO,\n  fee: DEFAULT_STD_FEE,\n  pubKey: publicKeyBase64,\n  sequence: baseAccount.sequence,\n  timeoutHeight: timeoutHeight.toNumber(),\n  accountNumber: baseAccount.accountNumber,\n  chainId: chainId,\n});\nconst web3Extension = createWeb3Extension({\n  ethereumChainId,\n});\nconst txRawEip712 = createTxRawEIP712(txRaw, web3Extension);\n\n/** Append Signatures */\ntxRawEip712.signatures = [signatureBuff];\n\n/** Broadcast the Transaction */\nconst txRestApi = new TxRestApi(restEndpoint);\n\nconst txResponse = await txRestApi.broadcast(txRawEip712);\nconst response = await txRestApi.fetchTxPoll(txResponse.txHash);\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum\\#example-with-walletstrategy-prepare--sign--broadcast)    Example with WalletStrategy (Prepare + Sign + Broadcast)\n\nExample can be found [here](https://github.com/InjectiveLabs/injective-ts/blob/862e7c30d96120947b056abffbd01b4f378984a1/packages/wallet-ts/src/broadcaster/MsgBroadcaster.ts#L166-L248).\n\n[PreviousLedger through Keplr Wallet](https://docs.ts.injective.network/transactions/transactions-cosmos/ledger-through-keplr-wallet) [NextEthereum Ledger](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger)\n\nLast updated 11 days ago\n\n<|firecrawl-page-64-lllmstxt|>\n## Signing Injective Transactions\n## [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#signing-transactions-on-injective-using-ledger)    Signing Transactions on Injective using Ledger\n\nThe goal of this document is to explain how to use Ledger to sign transactions on Injective and broadcast them to the chain. The implementation differs from the default approach that Cosmos SDK native chains have because Injective defines its custom Account type that uses Ethereum's ECDSA secp256k1 curve for keys.\n\n## [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#implementation)    Implementation\n\nTo understand how we should do the implementation, lets go through some concepts so it's easier to understand the approach we are going to take.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#background)    Background\n\nA derivation path is a piece of data that tells a Hierarchical Deterministic (HD) wallet how to derive a specific key within a tree of keys. Derivation paths are used as a standard and were introduced with HD wallets as a part of BIP32. A Hierarchical Deterministic Wallet is a term used to describe a wallet that uses a seed to derive many public and private keys.\n\nThis is what a derivation path looks like\n\n`m/purpose'/coin_type'/account'/change/address_index`\n\nEach of the parts in the sequence plays a part and each changes what the private key, public key, and address would be. We are not going to deep dive into the exact details about what every part of the HD path means, instead, we are just going to briefly explain the `coin_type`. Each blockchain has a number that represents it i.e the `coin_type`. Bitcoin is `0`, Ethereum is `60`, Cosmos is `118`.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#injective-specific-context)    Injective specific context\n\nInjective uses the same `coin_type` as Ethereum, i.e `60`. This means for Ledger to be used to sign transactions on Injective, **we have to use the Ethereum app on Ledger**.\n\nLedger is limited to having one installed application for one `coin_type`. As we have to use the Ethereum app to sign transactions on Injective, we have to explore available options to us to get a valid signature. One of the available options is the `EIP712` procedure for hashing and signing typed structured data. Ledger exposes the `signEIP712HashedMessage` which we are going to use.\n\nOnce we sign the `EIP712` typed data, we are going to pack the transaction using the normal Cosmos-SDK approach of packing and broadcasting the transaction. There are some minor differences, one of them being using the `SIGN_MODE_LEGACY_AMINO_JSON` mode and appending a `Web3Exension` to the Cosmos transaction and we are going to explain them in this document.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#eip712-typed-data)    EIP712 Typed Data\n\nEIP 712 is a standard for hashing and signing of typed structured data. For every EIP712 typed data, each of the values the user passes (that need to be signed) has a type representative which explains the exact type of that particular value. In addition to the value the user wants to sign and its type (the `PrimaryType` of the EIP712 typedData), every EIP712 typed data should contain an `EIP712Domain` which provides context about the source of the transaction.\n\n## [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#transaction-flow)    Transaction Flow\n\nThe implementation itself consists of a few steps, namely:\n\n1. Preparing the transaction to be signed using the Ethereum app on Ledger,\n\n2. Preparing and signing the transaction on Ledger,\n\n3. Preparing the transaction to be broadcasted,\n\n4. Broadcast the transaction.\n\n\nWe are going deep dive into each step and elaborate on the actions we need to take to get the transaction signed and broadcasted to the chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#preparing-the-transaction-for-signing)    Preparing the transaction (for signing)\n\nAs weve said above, the transaction needs to be signed using the Ethereum app on Ledger. This means that the user has to be prompted to switch (or open) the Ethereum app on Ledger once they reach the signing stage.\n\nWe know that each Cosmos transaction consists of messages which signify the instructions the user wants to execute on the chain. If we want to send funds from one address to another, we are going to pack the `MsgSend` message into a transaction and broadcast it to the chain.\n\nKnowing this, the Injective team made [abstraction](https://github.com/InjectiveLabs/injective-ts/blob/master/packages/sdk-ts/src/core/modules/MsgBase.ts) of these Messages to simplify the way they are packed into a transaction. Each of these Messages accepts a specific set of parameters that are needed to instantiate the message. Once this is done, the abstraction exposes a couple of convenient methods which we can use based on the signing/broadcasting method we chose to use. As an example, the Message exposes the `toDirectSign` method which returns the type and the proto representation of the message which can be then used to pack the transaction using the default Cosmos approach, sign it using a privateKey and broadcast it to the chain.\n\nWhat is of importance for us for this particular implementation are the `toEip712Types` and `toEip712` methods. Calling the first one on an instance of the Message gives out the types of the Message for the EIP712 typed data and the second one gives the values of the Message for the EIP712 data. When we combine these two methods we can generate valid EIP712 typed data which can be passed down to the signing process.\n\nSo, lets see a quick code snippet of the usage of these methods and how we can generate EIP712 typedData from a message:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgSend, DEFAULT_STD_FEE } from '@injectivelabs/sdk-ts'\nimport {\n   getEip712TypedData,\n   Eip712ConvertTxArgs,\n   Eip712ConvertFeeArgs\n} from '@injectivelabs/sdk-ts/dist/core/eip712'\nimport { EtherumChainId } from '@injectivelabs/ts-types'\n\n/** More details on these two interfaces later on */\nconst txArgs: Eip712ConvertTxArgs = {\n  accountNumber: accountDetails.accountNumber.toString(),\n  sequence: accountDetails.sequence.toString(),\n  timeoutHeight: timeoutHeight.toFixed(),\n  chainId: chainId,\n}\nconst txFeeArgs: Eip712ConvertFeeArgs = DEFAULT_STD_FEE\nconst injectiveAddress = 'inj14au322k9munkmx5wrchz9q30juf5wjgz2cfqku'\nconst amount = {\n  amount: new BigNumberInBase(0.01).toWei().toFixed(),\n  denom: \"inj\",\n};\nconst ethereumChainId = EthereumChainId.Mainnet\n\nconst msg = MsgSend.fromJSON({\n  amount,\n  srcInjectiveAddress: injectiveAddress,\n  dstInjectiveAddress: injectiveAddress,\n});\n\n/** The EIP712 TypedData that can be used for signing **/\nconst eip712TypedData = getEip712Tx({\n  msgs: msg,\n  tx: txArgs,\n  fee: txFeeArgs\n  ethereumChainId: ethereumChainId,\n})\n\nreturn eip712TypedData;\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#preparing-the-signing-process-on-ledger)    Preparing the signing process on Ledger\n\nNow that we have the `eip712TypedData` we need to sign it using Ledger. First, we need to get the Ledgers transport depending on the support that the user has on the browser and use the `@ledgerhq/hw-app-eth` to make a Ledger instance with the transport thatll use the Ethereum app on the Ledger device for executing the users actions (confirming transactions). After we get the `eip712TypedData` from Step 1, we can use the `signEIP712HashedMessage` on the `EthereumApp` to sign this typedData and return the signature.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { TypedDataUtils } from 'eth-sig-util'\nimport { bufferToHex, addHexPrefix } from 'ethereumjs-util'\nimport EthereumApp from '@ledgerhq/hw-app-eth'\n\nconst domainHash = (message: any) =>\n  TypedDataUtils.hashStruct('EIP712Domain', message.domain, message.types, true)\n\nconst messageHash = (message: any) =>\n  TypedDataUtils.hashStruct(\n    message.primaryType,\n    message.message,\n    message.types,\n    true,\n  )\n\nconst transport = /* Get the transport from Ledger */\nconst ledger = new EthereumApp(transport)\nconst derivationPath = /* Get the derivation path for the address */\n\n/* eip712TypedData from Step 1 */\nconst object = JSON.parse(eip712TypedData)\n\nconst result = await ledger.signEIP712HashedMessage(\n  derivationPath,\n  bufferToHex(domainHash(object)),\n  bufferToHex(messageHash(object)),\n)\nconst combined = `${result.r}${result.s}${result.v.toString(16)}`\nconst signature = combined.startsWith('0x') ? combined : `0x${combined}`\n\nreturn signature;\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#preparing-the-transaction-to-be-broadcasted)    Preparing the transaction to be broadcasted\n\nNow that we have the signature, we can prepare the transaction using the default cosmos approach.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  ChainRestAuthApi,\n  ChainRestTendermintApi,\n  BaseAccount,\n  DEFAULT_STD_FEE,\n  createTransaction,\n  createTxRawEIP712,\n  createWeb3Extension,\n  SIGN_AMINO\n} from '@injectivelabs/sdk-ts'\nimport { DEFAULT_BLOCK_TIMEOUT_HEIGHT } from '@injectivelabs/utils'\n\nconst msg: MsgSend /* from Step 1 */\n\n/** Account Details **/\nconst chainRestAuthApi = new ChainRestAuthApi(\n  lcdEndpoint,\n)\nconst accountDetailsResponse = await chainRestAuthApi.fetchAccount(\n  injectiveAddress,\n)\nconst baseAccount = BaseAccount.fromRestApi(accountDetailsResponse)\nconst accountDetails = baseAccount.toAccountDetails()\n\n/** Block Details */\nconst chainRestTendermintApi = new ChainRestTendermintApi(\n  lcdEndpoint,\n)\nconst latestBlock = await chainRestTendermintApi.fetchLatestBlock()\nconst latestHeight = latestBlock.header.height\nconst timeoutHeight = new BigNumberInBase(latestHeight).plus(\n  DEFAULT_BLOCK_TIMEOUT_HEIGHT,\n)\n\nconst { txRaw } = createTransaction({\n  message: msgs,\n  memo: '',\n  signMode: SIGN_AMINO,\n  fee: DEFAULT_STD_FEE,\n  pubKey: publicKeyBase64,\n  sequence: baseAccount.sequence,\n  timeoutHeight: timeoutHeight.toNumber(),\n  accountNumber: baseAccount.accountNumber,\n  chainId: chainId,\n})\nconst web3Extension = createWeb3Extension({\n  ethereumChainId,\n})\nconst txRawEip712 = createTxRawEIP712(txRaw, web3Extension)\n\n/** Append Signatures */\nconst signatureBuff = Buffer.from(signature.replace('0x', ''), 'hex')\ntxRawEip712.signatures = [signatureBuff]\n\nreturn txRawEip712\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#broadcasting-the-transaction)    Broadcasting the transaction\n\nNow that we have the transaction packed into `TxRaw` we can broadcast it to the node using the default cosmos approach.\n\n## [Direct link to heading](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger\\#codebase)    Codebase\n\nLets see an example codebase containing all of the steps above\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  ChainRestAuthApi,\n  ChainRestTendermintApi,\n  BaseAccount,\n  DEFAULT_STD_FEE\n  TxRestApi,\n  createTransaction,\n  createTxRawEIP712,\n  createWeb3Extension,\n  SIGN_AMINO\n} from '@injectivelabs/sdk-ts'\nimport { TypedDataUtils } from 'eth-sig-util'\nimport { bufferToHex, addHexPrefix } from 'ethereumjs-util'\nimport EthereumApp from '@ledgerhq/hw-app-eth'\nimport {\n   getEip712TypedData,\n   Eip712ConvertTxArgs,\n   Eip712ConvertFeeArgs\n} from '@injectivelabs/sdk-ts/dist/core/eip712'\nimport { EtherumChainId, CosmosChainId } from '@injectivelabs/ts-types'\nimport { BigNumberInBase, DEFAULT_BLOCK_TIMEOUT_HEIGHT } from '@injectivelabs/utils'\n\nconst domainHash = (message: any) =>\nTypedDataUtils.hashStruct('EIP712Domain', message.domain, message.types, true)\n\nconst messageHash = (message: any) =>\n  TypedDataUtils.hashStruct(\n    message.primaryType,\n    message.message,\n    message.types,\n    true,\n  )\n\nconst signTransaction = async (eip712TypedData: any) => {\n  const transport = /* Get the transport from Ledger */\n  const ledger = new EthereumApp(transport)\n  const derivationPath = /* Get the derivation path for the address */\n\n  /* eip712TypedData from Step 1 */\n  const result = await ledger.signEIP712HashedMessage(\n    derivationPath,\n    bufferToHex(domainHash(eip712TypedData)),\n    bufferToHex(messageHash(eip712TypedData)),\n  )\n  const combined = `${result.r}${result.s}${result.v.toString(16)}`\n  const signature = combined.startsWith('0x') ? combined : `0x${combined}`\n\n  return signature;\n}\n\nconst getAccountDetails = (address: string): BaseAccount => {\n  const chainRestAuthApi = new ChainRestAuthApi(\n    lcdEndpoint,\n  )\n  const accountDetailsResponse = await chainRestAuthApi.fetchAccount(\n    address,\n  )\n  const baseAccount = BaseAccount.fromRestApi(accountDetailsResponse)\n  const accountDetails = baseAccount.toAccountDetails()\n\n  return accountDetails\n}\n\nconst getTimeoutHeight = () => {\n  const chainRestTendermintApi = new ChainRestTendermintApi(\n    lcdEndpoint,\n  )\n  const latestBlock = await chainRestTendermintApi.fetchLatestBlock()\n  const latestHeight = latestBlock.header.height\n  const timeoutHeight = latestHeight + DEFAULT_BLOCK_TIMEOUT_HEIGHT\n\n  return timeoutHeight\n}\n\nconst address = 'inj14au322k9munkmx5wrchz9q30juf5wjgz2cfqku'\nconst chainId = CosmosChainId.Injective\nconst ethereumChainId = EthereumChainId.Mainnet\nconst accountDetails = getAccountDetails()\nconst timeoutHeight = getTimeoutHeight\n\nconst txArgs: Eip712ConvertTxArgs = {\n  accountNumber: accountDetails.accountNumber.toString(),\n  sequence: accountDetails.sequence.toString(),\n  timeoutHeight: timeoutHeight.toString(),\n  chainId: chainId,\n}\nconst txFeeArgs: Eip712ConvertFeeArgs = DEFAULT_STD_FEE\nconst injectiveAddress = 'inj14au322k9munkmx5wrchz9q30juf5wjgz2cfqku'\nconst amount = {\n  amount: new BigNumberInBase(0.01).toWei().toFixed(),\n  denom: \"inj\",\n};\n\nconst msg = MsgSend.fromJSON({\n  amount,\n  srcInjectiveAddress: injectiveAddress,\n  dstInjectiveAddress: injectiveAddress,\n});\n\n/** The EIP712 TypedData that can be used for signing **/\nconst eip712TypedData = getEip712Tx({\n  msgs: msg,\n  tx: txArgs,\n  fee: txFeeArgs\n  ethereumChainId: ethereumChainId,\n})\n\n/** Signing on Ethereum */\nconst signature = await signTransaction(eip712TypedData)\n\n/** Preparing the transaction for client broadcasting */\nconst { txRaw } = createTransaction({\n  message: msg,\n  memo: '',\n  signMode: SIGN_AMINO,\n  fee: DEFAULT_STD_FEE,\n  pubKey: publicKeyBase64,\n  sequence: accountDetails.sequence,\n  timeoutHeight: timeoutHeight.toNumber(),\n  accountNumber: accountDetails.accountNumber,\n  chainId: chainId,\n})\nconst web3Extension = createWeb3Extension({\n  ethereumChainId,\n})\nconst txRawEip712 = createTxRawEIP712(txRaw, web3Extension)\n\n/** Append Signatures */\nconst signatureBuff = Buffer.from(signature.replace('0x', ''), 'hex')\ntxRawEip712.signatures = [signatureBuff]\n\n/** Broadcast the transaction **/\nconst txRestApi = new TxRestApi(lcdEndpoint)\nconst response = await txRestApi.broadcast(txRawEip712)\n\nif (response.code !== 0) {\n  throw new Error(`Transaction failed: ${response.rawLog}`)\n}\n\nreturn response.txhash\n\n```\n\n[PreviousEthereum](https://docs.ts.injective.network/transactions/ethereum) [NextMsgBroadcaster](https://docs.ts.injective.network/transactions/msgbroadcaster)\n\nLast updated 4 months ago\n\n<|firecrawl-page-65-lllmstxt|>\n## MsgBroadcast Overview\nThe `MsgBroadcast` er abstraction class is a way to broadcast transactions on Injective with ease. With it, you can pass a Message that you want to be packed in a transaction and the signer's address and the transaction will be prepared, signed, and broadcasted.\n\nAn example of usage can be found on our [Helix demo repo](https://github.com/InjectiveLabs/injective-helix-demo). As for the messages that you can pass to the `broadcast` methods, you can find examples in the [Core Modules](https://docs.ts.injective.network/core-modules-and-examples/core-modules) section of the docs.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/msgbroadcaster\\#msgbroadcaster--wallet-strategy)    MsgBroadcaster + Wallet Strategy\n\nThis MsgBroadcaster is used alongside the Wallet Strategy class for building decentralized applications.\n\nTo instantiate (and use) the `MsgBroadcaster` class, you can use the following code snippet\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainId, EthereumChainId } from \"@injectivelabs/ts-types\"\nimport { Network, getNetworkEndpoints } from '@injectivelabs/networks'\nimport { MsgBroadcaster } from '@injectivelabs/wallet-core'\nimport { MsgSend } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { WalletStrategy } from '@injectivelabs/wallet-strategy'\n\nexport const alchemyRpcEndpoint = \"\"\nexport const walletStrategy = new WalletStrategy({\n  chainId: ChainId.Mainnet,\n  ethereumOptions: {\n    ethereumChainId: EthereumChainId.Mainnet,\n    rpcUrl: alchemyRpcEndpoint\n  },\n  strategies: {}\n})\n\nexport const msgBroadcaster = new MsgBroadcaster({\n  walletStrategy,\n  simulateTx: true,\n  network: Network.Mainnet,\n  endpoints: getNetworkEndpoints(Network.Mainnet),\n  gasBufferCoefficient: 1.1,\n})\n\n// Usage Example\n(async () => {\n  const signer = 'inj1...'\n\n  const msg = MsgSend.fromJSON({\n    amount: {\n        denom: 'inj',\n        amount: new BigNumberInBase(0.01).toWei().toFixed()\n    },\n    srcInjectiveAddress: signer,\n    dstInjectiveAddress: 'inj1...',\n  });\n\n  // Prepare + Sign + Broadcast the transaction using the Wallet Strategy\n  await msgBroadcastClient.broadcast({\n      injectiveAddress: signer,\n      msgs: msg\n  })\n})()\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/transactions/msgbroadcaster\\#constructor-broadcast-options)    Constructor/Broadcast Options\n\nWe allow to override some of the options passed to the constructor of `MsgBroadcaster` as well as when broadcasting the transaction. Here is the interface and the meaning of each field\n\nCopy\n\n````inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { Msgs } from '@injectivelabs/sdk-ts'\nimport { ChainId, EthereumChainId } from '@injectivelabs/ts-types'\nimport { Network, NetworkEndpoints } from '@injectivelabs/networks'\nimport type { WalletStrategy } from '../strategies'\n\nexport interface MsgBroadcasterOptions {\n  network: Network /** network configuration (chainId, fees, etc) - Network.MainnetSentry for mainnet or  Network.TestnetSentry for testnet */\n  endpoints?: NetworkEndpoints /** optional - overriding the endpoints taken from the `network` param **/\n  feePayerPubKey?: string /** optional - if you are using the fee delegation service, you can set the fee payer so you don't do an extra query to the Web3Gateway */\n  simulateTx?: boolean /** simulate the transaction before broadcasting + get gas fees needed for the transaction */\n  txTimeout?: number /** optional - blocks to wait for tx to be included in a block **/\n  walletStrategy: WalletStrategy\n  gasBufferCoefficient?: number /** optional - as gas buffer to add to the simulated/hardcoded gas to ensure the transaction is included in a block */\n}\n\nexport interface MsgBroadcasterTxOptions {\n  memo?: string /** MEMO added to the transaction **/\n  injectiveAddress: string /** the signer of the transaction **/\n  msgs: Msgs | Msgs[] /** the messages to pack into a transaction **/\n\n  /*\n  *** overriding the hardcoded gas/simulation -\n  *** depending on the simulateTx parameter in\n  *** the MsgBroadcaster constructor\n  */\n  gas?: {\n    gasPrice?: string\n    gas?: number /** gas limit */\n    feePayer?: string\n    granter?: string\n  }\n}\n\n```\n````\n\nTo override the `endpoints` and use your infrastructure (which is something we recommend), please read more on the [Networks](https://docs.ts.injective.network/getting-started/application-concepts/networks) page on the endpoints you need to provide and how to set them up.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/msgbroadcaster\\#msgbroadcaster-with-private-key)    MsgBroadcaster with Private Key\n\nThis MsgBroadcaster is used with a private key (mostly used for CLI environments). Constructor/broadcast options are quite similar as for the `MsgBroadcaster`.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgSend, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\n\nexport const msgBroadcasterWithPk = new MsgBroadcasterWithPk({\nprivateKey: `0x...`, /** private key hash or PrivateKey class from sdk-ts */\nnetwork: NETWORK,\n})\n\n// Usage Example\n(async () => {\nconst signer = 'inj1...'\n\nconst msg = MsgSend.fromJSON({\n    amount: {\n        denom: 'inj',\n        amount: new BigNumberInBase(0.01).toWei().toFixed()\n    },\n    srcInjectiveAddress: signer,\n    dstInjectiveAddress: 'inj1...',\n});\n\n// Prepare + Sign + Broadcast the transaction using the Wallet Strategy\nawait msgBroadcasterWithPk.broadcast({\n      injectiveAddress: signer,\n      msgs: msg\n})\n})()\n```\n\n[PreviousEthereum Ledger](https://docs.ts.injective.network/transactions/ethereum/ethereum-ledger) [NextPrivate Key](https://docs.ts.injective.network/transactions/private-key)\n\nLast updated 11 days ago\n\n<|firecrawl-page-66-lllmstxt|>\n## Signing Transactions with PrivateKey\nIn this document, we are going to show you how to use a PrivateKey to sign transactions on Injective.\n\nEvery transaction on Injective follows the same flow. The flow consists of three steps: preparing, signing and broadcasting the transaction. Let's dive into each step separately and explain the process in-depth (including examples) so we can understand the whole transaction flow.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/private-key\\#preparing-a-transaction)    Preparing a transaction\n\nFirst of, we need to prepare the transaction for signing.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgSend,\n  PrivateKey,\n  BaseAccount,\n  DEFAULT_STD_FEE,\n  ChainRestAuthApi,\n  createTransaction,\n  ChainRestTendermintApi,\n} from '@injectivelabs/sdk-ts'\nimport {\n  DEFAULT_STD_FEE,\n  DEFAULT_BLOCK_TIMEOUT_HEIGHT,\n} from '@injectivelabs/utils'\nimport { ChainId } from '@injectivelabs/ts-types'\nimport { Network, getNetworkEndpoints } from '@injectivelabs/networks'\n\nconst privateKeyHash = ''\nconst privateKey = PrivateKey.fromHex(privateKeyHash)\nconst injectiveAddress = privateKey.toBech32()\nconst address = privateKey.toAddress()\nconst pubKey = privateKey.toPublicKey().toBase64()\nconst chainId = 'injective-1' /* ChainId.Mainnet */\nconst restEndpoint =\n  'https://lcd.injective.network' /* getNetworkEndpoints(Network.Mainnet).rest */\nconst amount = {\n  amount: new BigNumberInBase(0.01).toWei().toFixed(),\n  denom: 'inj',\n}\n\n/** Account Details **/\nconst chainRestAuthApi = new ChainRestAuthApi(restEndpoint)\nconst accountDetailsResponse = await chainRestAuthApi.fetchAccount(\n  injectiveAddress,\n)\nconst baseAccount = BaseAccount.fromRestApi(accountDetailsResponse)\nconst accountDetails = baseAccount.toAccountDetails()\n\n/** Block Details */\nconst chainRestTendermintApi = new ChainRestTendermintApi(restEndpoint)\nconst latestBlock = await chainRestTendermintApi.fetchLatestBlock()\nconst latestHeight = latestBlock.header.height\nconst timeoutHeight = new BigNumberInBase(latestHeight).plus(\n  DEFAULT_BLOCK_TIMEOUT_HEIGHT,\n)\n\n/** Preparing the transaction */\nconst msg = MsgSend.fromJSON({\n  amount,\n  srcInjectiveAddress: injectiveAddress,\n  dstInjectiveAddress: injectiveAddress,\n})\n\n/** Prepare the Transaction **/\nconst { txRaw, signBytes } = createTransaction({\n  pubKey,\n  chainId,\n  fee: DEFAULT_STD_FEE,\n  message: msgs,\n  sequence: baseAccount.sequence,\n  timeoutHeight: timeoutHeight.toNumber(),\n  accountNumber: baseAccount.accountNumber,\n})\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/private-key\\#signing-a-transaction)    Signing a transaction\n\nOnce we have prepared the transaction, we proceed to signing. Once you get the `txRaw` transaction from the previous step use any Cosmos native wallet to sign (ex: Keplr),\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainId } from '@injectivelabs/ts-types'\n\n/* Sign the Transaction */\nconst privateKeyHash = ''\nconst privateKey = PrivateKey.fromHex(privateKeyHash);\nconst signBytes = /* From the previous step */\n\n/** Sign transaction */\nconst signature = await privateKey.sign(Buffer.from(signBytes));\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/private-key\\#broadcasting-a-transaction)    Broadcasting a transaction\n\nOnce we have the signature ready, we need to broadcast the transaction to the Injective chain itself. After getting the signature from the second step, we need to include that signature in the signed transaction and broadcast it to the chain.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainId } from '@injectivelabs/ts-types'\nimport { TxRestClient } from '@injectivelabs/sdk-ts'\nimport { Network, getNetworkInfo } from '@injectivelabs/networks'\n\n/** Append Signatures */\nconst network = getNetworkInfo(Network.Testnet);\nconst txRaw = /* from the first step */\nconst signature = /* from the second step */\ntxRaw.signatures = [signature];\n\n/** Calculate hash of the transaction */\nconsole.log(`Transaction Hash: ${TxClient.hash(txRaw)}`);\n\nconst txService = new TxGrpcClient(network.grpc);\n\n/** Simulate transaction */\nconst simulationResponse = await txService.simulate(txRaw);\n\nconsole.log(\n  `Transaction simulation response: ${JSON.stringify(\n    simulationResponse.gasInfo\n  )}`\n);\n\n/** Broadcast transaction */\nconst txResponse = await txService.broadcast(txRaw);\n\nconsole.log(txResponse);\n\nif (txResponse.code !== 0) {\n  console.log(`Transaction failed: ${txResponse.rawLog}`);\n} else {\n  console.log(\n    `Broadcasted transaction hash: ${JSON.stringify(txResponse.txHash)}`\n  );\n}\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/private-key\\#example-prepare--sign--broadcast)    Example (Prepare + Sign + Broadcast)\n\nLet's have a look at the whole flow (using Keplr as a signing wallet)\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { getNetworkInfo, Network } from '@injectivelabs/networks'\nimport {\n  TxClient,\n  PrivateKey,\n  TxGrpcClient,\n  ChainRestAuthApi,\n  createTransaction,\n} from '@injectivelabs/sdk-ts'\nimport { MsgSend } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase, DEFAULT_STD_FEE } from '@injectivelabs/utils'\n\n/** MsgSend Example */\n;(async () => {\n  const network = getNetworkInfo(Network.Testnet)\n  const privateKeyHash =\n    'f9db9bf330e23cb7839039e944adef6e9df447b90b503d5b4464c90bea9022f3'\n  const privateKey = PrivateKey.fromHex(privateKeyHash)\n  const injectiveAddress = privateKey.toBech32()\n  const publicKey = privateKey.toPublicKey().toBase64()\n\n  /** Account Details **/\n  const accountDetails = await new ChainRestAuthApi(network.rest).fetchAccount(\n    injectiveAddress,\n  )\n\n  /** Prepare the Message */\n  const amount = {\n    amount: new BigNumberInBase(0.01).toWei().toFixed(),\n    denom: 'inj',\n  }\n\n  const msg = MsgSend.fromJSON({\n    amount,\n    srcInjectiveAddress: injectiveAddress,\n    dstInjectiveAddress: injectiveAddress,\n  })\n\n  /** Prepare the Transaction **/\n  const { signBytes, txRaw } = createTransaction({\n    message: msg,\n    memo: '',\n    fee: DEFAULT_STD_FEE,\n    pubKey: publicKey,\n    sequence: parseInt(accountDetails.account.base_account.sequence, 10),\n    accountNumber: parseInt(\n      accountDetails.account.base_account.account_number,\n      10,\n    ),\n    chainId: network.chainId,\n  })\n\n  /** Sign transaction */\n  const signature = await privateKey.sign(Buffer.from(signBytes))\n\n  /** Append Signatures */\n  txRaw.signatures = [signature]\n\n  /** Calculate hash of the transaction */\n  console.log(`Transaction Hash: ${TxClient.hash(txRaw)}`)\n\n  const txService = new TxGrpcClient(network.grpc)\n\n  /** Simulate transaction */\n  const simulationResponse = await txService.simulate(txRaw)\n  console.log(\n    `Transaction simulation response: ${JSON.stringify(\n      simulationResponse.gasInfo,\n    )}`,\n  )\n\n  /** Broadcast transaction */\n  const txResponse = await txService.broadcast(txRaw)\n\n  if (txResponse.code !== 0) {\n    console.log(`Transaction failed: ${txResponse.rawLog}`)\n  } else {\n    console.log(\n      `Broadcasted transaction hash: ${JSON.stringify(txResponse.txHash)}`,\n    )\n  }\n})()\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/private-key\\#example-with-msgbroadcasterwithpk)    Example with MsgBroadcasterWithPk\n\nYou can use the `MsgBroadcasterWithPk` class from the `@injectivelabs/sdk-ts` package which abstracts away most of the logic written above into a single class.\n\n**This abstraction allows you to sign transactions in a Node/CLI environment.**\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgSend, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst amount = {\n  denom: 'inj',\n  amount: new BigNumberInBase(1).toWei().toFixed(),\n}\nconst msg = MsgSend.fromJSON({\n  amount,\n  srcInjectiveAddress: injectiveAddress,\n  dstInjectiveAddress: injectiveAddress,\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n[PreviousMsgBroadcaster](https://docs.ts.injective.network/transactions/msgbroadcaster) [NextWeb3 Gateway](https://docs.ts.injective.network/transactions/web3-gateway)\n\nLast updated 1 year ago\n\n<|firecrawl-page-67-lllmstxt|>\n## Web3 Gateway Overview\n_Pre-requisite reading #1:_ [Transaction Lifecycle](https://docs.cosmos.network/main/basics/tx-lifecycle)\n\n_Pre-requisite reading #2:_ Transactions on Injective\n\nThe Web3Gateway microservice exposes an API to the end user with the main purpose of providing fee delegation for transactions that happen on Injective. This allows users to enjoy a gasless environment while interacting with Injective as the gas is paid for by the runner of the Web3Gateway service.\n\nAlongside fee delegation support, Web3Gateway allows developers to convert Messages to EIP712 typed data. After converting the Message the EIP712 data, it can be signed by any Ethereum native wallet and then broadcasted to Injective.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/web3-gateway\\#fee-delegation)    Fee Delegation\n\nAs said before, fee delegation allows users to interact with Injective (submit transactions) without having to pay for gas. As a part of the _Transaction Lifecycle_ of every Cosmos-SDK powered chain, we have `AnteHandler`'s, which, among other things perform a signature verification, gas calculation, and fee deduction.\n\nThere are a couple of things that we need to know:\n\n- Transactions can have multiple signers (i.e we can include multiple signatures within a transaction),\n\n- Gas Fee for the transaction is deducted from the `authInfo.fee.feePayer` value and the signature that gets verified against the `feePayer` is the first signature within the signatures list of the Transaction ( [reference](https://github.com/cosmos/cosmos-sdk/blob/e2d6cbdeb55555893ffde3f2ae0ed6db7179fd0d/x/auth/ante/fee.go#L15-L24)),\n\n- The rest of the signatures are being verified against the actual sender of the transaction.\n\n\nKnowing this, to achieve fee delegation, we have to sign the transaction using the private key of the Web3Gateway microservice, including the address of that `privateKey` as a `feePayer`, sign this transaction using the privateKey that we want to interact with Injective from, and broadcast that transaction.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/web3-gateway\\#web3gateway-api)    Web3Gateway API\n\nEveryone can run the Web3Gateway microservice and provide fee delegation services to their users. An example usage can be developers who build exchange dApps on top of Injective run this microservice to offer a gasless trading environment to their traders.\n\nThis microservice exposes an API containing two core methods:\n\n- `PrepareTx`(and `PrepareCosmosTx`)\n\n- `BroadcastTx` (and `BroadcastCosmosTx`)\n\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/web3-gateway\\#preparetx)    PrepareTx\n\nThe `PrepareTx` method accepts a Message(s) including context for the transaction the user wants to execute ( `chainId`, `signerAddress`, `timeoutHeight`, etc), and returns an EIP712 typed data of the particular message, including its signature within the EIP712 typed data. We can use this EIP712 typed data to sign it using any Ethereum native wallet and get the signature for users who want to interact with Injective.\n\nThe EIP712 typed data is generated from the proto definition of the Message we pass to the `PrepareTx` method.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/web3-gateway\\#broadcasttx)    BroadcastTx\n\nThe `BroadcastTx` method is responsible for broadcasting the transaction to the node. Alongside the full response of the `PrepareTx` API call, we pass in the signature of the EIP712 typed data. Then, the `BroadcastTx` packs the Message into a native Cosmos transaction, prepares the transaction (including its context) and broadcasts it to Injective. As a result, the transaction hash is being returned to the user.\n\n### [Direct link to heading](https://docs.ts.injective.network/transactions/web3-gateway\\#prepare-broadcastcosmostx)    Prepare/BroadcastCosmosTx\n\nThe above methods are used when we use **Ethereum Native wallets** to sign and broadcast transactions as we sign an EIP712 transaction representation.\n\nIf we want support fee delegation on Cosmos native wallets using the Web3Gateway, we can omit the PrepareCosmosTx call (or call it if we need the Web3Gateway signer's `publicKey`), prepare the transaction on the client side, sign it using a Cosmos wallet, and broadcast it using the `BroadcastCosmosTx` method.\n\nThe way this works is we add the `publicKey` of the `Web3Gateway`'s signer to the `authInfo` object in the `TxRaw` and then sign the transaction using the `privateKey` on the API side when we broadcast\n\nThe difference with the previous EIP712 approach is that we need to sign the transaction using the `Web3Gateway`'s signer in advance i.e when we generate the EIP712 -> meaning that we need to use `PrepareTx` and can't generate the transaction on the client side.).\n\n[PreviousPrivate Key](https://docs.ts.injective.network/transactions/private-key) [NextGetting Started](https://docs.ts.injective.network/core-modules-and-examples/core-modules)\n\nLast updated 11 months ago\n\n<|firecrawl-page-68-lllmstxt|>\n## Injective Core Modules\nWithin this section, we are going to explore the core modules of the Injective chain and provide examples of how to make and broadcast transactions for each of the Messages defined on-chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/core-modules\\#topics)    Topics\n\nTopic\n\nDescription\n\n[Auction](https://docs.ts.injective.network/core-modules-and-examples/auction)\n\nUsed for the buy-back-and-burn on chain mechanism\n\n[AuthZ](https://docs.ts.injective.network/core-modules-and-examples/authz)\n\nUsed for granting account priveledges\n\n[Bank](https://docs.ts.injective.network/core-modules-and-examples/bank)\n\nUsed for managing users assets (funds)\n\n[Distribution](https://docs.ts.injective.network/core-modules-and-examples/distribution)\n\nUsed for on-chain distribution/minting\n\n[Exchange](https://docs.ts.injective.network/core-modules-and-examples/exchange)\n\nUsed for the exchange primitives\n\n[Feegrant](https://docs.ts.injective.network/core-modules-and-examples/feegrant)\n\nUsed for granting fee allowance priveledges\n\n[Governance](https://docs.ts.injective.network/core-modules-and-examples/governance)\n\nUsed for on-chain governance\n\n[IBC](https://docs.ts.injective.network/core-modules-and-examples/ibc)\n\nUsed for cross-Cosmos chain transfers\n\n[Insurance](https://docs.ts.injective.network/core-modules-and-examples/insurance)\n\nUsed for on-chain insurance funds\n\n[Peggy](https://docs.ts.injective.network/core-modules-and-examples/peggy)\n\nUsed for the Injective <> Ethereum Bridge\n\n[Permissions](https://docs.ts.injective.network/core-modules-and-examples/permissions)\n\nUsed fot on-chain permissions\n\n[Staking](https://docs.ts.injective.network/core-modules-and-examples/staking)\n\nUsed for on-chain staking\n\n[Tokenfactory](https://docs.ts.injective.network/core-modules-and-examples/token-factory)\n\nUsed for creating and managing `tokenfactory` tokens\n\n[Wasm](https://docs.ts.injective.network/core-modules-and-examples/wasm)\n\nUsed for interacting with the Cosmwasm Layer\n\n[PreviousWeb3 Gateway](https://docs.ts.injective.network/transactions/web3-gateway) [NextAuction](https://docs.ts.injective.network/core-modules-and-examples/auction)\n\nLast updated 6 months ago\n\n<|firecrawl-page-69-lllmstxt|>\n## INJ Auction Module\nThe `auction` module is heart of the `buy-back-and-burn` on chain mechanism, where 60% of the weekly trading fees are collected and auctioned off to the highest INJ bidder where the submitted INJ of the highest bidder are burned in the process.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/auction\\#msgbid)    MsgBid\n\nThis message is used to submit a bid on the [auction](https://hub.injective.network/auction/) held weekly to allow members to use INJ to bid for the basket of trading fees (60%) collected by Injective that week.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgBid,\n  ChainGrpcAuctionApi,\n  MsgBroadcasterWithPk,\n} from '@injectivelabs/sdk-ts'\nimport { ChainId } from '@injectivelabs/ts-types'\nimport { INJ_DENOM, BigNumberInBase } from '@injectivelabs/utils'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\nconst endpointsForNetwork = getNetworkEndpoints(Network.Mainnet)\nconst auctionApi = new ChainGrpcAuctionApi(endpointsForNetwork.grpc)\n\nconst injectiveAddress = 'inj1...'\n/* format amount for bid, note that bid amount has to be higher than the current highest bid */\nconst amount = {\n  denom: INJ_DENOM,\n  amount: new BigNumberInBase(1).toWei(),\n}\n\nconst latestAuctionModuleState = await auctionApi.fetchModuleState()\nconst latestRound = latestAuctionModuleState.auctionRound\n\n/* create message in proto format */\nconst msg = MsgBid.fromJSON({\n  amount,\n  injectiveAddress,\n  round: latestRound,\n})\n\nconst privateKey = '0x...'\n\n/* broadcast transaction */\nconst txHash = await new MsgBroadcasterWithPk({\n  network: Network.Mainnet,\n  privateKey,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/auction\\#burn-auction-deposit-via-msgexternaltransfer)    Burn Auction Deposit via MsgExternalTransfer\n\nIf you would like to grow the burn auction's pool size, you can directly send funds to the Auction subaccount.\n\nNotes:\n\n- You will need to send funds to the pool's subaccount `0x1111111111111111111111111111111111111111111111111111111111111111`.\n\n- Be aware that any funds you send will be reflected in the next auction, not the current one.\n\n- You cannot transfer from your default subaccountId since that balance is now associated with your Injective address in the bank module. Therefore, in order for `MsgExternalTransfer` to work, you will need to transfer from a non-default subaccountId.\n\n\nHow to find the subaccountId that you will be transferring from:\n\n- you can query your existing subaccountIds via the [account portfolio api](https://docs.ts.injective.network/querying/querying-api/querying-indexer-portfolio).\n\n\nHow to use funds that are currently associated with your Injective Address in bank module:\n\n- If you have existing non-default subaccounts, you'll want to do a [MsgDeposit](https://docs.ts.injective.network/core-modules-and-examples/exchange#msgdeposit) to one of your existing non-default subaccountIds and use that subaccountId as the `srcSubaccountId` below.\n\n- If you don't have existing non-default subaccounts, you can do a [MsgDeposit](https://docs.ts.injective.network/core-modules-and-examples/exchange#msgdeposit) to a new default subaccountId, which would be done via importing `getSubaccountId` from `sdk-ts` and setting the `subaccountId` field in [MsgDeposit](https://docs.ts.injective.network/core-modules-and-examples/exchange#msgdeposit) to `getSubaccountId(injectiveAddress, 1)`.\n\n\nFor more info, check out the [burn auction pool docs](https://docs.injective.network/developers/modules/injective/auction).\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  DenomClient,\n  MsgExternalTransfer,\n  MsgBroadcasterWithPk,\n} from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst denomClient = new DenomClient(Network.Mainnet)\n\nconst injectiveAddress = 'inj1...'\nconst srcSubaccountId = '0x...'\nconst POOL_SUBACCOUNT_ID = `0x1111111111111111111111111111111111111111111111111111111111111111`\nconst USDT_TOKEN_SYMBOL = 'USDT'\nconst tokenMeta = denomClient.getTokenMetaDataBySymbol(USDT_TOKEN_SYMBOL)\nconst tokenDenom = `peggy${tokenMeta.erc20.address}`\n\n/* format amount to add to the burn auction pool */\nconst amount = {\n  denom: tokenDenom,\n  amount: new BigNumberInBase(1).toWei(tokenMeta.decimals).toFixed(),\n}\n\n/* create message in proto format */\nconst msg = MsgExternalTransfer.fromJSON({\n  amount,\n  srcSubaccountId,\n  injectiveAddress,\n  dstSubaccountId: POOL_SUBACCOUNT_ID,\n})\n\nconst privateKey = '0x...'\n\n/* broadcast transaction */\nconst txHash = await new MsgBroadcasterWithPk({\n  network: Network.Mainnet,\n  privateKey,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n[PreviousGetting Started](https://docs.ts.injective.network/core-modules-and-examples/core-modules) [NextAuthZ](https://docs.ts.injective.network/core-modules-and-examples/authz)\n\nLast updated 3 months ago\n\n<|firecrawl-page-70-lllmstxt|>\n## Authz Module Overview\nThe `authz` module is an implementation of a Cosmos SDK module, per ADR 30, that allows granting arbitrary privileges from one account (the granter) to another account (the grantee).\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/authz\\#messages)    Messages\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/authz\\#msggrant)    MsgGrant\n\nAn authorization grant is created using the MsgGrant message. If there is already a grant for the (granter, grantee, Authorization) triple, then the new grant will overwrite the previous one. To update or extend an existing grant, a new grant with the same (granter, grantee, Authorization) triple should be created.\n\nList of useful message types:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n\"/injective.exchange.v1beta1.MsgCreateSpotLimitOrder\",\n\"/injective.exchange.v1beta1.MsgCreateSpotMarketOrder\",\n\"/injective.exchange.v1beta1.MsgCancelSpotOrder\",\n\"/injective.exchange.v1beta1.MsgBatchUpdateOrders\",\n\"/injective.exchange.v1beta1.MsgBatchCancelSpotOrders\",\n\"/injective.exchange.v1beta1.MsgDeposit\",\n\"/injective.exchange.v1beta1.MsgWithdraw\",\n\"/injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder\",\n\"/injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder\",\n\"/injective.exchange.v1beta1.MsgCancelDerivativeOrder\",\n\"/injective.exchange.v1beta1.MsgBatchUpdateOrders\",\n\"/injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders\",\n\"/injective.exchange.v1beta1.MsgDeposit\",\n\"/injective.exchange.v1beta1.MsgWithdraw\",\n```\n\nPer [cosmos sdk docs](https://docs.cosmos.network/main/modules/authz), \"Authorizations must be granted for a particular Msg service method one by one\", so the following code snipped must be repeated for each message type that you would like for the `grantee` to have authorization on behalf of a `granter`.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgGrant, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKeyOfGranter = '0x...'\nconst grantee = 'inj...'\nconst granter = 'inj...'\nconst messageType = '/injective.exchange.v1beta1.MsgCreateSpotLimitOrder' /* example message type */\n\nconst msg = MsgGrant.fromJSON({\n   messageType,\n    grantee,\n    granter\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey: privateKeyOfGranter,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/authz\\#msgexec)    MsgExec\n\nWhen a grantee wants to execute a transaction on behalf of a granter, they must send MsgExec. In this example, we'll do a MsgSend to transfer assets from the granter's account address to another account address.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgExec, MsgSend, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKeyOfGrantee = '0x...'\nconst grantee = 'inj...'\nconst granter = 'inj...'\n\nconst msgs = MsgSend.fromJSON({\n    amount: {\n        denom: 'inj',\n        amount: new BigNumberInBase(0.01).toWei().toFixed()\n    },\n    srcInjectiveAddress: granter,\n    dstInjectiveAddress: 'inj1...',\n  });\n\nconst msg = MsgExec.fromJSON({\n    msgs,\n    grantee,\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey: privateKeyOfGrantee,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/authz\\#msgrevoke)    MsgRevoke\n\nA grant can be removed with the MsgRevoke message.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgRevoke, MsgBroadcasterWithPk, getEthereumAddress } from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKeyOfGranter = '0x...'\nconst grantee = 'inj...'\nconst granter = 'inj...'\nconst messageType = '/injective.exchange.v1beta1.MsgCreateSpotLimitOrder' /* example message type */\n\nconst msg = MsgRevoke.fromJSON({\n   messageType,\n    grantee,\n    granter\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey: privateKeyOfGranter,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n[PreviousAuction](https://docs.ts.injective.network/core-modules-and-examples/auction) [NextBank](https://docs.ts.injective.network/core-modules-and-examples/bank)\n\nLast updated 1 year ago\n\n<|firecrawl-page-71-lllmstxt|>\n## Bank Module Overview\nThe bank module is responsible for handling multi-asset coin transfers between accounts and tracking special-case pseudo-transfers which must work differently with particular kinds of accounts (notably delegating/undelegating for vesting accounts). It exposes several interfaces with varying capabilities for secure interaction with other modules which must alter user balances.\n\nIn addition, the bank module tracks and provides query support for the total supply of all assets used in the application.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/bank\\#messages)    Messages\n\nLet's explore (and provide examples) the messages that the Bank module exports and we can use to interact with the Injective chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/bank\\#msgsend)    MsgSend\n\nThis message is used to send coins from one address to another. Any TokenFactory token and Peggy token can be used here. To transfer CW20 tokens, see the `MsgExecuteContract` section [here](https://docs.ts.injective.network/core-modules/wasm#msgexecutecontract-transfer).\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgSend, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst amount = {\n  denom: 'inj',\n  amount: new BigNumberInBase(1).toWei()\n}\nconst msg = MsgSend.fromJSON({\n  amount,\n  srcInjectiveAddress: injectiveAddress,\n  dstInjectiveAddress: injectiveAddress\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/bank\\#msgmultisend)    MsgMultiSend\n\nThis message is used to send to multiple recipients from multiple senders.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgMultiSend, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase, BigNumberInWei } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst denom = 'inj'\nconst decimals = 18\nconst records = [/** add records here */] as {\n    address: string;\n    amount: string; /* in a human readable number */\n}[];\nconst totalToSend = records.reduce((acc, record) => {\n  return acc.plus(new BigNumberInBase(record.amount).toWei(decimals));\n}, new BigNumberInWei(0));\n\nconst msg = MsgMultiSend.fromJSON({\n  inputs: [\\\n    {\\\n      address: injectiveAddress,\\\n      coins: [\\\n        {\\\n          denom,\\\n          amount: totalToSend.toFixed(),\\\n        },\\\n      ],\\\n    },\\\n  ],\n  outputs: records.map((record) => {\n    return {\n      address: record.address,\n      coins: [\\\n        {\\\n          amount: new BigNumberInBase(record.amount)\\\n            .toWei(decimals)\\\n            .toFixed(),\\\n          denom,\\\n        },\\\n      ],\n    };\n  }),\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n[PreviousAuthZ](https://docs.ts.injective.network/core-modules-and-examples/authz) [NextDistribution](https://docs.ts.injective.network/core-modules-and-examples/distribution)\n\nLast updated 10 months ago\n\n<|firecrawl-page-72-lllmstxt|>\n## Staking Rewards Management\nThe `distribution` module is extended from the cosmos sdk [distribution module](https://github.com/InjectiveLabs/cosmos-sdk/tree/master/x/distribution), where delegator can withdraw their staking rewards from the validator.\n\nDistribution -> MsgWithdrawValidatorCommission\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/distribution\\#msgwithdrawdelegatorreward)    MsgWithdrawDelegatorReward\n\nThis message is used to withdraw all available delegator staking rewards from the validator.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgBroadcasterWithPk,\n  MsgWithdrawDelegatorReward,\n} from \"@injectivelabs/sdk-ts\";\nimport {  Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst validatorAddress = \"inj1...\";\n\n/* create message in proto format */\nconst msg = MsgWithdrawDelegatorReward.fromJSON({\n  validatorAddress,\n  delegatorAddress: injectiveAddress,\n});\n\nconst privateKey = \"0x...\";\n\n/* broadcast transaction */\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Mainnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/distribution\\#msgwithdrawvalidatorcommission)    MsgWithdrawValidatorCommission\n\nThis message is used by the validator to withdraw the commission earned.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgBroadcasterWithPk,\n  MsgWithdrawValidatorCommission,\n} from \"@injectivelabs/sdk-ts\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst validatorAddress = \"inj1...\";\n\n/* create message in proto format */\nconst msg = MsgWithdrawValidatorCommission.fromJSON({\n  validatorAddress,\n});\n\nconst privateKey = \"0x...\";\n\n/* broadcast transaction */\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n```\n\n[PreviousBank](https://docs.ts.injective.network/core-modules-and-examples/bank) [NextExchange](https://docs.ts.injective.network/core-modules-and-examples/exchange)\n\nLast updated 1 year ago\n\n<|firecrawl-page-73-lllmstxt|>\n## Injective Exchange Module\nThe `exchange` module is the heart of the Injective Chain which enables fully decentralized spot and derivative exchange. It is the sine qua non module of the chain and integrates tightly with the `auction`, `insurance`, `oracle`, and `peggy` modules.\n\nThe exchange protocol enables traders to create and trade on arbitrary spot and derivative markets. The entire process of orderbook management, trade execution, order matching and settlement occurs on chain through the logic codified by the exchange module.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#messages)    Messages\n\nLet's explore (and provide examples) the Messages that the Exchange module exports and we can use to interact with the Injective chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgdeposit)    MsgDeposit\n\nThis Message is used to send coins from the Bank module to a wallet's subaccount\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgDeposit, MsgBroadcasterWithPk, getEthereumAddress } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\n\nconst amount = {\n  denom: 'inj',\n  amount: new BigNumberInBase(1).toWei()\n}\n\nconst ethereumAddress = getEthereumAddress(injectiveAddress)\nconst subaccountIndex = 0\nconst suffix = '0'.repeat(23) + subaccountIndex\nconst subaccountId = ethereumAddress + suffix\n\nconst msg = MsgDeposit.fromJSON({\n  amount,\n  subaccountId,\n  injectiveAddress\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgwithdraw)    MsgWithdraw\n\nThis Message is used to send coins from the wallet's subaccount back to the users Bank funds\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgWithdraw, MsgBroadcasterWithPk, getEthereumAddress } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\n\nconst amount = {\n  denom: 'inj',\n  amount: new BigNumberInBase(1).toWei()\n}\n\nconst ethereumAddress = getEthereumAddress(injectiveAddress)\nconst subaccountIndex = 0\nconst suffix = '0'.repeat(23) + subaccountIndex\nconst subaccountId = ethereumAddress + suffix\n\nconst msg = MsgWithdraw.fromJSON({\n  amount,\n  subaccountId,\n  injectiveAddress\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgcreatespotlimitorder)    MsgCreateSpotLimitOrder\n\nThis Message is used to create a spot limit order\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgCreateSpotLimitOrder,\n  MsgBroadcasterWithPk,\n  getEthereumAddress,\n  getSpotMarketTensMultiplier\n} from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase, spotPriceToChainPriceToFixed, spotQuantityToChainQuantityToFixed } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst feeRecipient = 'inj1...'\nconst market = {\n  marketId: '0x...',\n  baseDecimals: 18,\n  quoteDecimals: 6,\n  minPriceTickSize: '', /* fetched from the chain */\n  minQuantityTickSize: '', /* fetched from the chain */\n  priceTensMultiplier: '', /** can be fetched from getSpotMarketTensMultiplier */\n  quantityTensMultiplier: '', /** can be fetched from getSpotMarketTensMultiplier */\n}\n\nconst order = {\n  price: 1,\n  quantity: 1\n}\n\nconst ethereumAddress = getEthereumAddress(injectiveAddress)\nconst subaccountIndex = 0\nconst suffix = '0'.repeat(23) + subaccountIndex\nconst subaccountId = ethereumAddress + suffix\n\nconst msg = MsgCreateSpotLimitOrder.fromJSON({\n  subaccountId,\n  injectiveAddress,\n  orderType: 1, /* Buy */\n  price: spotPriceToChainPriceToFixed({\n    value: order.price,\n    tensMultiplier: market.priceTensMultiplier,\n    baseDecimals: market.baseDecimals,\n    quoteDecimals: market.quoteDecimals\n  }),\n  quantity: spotQuantityToChainQuantityToFixed({\n    value: order.quantity,\n    tensMultiplier: market.quantityTensMultiplier,\n    baseDecimals: market.baseDecimals\n  }),\n  marketId: market.marketId,\n  feeRecipient: feeRecipient\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgcreatespotmarketorder)    MsgCreateSpotMarketOrder\n\nThis Message is used to create a spot market order\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgCreateSpotMarketOrder,\n  MsgBroadcasterWithPk,\n  getEthereumAddress,\n  getSpotMarketTensMultiplier\n} from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase, spotPriceToChainPriceToFixed, spotQuantityToChainQuantityToFixed } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst feeRecipient = 'inj1...'\nconst market = {\n  marketId: '0x...',\n  baseDecimals: 18,\n  quoteDecimals: 6,\n  minPriceTickSize: '', /* fetched from the chain */\n  minQuantityTickSize: '', /* fetched from the chain */\n  priceTensMultiplier: '', /** can be fetched from getSpotMarketTensMultiplier */\n  quantityTensMultiplier: '', /** can be fetched from getSpotMarketTensMultiplier */\n}\nconst order = {\n  price: 10,\n  quantity: 1\n}\n\nconst ethereumAddress = getEthereumAddress(injectiveAddress)\nconst subaccountIndex = 0\nconst suffix = '0'.repeat(23) + subaccountIndex\nconst subaccountId = ethereumAddress + suffix\n\nconst msg = MsgCreateSpotMarketOrder.fromJSON({\n  subaccountId,\n  injectiveAddress,\n  orderType: 1, /* Buy */\n  price: spotPriceToChainPriceToFixed({\n    value: order.price,\n    tensMultiplier: market.priceTensMultiplier,\n    baseDecimals: market.baseDecimals,\n    quoteDecimals: market.quoteDecimals\n  }),\n  quantity: spotQuantityToChainQuantityToFixed({\n    value: order.quantity,\n    tensMultiplier: market.quantityTensMultiplier,\n    baseDecimals: market.baseDecimals\n  }),\n  marketId: market.marketId,\n  feeRecipient: feeRecipient,\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgcreatederivativelimitorder)    MsgCreateDerivativeLimitOrder\n\nThis Message is used to create a derivative limit order\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgCreateDerivativeLimitOrder,\n  MsgBroadcasterWithPk,\n  getEthereumAddress,\n  getDerivativeMarketTensMultiplier\n} from '@injectivelabs/sdk-ts'\nimport {\n  BigNumberInBase,\n  derivativePriceToChainPriceToFixed,\n  derivativeQuantityToChainQuantityToFixed,\n  derivativeMarginToChainMarginToFixed\n} from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst feeRecipient = 'inj1...'\nconst market = {\n  marketId: '0x...',\n  baseDecimals: 18,\n  quoteDecimals: 6,\n  minPriceTickSize: '', /* fetched from the chain */\n  minQuantityTickSize: '', /* fetched from the chain */\n  priceTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n  quantityTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n}\nconst order = {\n  price: 10,\n  quantity: 1,\n  margin: 10\n}\n\nconst ethereumAddress = getEthereumAddress(injectiveAddress)\nconst subaccountIndex = 0\nconst suffix = '0'.repeat(23) + subaccountIndex\nconst subaccountId = ethereumAddress + suffix\n\nconst msg = MsgCreateDerivativeLimitOrder.fromJSON(\n  orderType: 1 /* Buy */,\n  triggerPrice: '0',\n  injectiveAddress,\n  price: derivativePriceToChainPriceToFixed({\n    value: order.price,\n    quoteDecimals: market.quoteDecimals\n  }),\n  quantity: derivativeQuantityToChainQuantityToFixed({ value: order.quantity }),\n  margin: derivativeMarginToChainMarginToFixed({\n    value: order.margin,\n    quoteDecimals: market.quoteDecimals\n  }),\n  marketId: market.marketId,\n  feeRecipient: feeRecipient,\n  subaccountId: subaccountI\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgcreatederivativemarketorder)    MsgCreateDerivativeMarketOrder\n\nThis Message is used to create a derivative market order\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgCreateDerivativeMarketOrder,\n  MsgBroadcasterWithPk,\n  getEthereumAddress,\n  getDerivativeMarketTensMultiplier\n} from '@injectivelabs/sdk-ts'\nimport {\n  BigNumberInBase,\n  derivativePriceToChainPriceToFixed,\n  derivativeQuantityToChainQuantityToFixed,\n  derivativeMarginToChainMarginToFixed\n} from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst feeRecipient = 'inj1...'\nconst market = {\n  marketId: '0x...',\n  baseDecimals: 18,\n  quoteDecimals: 6,\n  minPriceTickSize: '', /* fetched from the chain */\n  minQuantityTickSize: '', /* fetched from the chain */\n  priceTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n  quantityTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n}\nconst order = {\n  price: 10,\n  quantity: 1,\n  margin: 10\n}\n\nconst ethereumAddress = getEthereumAddress(injectiveAddress)\nconst subaccountIndex = 0\nconst suffix = '0'.repeat(23) + subaccountIndex\nconst subaccountId = ethereumAddress + suffix\n\nconst msg = MsgCreateDerivativeMarketOrder.fromJSON(\n  orderType: 1 /* Buy */,\n  triggerPrice: '0',\n  injectiveAddress,\n  price: derivativePriceToChainPriceToFixed({\n    value: order.price,\n    tensMultiplier: market.priceTensMultiplier,\n    quoteDecimals: market.quoteDecimals\n  }),\n  quantity: derivativeQuantityToChainQuantityToFixed({\n    value: order.quantity,\n    tensMultiplier: market.quantityTensMultiplier,\n  }),\n  margin: derivativeMarginToChainMarginToFixed({\n    value: order.margin,\n    quoteDecimals: market.quoteDecimals,\n    tensMultiplier: priceTensMultiplier,\n  }),\n  marketId: market.marketId,\n  feeRecipient: feeRecipient,\n  subaccountId: subaccountI\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgbatchupdateorders)    MsgBatchUpdateOrders\n\nThis Message is used to batch update orders on the chain\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgBatchUpdateOrders,\n  MsgBroadcasterWithPk,\n  getEthereumAddress,\n  getDerivativeMarketTensMultiplier\n} from '@injectivelabs/sdk-ts'\nimport {\n  BigNumberInBase,\n  derivativePriceToChainPriceToFixed,\n  derivativeQuantityToChainQuantityToFixed,\n  derivativeMarginToChainMarginToFixed\n} from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst feeRecipient = 'inj1...'\nconst derivativeMarket = {\n  marketId: '0x...',\n  baseDecimals: 18,\n  quoteDecimals: 6,\n  minPriceTickSize: '', /* fetched from the chain */\n  minQuantityTickSize: '', /* fetched from the chain */\n  priceTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n  quantityTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n}\nconst derivativeOrder = {\n  price: 10,\n  quantity: 1,\n  margin: 10\n}\nconst spotMarket = {\n  marketId: '0x...',\n  baseDecimals: 18,\n  quoteDecimals: 6,\n  minPriceTickSize: '', /* fetched from the chain */\n  minQuantityTickSize: '', /* fetched from the chain */\n  priceTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n  quantityTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n}\nconst spotOrder = {\n  price: 10,\n  quantity: 1,\n  margin: 10\n}\n\nconst ethereumAddress = getEthereumAddress(injectiveAddress)\nconst subaccountIndex = 0\nconst suffix = '0'.repeat(23) + subaccountIndex\nconst subaccountId = ethereumAddress + suffix\n\nconst msg = MsgBatchUpdateOrders.fromJSON({\n  injectiveAddress,\n  subaccountId: subaccountId,\n  derivativeOrdersToCreate: [\\\n    {\\\n      orderType: derivativeOrder.orderType as GrpcOrderType,\\\n      price: derivativePriceToChainPriceToFixed({\\\n        value: derivativeOrder.price,\\\n        quoteDecimals: 6 /* USDT has 6 decimals */,\\\n      }),\\\n      quantity: derivativeQuantityToChainQuantityToFixed({\\\n        value: derivativeOrder.quantity,\\\n      }),\\\n      margin: derivativeMarginToChainMarginToFixed({\\\n        value: margin,\\\n        quoteDecimals: 6 /* USDT has 6 decimals */,\\\n      }),\\\n      marketId: derivativeMarket.marketId,\\\n      feeRecipient: injectiveAddress,\\\n    },\\\n  ],\n  spotOrdersToCreate: [\\\n    {\\\n      orderType: spotOrder.orderType as GrpcOrderType,\\\n      price: spotPriceToChainPriceToFixed({\\\n        value: spotOrder.price,\\\n        baseDecimals: 18 /* INJ has 18 decimals */,\\\n        quoteDecimals: 6 /* USDT has 6 decimals */,\\\n      }),\\\n      quantity: spotQuantityToChainQuantityToFixed({\\\n        value: spotOrder.quantity,\\\n        baseDecimals: 18 /* INJ has 18 decimals */,\\\n      }),\\\n      marketId: spotMarket.marketId,\\\n      feeRecipient: injectiveAddress,\\\n    },\\\n  ],\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgbatchcancelspotorders)    MsgBatchCancelSpotOrders\n\nThis Message is used to batch cancel spot orders on the chain\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgBatchCancelSpotOrders, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst orders = [{\\\n  marketId: '0x...',\\\n  subaccountId: '0x...',\\\n  orderHash: '0x...'\\\n },{\\\n  marketId: '0x...',\\\n  subaccountId: '0x...',\\\n  orderHash: '0x...'\\\n}]\n\nconst messages = orders.map((order) =>\n  MsgBatchCancelSpotOrders.fromJSON({\n    injectiveAddress,\n    orders: [\\\n      {\\\n        marketId: order.marketId,\\\n        subaccountId: order.subaccountId,\\\n        orderHash: order.orderHash\\\n      }\\\n    ]\n  })\n)\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: messages\n})\n\nconsole.log(txHash)\n```\n\nThis Message is used to batch cancel spot orders on the chain\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgbatchcancelderivativeorders)    MsgBatchCancelDerivativeOrders\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgBatchCancelDerivativeOrders, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst orders = [{\\\n  marketId: '0x...',\\\n  subaccountId: '0x...',\\\n  orderHash: '0x...'\\\n  },{\\\n  marketId: '0x...',\\\n  subaccountId: '0x...',\\\n  orderHash: '0x...'\\\n}]\n\nconst messages = orders.map((order) =>\n  MsgBatchCancelDerivativeOrders.fromJSON({\n    injectiveAddress,\n    orders: [\\\n      {\\\n        marketId: order.marketId,\\\n        subaccountId: order.subaccountId,\\\n        orderHash: order.orderHash\\\n      }\\\n    ]\n  })\n)\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: messages\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgrewardsoptout)    MsgRewardsOptOut\n\nThis Message is used to opt out of the Trade & Earn program.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgRewardsOptOut,\n  MsgBroadcasterWithPk,\n} from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj...'\n\nconst msg = MsgRewardsOptOut.fromJSON(\n { sender: injectiveAddress })\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/exchange\\#msgexternaltransfer)    MsgExternalTransfer\n\nThis message is used to transfer balance from one subaccount to another subaccount.\n\nNote:\n\n- You cannot transfer from your default subaccountId since that balance is now associated with your Injective address in the bank module. Therefore, in order for `MsgExternalTransfer` to work, you will need to transfer from a non-default subaccountId.\n\n\nHow to find the subaccountId that you will be transferring from:\n\n- you can query your existing subaccountIds via the [account portfolio api](https://docs.ts.injective.network/querying/querying-api/querying-indexer-portfolio).\n\n\nHow to use funds that are currently associated with your Injective Address in bank module:\n\n- If you have existing non-default subaccounts, you'll want to do a [MsgDeposit](https://docs.ts.injective.network/core-modules-and-examples/exchange#MsgDeposit) to one of your existing non-default subaccountIds and use that subaccountId as the `srcSubaccountId` below.\n\n- If you don't have existing non-default subaccounts, you can do a [MsgDeposit](https://docs.ts.injective.network/core-modules-and-examples/exchange#MsgDeposit) to a new default subaccountId, which would be done via importing `getSubaccountId` from `sdk-ts` and setting the `subaccountId` field in [MsgDeposit](https://docs.ts.injective.network/core-modules-and-examples/exchange#MsgDeposit) to `getSubaccountId(injectiveAddress, 1)`.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  DenomClient,\n  MsgExternalTransfer,\n  MsgBroadcasterWithPk,\n} from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst denomClient = new DenomClient(Network.Testnet)\n\nconst injectiveAddress = 'inj...'\nconst srcSubaccountId = '0x...'\nconst dstSubaccountId = `0x...`\nconst INJ_TOKEN_SYMBOL = 'INJ'\nconst tokenMeta = denomClient.getTokenMetaDataBySymbol(INJ_TOKEN_SYMBOL)\nconst tokenDenom = `inj`\n\n/* format amount to add to the burn auction pool */\nconst amount = {\n  denom: tokenDenom,\n  amount: new BigNumberInBase(1).toWei(tokenMeta.decimals).toFixed(),\n}\n\n/* create message in proto format */\nconst msg = MsgExternalTransfer.fromJSON({\n  amount,\n  dstSubaccountId,\n  srcSubaccountId,\n  injectiveAddress,\n})\n\nconst privateKey = '0x...'\n\n/* broadcast transaction */\nconst txHash = await new MsgBroadcasterWithPk({\n  network: Network.Testnet,\n  privateKey,\n}).broadcast({\n  msgs: msg\n})\n\nconsole.log(txHash)\n```\n\n[PreviousDistribution](https://docs.ts.injective.network/core-modules-and-examples/distribution) [NextFeegrant](https://docs.ts.injective.network/core-modules-and-examples/feegrant)\n\nLast updated 1 year ago\n\n<|firecrawl-page-74-lllmstxt|>\n## Feegrant Module Overview\nThe `feegrant` module allows accounts (granters) to grant fee allowances to other accounts (grantees). This allows the grantee to use the granter's funds to pay for transaction fees.\n\n## [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/feegrant\\#messages)    Messages\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/feegrant\\#msggrantallowance)    MsgGrantAllowance\n\nA fee allowance grant is created using the `MsgGrantAllowance` message. If there is already a grant for the (granter, grantee) pair, then the new grant will overwrite the previous one.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgGrantAllowance, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKeyOfGranter = '0x...'\n\nconst date = new Date('2023-10-02T00:00:00Z')\nconst expiration = date.getTime() / 1000\nconst granter = 'inj...'\nconst grantee = 'inj...'\nconst allowance = {\n  spendLimit: [\\\n    {\\\n      denom: 'inj',\\\n      amount: '10000',\\\n    },\\\n  ],\n  expiration\n}\n\nconst msg = MsgGrantAllowance.fromJSON({\n  granter,\n  grantee,\n  allowance,\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\nprivateKey: privateKeyOfGranter,\nnetwork: Network.Testnet,\n}).broadcast({\nmsgs: msg,\n})\n\nconsole.log(txHash)\n\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/feegrant\\#msgrevokeallowance)    MsgRevokeAllowance\n\nA grant can be removed using the MsgRevokeAllowance message. The grantee will no longer be able to use the granter's funds to pay for transaction fees.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgRevokeAllowance, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey= \"0x...\"\nconst granteeAddress = 'inj...'\nconst granterAddress = 'inj...'\n\nconst params = {\ngrantee: granteeAddress,\ngranter: granterAddress,\n}\n\nconst msg = MsgRevokeAllowance.fromJSON(params);\n\nconst txHash = await new MsgBroadcasterWithPk({\nprivateKey,\nnetwork: Network.Testnet,\n}).broadcast({\nmsgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n[PreviousExchange](https://docs.ts.injective.network/core-modules-and-examples/exchange) [NextGovernance](https://docs.ts.injective.network/core-modules-and-examples/governance)\n\nLast updated 1 year ago\n\n<|firecrawl-page-75-lllmstxt|>\n## Injective Governance\nInjective is a community-run blockchain and users who have staked INJ are able to participate in governance as it relates to the blockchain. Proposals can be submitted to make revisions to Injective programs, tech upgrades, or any other Injective related changes that impact the entire Injective ecosystem.\n\nFor every proposal you create, we require you to deposit at least 1 INJ. This is to ensure that you are an active participant of the Injective community and you are eligible to make proposals and govern the protocol moving forward. For the proposal to pass to the voting stage, it must have 500 INJ deposited. You can deposit the 500 INJ yourself or collaborate with the community to deposit them collectively.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/governance\\#messages)    Messages\n\nLet's explore (and provide examples) the messages that the Governance module exports and we can use to interact with the Injective chain. For example, you can use these messages to propose new spot, perpetual, or futures markets.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/governance\\#msggovdeposit)    MsgGovDeposit\n\nThis message can be used to deposit towards an existing proposal.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgGovDeposit\n  MsgBroadcasterWithPk,\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst INJ_DENOM = 'inj'\nconst amount = new BigNumberInBase(1).toWei().toFixed()\nconst proposalId = 12345\nconst injectiveAddress = \"inj...\";\nconst privateKey = \"0x...\";\n\nconst message = MsgGovDeposit.fromJSON({\n  amount: {\n    denom: INJ_DENOM,\n    amount\n  },\n  proposalId,\n  depositor: injectiveAddress\n})\n\n/* broadcast transaction */\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: message\n});\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/governance\\#msgvote)    MsgVote\n\nAfter the proposal is properly funded, voting can commence. You can vote \"Yes\", \"No\", \"Abstain\", or \"No with Veto\".\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgVote,\n  MsgBroadcasterWithPk\n} from \"@injectivelabs/sdk-ts\";\nimport { Network } from \"@injectivelabs/networks\";\nimport { VoteOption } from '@injectivelabs/sdk-ts';\n\nconst injectiveAddress = \"inj...\";\nconst privateKey = \"0x...\";\nconst proposalId = 12345\nconst vote =  VoteOption.VOTE_OPTION_YES\n\nconst message = MsgVote.fromJSON({\n  vote,\n  proposalId,\n  voter: injectiveAddress\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: message\n});\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/governance\\#msgsubmittextproposal)    MsgSubmitTextProposal\n\nPropose any action on Injective. TextProposal defines a standard text proposal whose changes need to be manually updated in case of approval.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgSubmitTextProposal,\n  MsgBroadcasterWithPk\n} from \"@injectivelabs/sdk-ts\";\nimport { Network } from \"@injectivelabs/networks\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\n\nconst injectiveAddress = \"inj...\";\nconst privateKey = \"0x...\";\nconst INJ_DENOM = 'inj'\nconst amount = new BigNumberInBase(1).toWei().toFixed()\n\nconst message = MsgSubmitTextProposal.fromJSON({\n  title: 'Title of Proposal',\n  description: 'Description of Proposal',\n  proposer: injectiveAddress,\n  deposit: {\n    denom: INJ_DENOM,\n    amount\n  }\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: message\n});\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/governance\\#msgsubmitproposalspotmarketlaunch)    MsgSubmitProposalSpotMarketLaunch\n\nThis message allows you to propose a new spot market. Ensure that the ticker is accurate and provide the base asset denom followed by the quote asset denom. Base denom refers to the asset you would like to trade and quote denom refers to the asset by which your base asset is denominated. For instance, in the INJ/USDT market you would buy or sell INJ using USDT.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  DenomClientAsync,\n  MsgBroadcasterWithPk,\n  MsgSubmitProposalSpotMarketLaunch\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase, BigNumberInWei } from \"@injectivelabs/utils\";\nimport { getNetworkEndpoints, Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj...\";\nconst privateKey = \"0x...\";\nconst INJ_DENOM = 'inj'\nconst amount = new BigNumberInBase(1).toWei().toFixed()\n\nconst market = {\n  baseDenom: 'inj', // for example\n  quoteDenom: \"peggy0x...\",\n  makerFeeRate: '0.001',\n  takerFeeRate: '0.002',\n  title: 'INJ/USDT Spot Market Launch',\n  description: 'This proposal will launch the INJ/USDT Spot Market with maker and taker fees 0.001% and 0.002% respectively',\n  ticker: 'INJ/USDT',\n  minPriceTickSize: '0.001',\n  minQuantityTickSize: '0.001'\n}\n\nconst denomClient = new DenomClientAsync\n(\n  NETWORK.Testnet,\n  { endpoints: getNetworkEndpoints(Network.Testnet) }\n)\n\nconst baseDenom = await denomClient.getDenomToken(market.baseDenom)\nconst quoteDenom = await denomClient.getDenomToken(market.quoteDenom)\nconst marketWithDecimals: SpotMarketLaunchProposal = {\n  ...market,\n  baseTokenDecimals: baseDenom ? baseDenom.decimals : 18,\n  quoteTokenDecimals: quoteDenom ? quoteDenom.decimals : 6\n}\n\nconst marketWithTickSizes = {\n  ...market,\n  minPriceTickSize: new BigNumberInWei(\n    marketWithDecimals.minPriceTickSize\n  )\n  .toBase(\n    marketWithDecimals.baseTokenDecimals -\n      marketWithDecimals.quoteTokenDecimals\n  )\n  .toFixed(),\n  minQuantityTickSize: new BigNumberInBase(\n    marketWithDecimals.minQuantityTickSize\n  )\n  .toWei(marketWithDecimals.baseTokenDecimals)\n  .toFixed()\n}\n\nconst message = MsgSubmitProposalSpotMarketLaunch.fromJSON({\n  market: marketWithTickSizes,\n  proposer: injectiveAddress,\n  deposit: {\n    denom: INJ_DENOM,\n    amount\n  }\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: message\n});\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/governance\\#msgsubmitproposalperpetualmarketlaunch)    MsgSubmitProposalPerpetualMarketLaunch\n\nThis message allows you to propose a new perpetual market. perpetual futures contracts, or perps, are derivative futures contracts that allow users to buy or sell the value of an underlying base asset without actually owning it. This is the message you can use to create a perp market for a specified token pair.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  DenomClientAsync,\n  MsgBroadcasterWithPk,\n  MsgSubmitProposalPerpetualMarketLaunch\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { getNetworkEndpoints, Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj...\";\nconst privateKey = \"0x...\";\nconst INJ_DENOM = 'inj'\nconst amount = new BigNumberInBase(1).toWei().toFixed()\n\nconst market = {\n  title: 'INJ/USDT Perpetual Market Launch',\n  description: 'This proposal will launch the INJ/USDT Spot Market with maker and taker fees 0.001% and 0.002% respectively',\n  ticker: 'INJ/USDT PERP',\n  quoteDenom: 'peggy0x...',\n  oracleBase: 'INJ',\n  oracleQuote: 'USDT',\n  oracleScaleFactor: 6,\n  oracleType: 10, // BAND IBC\n  initialMarginRatio: '0.05',\n  maintenanceMarginRatio: '0.02',\n  makerFeeRate: '0.01',\n  takerFeeRate: '0.02',\n  minPriceTickSize: '0.01',\n  minQuantityTickSize: '0.01'\n}\n\nconst denomClient = new DenomClientAsync(\n  NETWORK.Testnet,\n  { endpoints: getNetworkEndpoints(Network.Testnet) }\n)\n const quoteDenom = await denomClient.getDenomToken(market.quoteDenom)\n\nconst marketWithDecimals = {\n    ...market,\n    quoteTokenDecimals: quoteDenom ? quoteDenom.decimals : 6\n  }\n\nconst marketWithTickSizes = {\n  ...market,\n  minPriceTickSize: new BigNumberInBase(\n    marketWithDecimals.minPriceTickSize\n  )\n    .toWei(marketWithDecimals.quoteTokenDecimals)\n    .toFixed()\n}\n\nconst message = MsgSubmitProposalPerpetualMarketLaunch.fromJSON({\n  market: marketWithTickSizes,\n  proposer: injectiveAddress,\n  deposit: {\n    denom: INJ_DENOM,\n    amount\n  }\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: message\n});\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/governance\\#msgsubmitproposalexpiryfuturesmarketlaunch)    MsgSubmitProposalExpiryFuturesMarketLaunch\n\nAn expiry futures contract is an agreement between two counterparties to buy and sell a specific amount of an underlying base asset at a specific future price, which is set to expire at a specified date in the future. This is the message you can use to create a futures market for a specified token pair.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  DenomClientAsync,\n  MsgBroadcasterWithPk,\n  MsgSubmitProposalExpiryFuturesMarketLaunch\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { getNetworkEndpoints, Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj...\";\nconst privateKey = \"0x...\";\nconst INJ_DENOM = 'inj'\nconst amount = new BigNumberInBase(1).toWei().toFixed()\n\nconst market = {\n  title: 'INJ/USDT Futures Market Launch',\n  description: 'This proposal will launch the INJ/USDT Spot Market with maker and taker fees 0.001% and 0.002% respectively',\n  ticker: 'INJ/USDT 24-MAR-2023',\n  quoteDenom: 'peggy0x...',\n  oracleBase: 'INJ',\n  oracleQuote: 'USDT',\n  expiry: 1000000, // when the market will expire, in ms\n  oracleScaleFactor: 6,\n  oracleType: 10, // BAND IBC\n  initialMarginRatio: '0.05',\n  maintenanceMarginRatio: '0.02',\n  makerFeeRate: '0.01',\n  takerFeeRate: '0.02',\n  minPriceTickSize: '0.01',\n  minQuantityTickSize: '0.01'\n}\n\nconst denomClient = new DenomClientAsync(\n  NETWORK.Testnet,\n  { endpoints: getNetworkEndpoints(Network.Testnet) }\n)\n const quoteDenom = await denomClient.getDenomToken(market.quoteDenom)\n\nconst marketWithDecimals = {\n    ...market,\n    quoteTokenDecimals: quoteDenom ? quoteDenom.decimals : 6\n  }\n\nconst marketWithTickSizes = {\n  ...market,\n  minPriceTickSize: new BigNumberInBase(\n    marketWithDecimals.minPriceTickSize\n  )\n    .toWei(marketWithDecimals.quoteTokenDecimals)\n    .toFixed()\n}\n\nconst message = MsgSubmitProposalExpiryFuturesMarketLaunch.fromJSON({\n  market: marketWithTickSizes,\n  proposer: injectiveAddress,\n  deposit: {\n    denom: INJ_DENOM,\n    amount: deposit.toWei().toFixed()\n  }\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: message\n});\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/governance\\#msgsubmitproposalspotmarketparamupdate)    MsgSubmitProposalSpotMarketParamUpdate\n\nThis message can be used to update the params of a spot market.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgBroadcasterWithPk,\n  MsgSubmitProposalSpotMarketParamUpdate\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport {  Network } from \"@injectivelabs/networks\";\nimport { MarketStatusMap } from '@injectivelabs/chain-api';\n\nconst injectiveAddress = \"inj...\";\nconst privateKey = \"0x...\";\nconst INJ_DENOM = 'inj'\nconst amount = new BigNumberInBase(1).toWei().toFixed()\n\nconst market = {\n  title: 'INJ/USDT Spot Market Launch',\n  description: 'This proposal will launch the INJ/USDT Spot Market with maker and taker fees 0.001% and 0.002% respectively',\n  marketId: '0x...',\n  makerFeeRate: '0.02',\n  takerFeeRate: '0.03',\n  relayerFeeShareRate: '0.4', // 40%, the percent of tsx fees that go to the relayers\n  minPriceTickSize: '0.002',\n  minQuantityTickSize: '0.002',\n  status: MarketStatusMap.Active\n}\n\nconst message = MsgSubmitProposalSpotMarketParamUpdate.fromJSON({\n  market,\n  proposer: injectiveAddress,\n  deposit: {\n    denom: INJ_DENOM,\n    amount\n  }\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: message\n});\n```\n\n[PreviousFeegrant](https://docs.ts.injective.network/core-modules-and-examples/feegrant) [NextIBC](https://docs.ts.injective.network/core-modules-and-examples/ibc)\n\nLast updated 1 year ago\n\n<|firecrawl-page-76-lllmstxt|>\n## IBC Coin Transfer\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/ibc\\#msgtransfer)    MsgTransfer\n\nThis message is used to send coins from the sender's Bank module on Injective to the receiver's Bank module on another Cosmos chain through IBC, which is Cosmos's Inter-Blockchain Communication Protocol. Note that Injective only supports mainnet transfers across IBC for most networks.\n\nApplication to application communication in IBC is conducted over channels, which route between an application module on one chain, and the corresponding application module on another one. More info on IBC channels can be found at https://tutorials.cosmos.network/academy/3-ibc/3-channels.html. A list of canonical channel Ids for mainnet transfers to and from Injective can be found [here](https://github.com/InjectiveLabs/injective-ts/blob/master/deprecated/token-metadata/src/ibc/canonicalChannelsToChainMap.ts). Also noteworthy is that the application module on each chain has a portId to designate the type of module on each end. For example, `transfer` is the portId designating the transfer of ICS-20 tokens between bank modules.\n\nIn this example, we will transfer ATOM from Injective to CosmosHub\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  ChainGrpcBankApi,\n  ChainRestTendermintApi,\n  makeTimeoutTimestampInNs,\n  MsgBroadcasterWithPk,\n  MsgTransfer,\n} from '@injectivelabs/sdk-ts'\nimport {\n  TokenService,\n  UiBankTransformer,\n  cosmosChainTokenMetaMap,\n} from '@injectivelabs/sdk-ui-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { ChainId, CosmosChainId } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\nimport { IbcToken, Token } from '@injectivelabs/token-metadata'\n\nconst tokenService = new TokenService({\n  chainId: ChainId.Mainnet,\n  network: Network.Mainnet,\n})\n\nconst destinationChainId = CosmosChainId['Cosmoshub']\nconst injectiveChainId = CosmosChainId['Injective']\n\nconst endpointsForNetwork = getNetworkEndpoints(Network.Mainnet)\nconst bankService = new ChainGrpcBankApi(endpointsForNetwork.grpc)\n\n// fetch ibc assets in bank module and format to token\nconst { supply } = await bankService.fetchTotalSupply()\nconst uiSupply = UiBankTransformer.supplyToUiSupply(supply)\nconst ibcSupplyWithToken = (await tokenService.getIbcSupplyWithToken(\n  uiSupply.ibcBankSupply,\n)) as IbcToken[]\n\n/* get metadata for canonical denoms available for transfer between chains */\nconst cosmosHubBaseDenom = 'uatom'\nconst tokenMeta = cosmosChainTokenMetaMap[destinationChainId]\nconst atomToken = (\n  Array.isArray(tokenMeta)\n    ? tokenMeta.find((token) => token.denom === cosmosHubBaseDenom)\n    : tokenMeta\n) as Token\n\n/* find the ibd denom hash for the canonical denom */\nconst injectiveToCosmosHubChannelId = 'channel-1'\nconst atomDenomFromSupply = ibcSupplyWithToken.find(\n  ({ channelId, baseDenom }) =>\n    channelId === injectiveToCosmosHubChannelId &&\n    baseDenom === atomToken.denom,\n) as IbcToken\nconst canonicalDenomHash = atomDenomFromSupply.denom\n\n/* format amount for transfer */\nconst amount = {\n  denom: canonicalDenomHash,\n  amount: new BigNumberInBase(0.001)\n    .toWei(atomDenomFromSupply.decimals)\n    .toString(),\n}\n\nconst injectiveAddress = 'inj...'\nconst destinationAddress = 'cosmos...'\nconst port = 'transfer'\nconst timeoutTimestamp = makeTimeoutTimestampInNs()\n\n/* get the latestBlock from the origin chain */\nconst tendermintRestApi = new ChainRestTendermintApi(endpointsForNetwork.rest)\n\n/* Block details from the origin chain */\nconst latestBlock = await tendermintRestApi.fetchLatestBlock()\nconst latestHeight = latestBlock.header.height\nconst timeoutHeight = new BigNumberInBase(latestHeight).plus(\n  30, // default block timeout height\n)\n\n/* create message in proto format */\nconst msg = MsgTransfer.fromJSON({\n  port,\n  memo: `IBC transfer from ${injectiveChainId} to ${destinationChainId}`,\n  sender: injectiveAddress,\n  receiver: destinationAddress,\n  channelId: injectiveToCosmosHubChannelId,\n  timeout: timeoutTimestamp,\n  height: {\n    revisionHeight: timeoutHeight.toNumber(),\n    revisionNumber: parseInt(latestBlock.header.version.block, 10),\n  },\n  amount,\n})\n\nconst privateKey = '0x...'\n\n/* broadcast transaction */\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Mainnet,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n[PreviousGovernance](https://docs.ts.injective.network/core-modules-and-examples/governance) [NextInsurance](https://docs.ts.injective.network/core-modules-and-examples/insurance)\n\nLast updated 9 months ago\n\n<|firecrawl-page-77-lllmstxt|>\n## Injective Insurance Module\nThis module provides insurance funds for derivative markets in the exchange module of the Injective Chain to use in order to support higher leverage trading. On a high level, insurance funds for each derivative market are funded by a permissionless group of underwriters who each own a proportional claim (represented through insurance fund share tokens) over the underlying assets in the insurance fund.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/insurance\\#messages)    Messages\n\nLet's explore (and provide examples) the Messages that the Insurance module exports and we can use to interact with the Injective chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/insurance\\#msgcreateinsurancefund)    MsgCreateInsuranceFund\n\nThis Message is used to create an Insurance Fund\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgCreateInsuranceFund,\n  MsgBroadcasterWithPk,\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst privateKey = \"0x...\";\nconst amount = new BigNumberInBase(5);\nconst fund = {\n  ticker: \"BTC/USDT\",\n  quoteDenom: \"peggy0x...\",\n  oracleBase: \"BTC\",\n  oracleQuote: \"USDT\",\n  oracleType: 10, // BANDIBC\n};\n\nconst msg = MsgCreateInsuranceFund.fromJSON({\n  fund,\n  injectiveAddress,\n  deposit: {\n    denom: fund.quoteDenom,\n    amount: amount.toWei(6 /* 6 because USDT has 6 decimals */).toFixed(),\n  },\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/insurance\\#msgrequestredemption)    MsgRequestRedemption\n\nThis Message is used to request redemption.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgRequestRedemption,\n  MsgBroadcasterWithPk,\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst privateKey = \"0x...\";\nconst amount = new BigNumberInBase(5);\nconst denom = \"share1\"; // the insurance fund denom (share{id})\nconst marketId = \"0x....\";\n\nconst msg = MsgRequestRedemption.fromJSON({\n  marketId,\n  injectiveAddress,\n  amount: {\n    denom,\n    amount: amount.toWei().toFixed(),\n  },\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/insurance\\#msgunderwrite)    MsgUnderwrite\n\nThis Message is used to underwrite to an insurance fund.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgUnderwrite, MsgBroadcasterWithPk } from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst privateKey = \"0x...\";\nconst amount = new BigNumberInBase(5);\nconst denom = \"peggy0x...\";\nconst marketId = \"0x...\";\n\nconst msg = MsgUnderwrite.fromJSON({\n  marketId,\n  injectiveAddress,\n  amount: {\n    denom,\n    amount: amount.toWei(6 /* 6 because USDT has 6 decimals */).toFixed(),\n  },\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n```\n\n[PreviousIBC](https://docs.ts.injective.network/core-modules-and-examples/ibc) [NextPeggy](https://docs.ts.injective.network/core-modules-and-examples/peggy)\n\nLast updated 1 year ago\n\n<|firecrawl-page-78-lllmstxt|>\n## Injective Peggy Module\nThe `peggy` module is the heart of the injective <> ethereum bridge, where deposited funds will be locked on the ethereum [peggy contract](https://etherscan.io/address/0xF955C57f9EA9Dc8781965FEaE0b6A2acE2BAD6f3#code) and minted on the Injective chain. Similarly withdrawal funds will be burned on the injective chain and unlocked on the ethereum peggy contract.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/peggy\\#msgsendtoeth)    MsgSendToEth\n\nThis message is used to withdraw funds from the Injective Chain via the [peggy contract](https://etherscan.io/address/0xF955C57f9EA9Dc8781965FEaE0b6A2acE2BAD6f3#code), in the process funds will be burned on the injective chain and distributed to the ethereum address from the peggy contract.\n\nNote that a $10 USD bridge fee will be charged for this transaction to cover for the ethereum gas fee on top of the standard INJ transaction fee.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  TokenPrice,\n  MsgSendToEth,\n  DenomClientAsync,\n  MsgBroadcasterWithPk,\n} from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { ChainId } from '@injectivelabs/ts-types'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n// refer to https://docs.ts.injective.network/readme/assets/injective-list\nimport { tokens } from '../data/tokens.json'\n\nexport const tokenFactoryStatic = new TokenFactoryStatic(\n  tokens as TokenStatic[],\n)\n\nconst tokenPriceMap = new TokenPrice(Network.Mainnet)\nconst tokenService = new TokenService({\n  chainId: ChainId.Mainnet,\n  network: Network.Mainnet,\n})\n\nconst ETH_BRIDGE_FEE_IN_USD = 10\nconst endpointsForNetwork = getNetworkEndpoints(Network.Mainnet)\nconst denomClient = new DenomClientAsync(Network.Mainnet, {\n  endpoints: endpointsForNetwork,\n})\n\nconst tokenSymbol = 'INJ'\nconst tokenMeta = tokenFactoryStatic.toToken(tokenSymbol)\n\nconst amount = 1\nconst injectiveAddress = 'inj1...'\nconst destinationAddress = '0x...' // ethereum address\nconst tokenDenom = `peggy${tokenMeta.erc20.address}`\n\nif (!tokenMeta) {\n  return\n}\n\nconst tokenUsdPrice = tokenPriceMap[tokenMeta.coinGeckoId]\nconst amountToFixed = new BigNumberInBase(amount)\n  .toWei(tokenMeta.decimals)\n  .toFixed()\nconst bridgeFeeInToken = new BigNumberInBase(ETH_BRIDGE_FEE_IN_USD)\n  .dividedBy(tokenUsdPrice)\n  .toFixed()\n\nconst msg = MsgSendToEth.fromJSON({\n  injectiveAddress,\n  address: destinationAddress,\n  amount: {\n    denom: tokenDenom,\n    amount: amountToFixed,\n  },\n  bridgeFee: {\n    denom: tokenDenom,\n    amount: bridgeFeeInToken,\n  },\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Mainnet,\n}).broadcast({\n  msgs: msg,\n})\n```\n\n[PreviousInsurance](https://docs.ts.injective.network/core-modules-and-examples/insurance) [NextPermissions](https://docs.ts.injective.network/core-modules-and-examples/permissions)\n\nLast updated 9 months ago\n\n<|firecrawl-page-79-lllmstxt|>\n## Permissions Module Overview\nThe Permissions Module facilitates the management of namespaces, roles, and permissions within the Injective ecosystem. This documentation outlines the key message types and their usage for interacting with permissions-related data.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/permissions\\#messages)    Messages\n\nLet's explore (and provide examples) the Messages that the Permissions module exports and we can use to interact with the Injective chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/permissions\\#msgclaimvoucher)    `MsgClaimVoucher`\n\nThis message is used to claim a voucher tied to a specific address within a namespace.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgClaimVoucher,\n  MsgBroadcasterWithPk,\n} from \"@injectivelabs/sdk-ts\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst privateKey = \"0x...\";\nconst denom = \"inj\";\n\nconst msg = MsgClaimVoucher.fromJSON({\n  injectiveAddress,\n  denom,\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/permissions\\#msgcreatenamespace)    `MsgCreateNamespace`\n\nThis message is used to creates a new namespace with permissions and roles.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgCreateNamespace,\n  MsgBroadcasterWithPk,\n} from \"@injectivelabs/sdk-ts\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst secondAddress = \"inj2.....\";\nconst privateKey = \"0x...\";\nconst denom = \"inj\";\nconst wasmHook = \"inj3....\";\nconst mintsPausedValue = false;\nconst sendsPausedValue = false;\nconst burnsPausedValue = false;\nconst role1 = \"Everyone\";\nconst permissions1 = 1;\n\nconst msg = MsgCreateNamespace.fromJSON({\n  injectiveAddress,\n  namespace: {\n    denom,\n    wasmHook,\n    mintsPausedValue,\n    sendsPausedValue,\n    burnsPausedValue,\n    rolePermissions: {\n      role: role1,\n      permissions: permissions1,\n    },\n    addressRoles: {\n      address: injectiveAddress,\n      roles: [role1],\n    },\n  },\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/permissions\\#msgdeletenamespace)    `MsgDeleteNamespace`\n\nThis message is used to delete an existing namespace.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgDeleteNamespace,\n  MsgBroadcasterWithPk,\n} from \"@injectivelabs/sdk-ts\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst privateKey = \"0x...\";\nconst denom = \"inj\";\n\nconst msg = MsgDeleteNamespace.fromJSON({\n  injectiveAddress,\n  denom\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/permissions\\#msgrevokenamespaceroles)    `MsgRevokeNamespaceRoles`\n\nThis message is used to revoke roles from specified addresses in a namespace.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgRevokeNamespaceRoles,\n  MsgBroadcasterWithPk,\n} from \"@injectivelabs/sdk-ts\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst privateKey = \"0x...\";\nconst denom = \"inj\";\nconst roles = [\"role1\",\"role2\"];\n\nconst msg = MsgRevokeNamespaceRoles.fromJSON({\n  injectiveAddress,\n  denom,\n  addressRolesToRevoke: {\n    injectiveAddress,\n    roles: roles,\n  },\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/permissions\\#msgupdatenamespace)    `MsgUpdateNamespace`\n\nThis message is used to update namespace properties like mints, sends, and burns.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgUpdateNamespace,\n  MsgBroadcasterWithPk,\n} from \"@injectivelabs/sdk-ts\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\"\nconst privateKey = \"0x...\";\nconst denom = \"inj\";\nconst wasmHookValue = \"inj2...\";\nconst mintsPausedValue = false;\nconst sendsPausedValue = false;\nconst burnsPausedValue = true;\n\nconst msg = await new MsgUpdateNamespace.fromJSON({\n  injectiveAddress,\n  denom,\n  wasmHook: {\n    newValue: wasmHookValue\n  },\n  mintsPaused: {\n    newValue: mintsPausedValue;\n  },\n  sendsPaused: {\n    newValue: sendsPausedValue;\n  },\n  burnsPaused: {\n    newValue: burnsPausedValue;\n  },\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/permissions\\#msgupdatenamespaceroles)    `MsgUpdateNamespaceRoles`\n\nThis message is used to modify the roles and permissions for addresses in a namespace.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgUpdateNamespaceRoles,\n  MsgBroadcasterWithPk,\n} from \"@injectivelabs/sdk-ts\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst privateKey = \"0x...\";\nconst denom = \"inj\";\nconst role = \"role1\";\nconst permissions = 4;\n\nconst msg = MsgUpdateNamespaceRoles.fromJSON({\n  injectiveAddress,\n  denom,\n  rolePermissions: {\n    role,\n    permissions: permissions\n  },\n  addressRoles: {\n    injectiveAddress,\n    roles: [role],\n  },\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n\n```\n\n[PreviousPeggy](https://docs.ts.injective.network/core-modules-and-examples/peggy) [NextStaking](https://docs.ts.injective.network/core-modules-and-examples/staking)\n\nLast updated 6 months ago\n\n<|firecrawl-page-81-lllmstxt|>\n## Token Factory Module\n## [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/token-factory\\#token-factory)    Token Factory\n\nThis `tokenfactory` module allows any account to create a new token with the name `factory/{creator address}/{subdenom}`. Because tokens are namespaced by creator address, this allows token minting to be permissionless, due to not needing to resolve name collisions.\n\n_Note: If you want your denom to be visible on products like Helix, Hub, Explorer, etc, it's important to add token metadata information using the_ `MsgSetDenomMetadata` _message as explained below._\n\n_Note #2: It's recommended to change your admin to the zero address for safety and preventing supply manipulation._\n\n#### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/token-factory\\#messages)    Messages\n\nLet's explore (and provide examples) the Messages that the TokenFactory module exports and we can use to interact with the Injective chain.\n\n#### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/token-factory\\#msgcreatedenom)    MsgCreateDenom\n\nCreates a denom of `factory/{creator address}/{subdenom}` given the denom creator address and the subdenom. Subdenoms can contain \\[a-zA-Z0-9./\\]. Keep in mind that there is a `creation fee` which you need to cover when creating a new token.\n\nKeep in mind that that the `admin` of the token can change the supply (mint or burn new tokens). Its recommended that the `admin` is unset using the `MsgChangeAdmin`, as explained below.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgCreateDenom } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst injectiveAddress = 'inj1...'\nconst privateKey = '0x...'\nconst subdenom = 'inj-test'\n\nconst msg = MsgCreateDenom.fromJSON({\n  subdenom,\n  symbol: 'InjTest',\n  name: 'Inj Testing',\n  sender: injectiveAddress,\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/token-factory\\#msgmint)    MsgMint\n\nMinting of a specific denom is only allowed for the current admin. Note, the current admin is defaulted to the creator of the denom.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgMint } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst injectiveAddress = 'inj1...'\nconst privateKey = '0x...'\nconst subdenom = 'inj-test'\nconst amountToMint = 1_000_000_000\n\nconst msg = MsgMint.fromJSON({\n  sender: injectiveAddress,\n  amount: {\n    denom: `factory/${injectiveAddress}/${subdenom}`,\n    amount: amountToMint,\n  },\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/token-factory\\#msgburn)    MsgBurn\n\nThe admin can burn the supply of the token factory. Everyone else can use this message to burn their funds only.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgBurn } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst injectiveAddress = 'inj1...'\nconst privateKey = '0x...'\nconst subdenom = 'inj-test'\nconst amountToBurn = 1_000_000_000\n\nconst msg = MsgBurn.fromJSON({\n  sender: injectiveAddress,\n  amount: {\n    denom: `factory/${injectiveAddress}/${subdenom}`,\n    amount: amountToBurn,\n  },\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/token-factory\\#msgsetdenommetadata)    MsgSetDenomMetadata\n\nSetting of metadata for a specific denom is only allowed for the admin of the denom. It allows the overwriting of the denom metadata in the bank module.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgSetDenomMetadata,\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst privateKey = \"0x...\";\nconst subdenom = 'inj-test'\nconst denom = `factory/${injectiveAddress}/${subdenom}`;\n\nconst denomUnitsIfTokenHas0Decimals = [\\\n  {\\\n    denom: denom,\\\n    exponent: 0,\\\n    aliases: [subdenom]\\\n  },\\\n]\nconst denomUnitsIfTokenHas6Decimals = [\\\n  {\\\n    denom: denom, /** we use the whole denom here */\\\n    exponent: 0,\\\n    aliases: [subdenom]\\\n  },\\\n  {\\\n    denom: subdenom,\\\n    exponent: 6, /** we use the subdenom only here (if you want your token to have 6 decimals) */\\\n    aliases: []\\\n  },\\\n]\n\nconst msg = MsgSetDenomMetadata.fromJSON({\n  sender: injectiveAddress,\n  metadata: {\n    base: denom, /** the base denom */\n    description: '', /** description of your token */\n    display: subdenom, /** the display alias of your token on UIs (it's the denom of the unit with highest decimals) */\n    name: '', /** the name of your token */\n    symbol: '', /** the symbol of your token */\n    uri: '' /** the logo of your token, should be hosted on IPFS and should be a small webp image */\n    denomUnits: denomUnitsIfTokenHas6Decimals  /** choose if you want to have 6 or 0 decimals for the token */,\n    decimals: 6 /** choose if you want to have 6 or 0 decimals for the token */\n  }\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: msg\n});\n\nconsole.log(txHash);\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/token-factory\\#msgchangeadmin)    MsgChangeAdmin\n\nThe admin of the denom can mint new supply or burn existing one. It's recommended to change the admin to the zero address as to not allow changing the token's supply.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgChangeAdmin } from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst injectiveAddress = 'inj1...'\nconst privateKey = '0x...'\nconst subdenom = 'inj-test'\nconst denom = `factory/${injectiveAddress}/${subdenom}`\n\nconst msg = MsgChangeAdmin.fromJSON({\n  denom,\n  sender: injectiveAddress,\n  newAdmin:\n    'inj1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqe2hm49' /** SET TO ZERO ADDRESS */,\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n#### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/token-factory\\#full-example)    Full Example\n\nHere is a full example on how to create a new token, mint new tokens and set token metadata on Injective.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgSetDenomMetadata,\n} from \"@injectivelabs/sdk-ts\";\nimport { BigNumberInBase } from \"@injectivelabs/utils\";\nimport { Network } from \"@injectivelabs/networks\";\n\nconst injectiveAddress = \"inj1...\";\nconst privateKey = \"0x...\";\nconst subdenom = 'inj-test'\nconst denom = `factory/${injectiveAddress}/${subdenom}`;\nconst amount = 1_000_000_000\n\nconst msgCreateDenom = MsgCreateDenom.fromJSON({\n  subdenom,\n  sender: injectiveAddress,\n});\nconst msgMint = MsgMint.fromJSON({\n  sender: injectiveAddress,\n  amount: {\n    denom: `factory/${injectiveAddress}/${subdenom}`,\n    amount: amount\n  }\n});\nconst msgChangeAdmin = MsgChangeAdmin.fromJSON({\n  denom: `factory/${injectiveAddress}/${subdenom}`,\n  sender: injectiveAddress,\n  newAdmin: 'inj1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqe2hm49' /** SET TO ZERO ADDRESS */\n});\nconst msgSetDenomMetadata = MsgSetDenomMetadata.fromJSON({\n  sender: injectiveAddress,\n  metadata: {\n    base: denom, /** the base denom */\n    description: '', /** description of your token */\n    display: '', /** the displayed name of your token on UIs */,\n    name: '', /** the name of your token */,\n    symbol: '' /** the symbol of your token */,\n    uri: '' /** the logo of your token, should be hosted on IPFS and should be a small webp image */\n    denomUnits: [\\\n      {\\\n        denom: denom,\\\n        exponent: 0,\\\n        aliases: [subdenom]\\\n      },\\\n      {\\\n        denom: subdenom,\\\n        exponent: 6, /** if you want your token to have 6 decimals */\\\n        aliases: []\\\n      },\\\n    ]\n  }\n});\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Testnet\n}).broadcast({\n  msgs: [msgCreateDenom, msgMint, msgSetDenomMetadata, msgChangeAdmin]\n});\n\nconsole.log(txHash);\n```\n\n[PreviousStaking](https://docs.ts.injective.network/core-modules-and-examples/staking) [NextWasm](https://docs.ts.injective.network/core-modules-and-examples/wasm)\n\nLast updated 2 months ago\n\n<|firecrawl-page-82-lllmstxt|>\n## Injective WASM Module\nThe `wasm` module is the heart of interacting with the wasm smart contracts deployed on the injective chain, here you can find a list of [smart contracts](https://explorer.injective.network/contracts/) that are deployed on the Injective chain.\n\n`MsgUpdateCode` and `MsgStoreCode` are not supported by Ethereum (ex: Metamask) wallets.\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/wasm\\#msgexecutecontract-transfer)    MsgExecuteContract (Transfer)\n\nThis message is used to execute contract function, below we will use the [CW20 spec](https://github.com/CosmWasm/cw-plus/blob/main/packages/cw20/README.md) transfer message as an example.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgExecuteContract, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst injectiveAddress = 'inj1...'\nconst recipientAddress = 'inj2...'\nconst contractAddress = 'cw...'\n\nconst msg = MsgExecuteContract.fromJSON({\n  contractAddress,\n  sender: injectiveAddress,\n  exec: {\n    action: 'transfer',\n    msg: {\n      recipient: recipientAddress,\n      amount: 100000,\n    },\n  },\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Mainnet,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/wasm\\#msgexecutecontract-funds-example)    MsgExecuteContract (funds example)\n\nIn some scenarios, depending on the smart contract's function we have to transfer tokens to the smart contract, following cosmwasm convention, we use the funds field to transfer tokens to the smart contract from the user's bank module.\n\nBelow is an example of how we can send the `MsgExecuteContract` using an `test` contract function.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgExecuteContract, MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { INJ_DENOM } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst injectiveAddress = 'inj1...'\nconst contractAddress = 'cw...'\n\nconst msg = MsgExecuteContract.fromJSON({\n  contractAddress,\n  sender: injectiveAddress,\n  exec: {\n    action: 'test',\n    funds: [\\\n      {\\\n        denom: 'inj',\\\n        amount: new BigNumberInBase(1).toWei().toFixed(),\\\n      },\\\n    ],\n  },\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Mainnet,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/core-modules-and-examples/wasm\\#msgexecutecontractcompat)    MsgExecuteContractCompat\n\nThere are some compatibility issues parsing the `funds` array and `msgs` object in the previous example with EIP712. Since `MsgExecuteContract` can't be properly converted to EIP712 and then signed by Ethereum wallets, we introduced `MsgExecuteContractCompat` which is fully compatible with EIP712.\n\n_**Note:**_ `MsgExecuteContract` _and_ `MsgExecuteContractCompat` _underlying messages are the same._ `MsgExecuteContractCompat` _is just EIP712 compatible._\n\nBelow is an example of how we can send the `MsgExecuteContractCompact` using an `test` contract function.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgBroadcasterWithPk,\n  MsgExecuteContractCompat,\n} from '@injectivelabs/sdk-ts'\nimport { INJ_DENOM } from '@injectivelabs/utils'\nimport { Network } from '@injectivelabs/networks'\n\nconst injectiveAddress = 'inj1...'\nconst contractAddress = 'cw...'\n\nconst msg = MsgExecuteContractCompat.fromJSON({\n  contractAddress,\n  sender: injectiveAddress,\n  exec: {\n    action: 'test',\n    funds: [\\\n      {\\\n        denom: INJ_DENOM,\\\n        amount: new BigNumberInBase(1).toWei().toFixed(),\\\n      },\\\n    ],\n  },\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.Mainnet,\n}).broadcast({\n  msgs: msg,\n})\n\nconsole.log(txHash)\n```\n\n[PreviousTokenfactory](https://docs.ts.injective.network/core-modules-and-examples/token-factory) [NextCosmwasm](https://docs.ts.injective.network/smart-contracts/contracts)\n\nLast updated 3 months ago\n\n<|firecrawl-page-83-lllmstxt|>\n## CosmWasm Smart Contracts\n#### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts\\#what-is-cosmwasm)    What is CosmWasm?\n\nCosmWasm is a novel smart contracting platform built for the Cosmos ecosystem. You can learn more about CosmWasm [here](https://docs.cosmwasm.com/docs/), or see the [CosmWasm Book](https://book.cosmwasm.com/index.html) for a guide on creating CosmWasm smart contracts.\n\n#### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts\\#specific-cosmwasm-contracts)    Specific Cosmwasm Contracts\n\nTopic\n\nDescription\n\n[Injective Name Service](https://docs.ts.injective.network/smart-contracts/contracts/injective-name-service)\n\nInjective Name Service\n\n[Neptune Service](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service)\n\nNeptune Service\n\n[CW20 to Bank & Market Order in One Transaction](https://docs.ts.injective.network/smart-contracts/contracts/cw20-convert-and-market-order-example)\n\nConvert Cw20 Example\n\n[PreviousWasm](https://docs.ts.injective.network/core-modules-and-examples/wasm) [NextInjective Name Service](https://docs.ts.injective.network/smart-contracts/contracts/injective-name-service)\n\nLast updated 3 months ago\n\n<|firecrawl-page-84-lllmstxt|>\n## Injective Name Service\nWithin this section, we will look at how to query the Injective name service contracts.\n\n## [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/injective-name-service\\#abstraction-service-deprecated)    Abstraction Service (deprecated)\n\n~~You can use our~~ `InjNameService` ~~~~ [~~abstraction~~](https://github.com/InjectiveLabs/injective-ts/blob/dev/deprecated/sdk-ui-ts/src/service/injNameService.ts) ~~to query the smart contracts with a single method call. Below this example, you can also find the raw implementation on how to query the smart contracts in case you need more flexibility.~~\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { getNetworkEndpoints, Network } from '@injectivelabs/network'\nimport { InjNameService } from '@injectivelabs/sdk-ui-ts'\n\nconst injNameService = new InjNameService(Network.Testnet)\nconst name = 'ninja.inj'\n\n// Fetch the address for the particular name\nconst addressForName = await injNameService.fetchInjAddress(name)\n\n// Fetch the name for the particular address\nconst nameFromAddress = await injNameService.fetchInjName(addressForName)\n```\n\n## [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/injective-name-service\\#raw-smart-contract-querying)    Raw Smart Contract Querying\n\nExample code snippets to resolve .inj domain name.\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/injective-name-service\\#domain-resolution)    Domain Resolution\n\n- Get resolver address\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  Network,\n  getNetworkEndpoints,\n  getInjNameRegistryContractForNetwork,\n} from '@injectivelabs/networks'\nimport {\n  ChainGrpcWasmApi,\n  QueryResolverAddress,\n  InjNameServiceQueryTransformer,\n} from '@injectivelabs/sdk-ts'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst registryContractAddress = getInjNameRegistryContractForNetwork(\n  Network.Testnet,\n)\n\nconst node = ''\n\nconst query = new QueryResolverAddress({ node }).toPayload()\n\nconst response = await chainGrpcWasmApi.fetchSmartContractState(\n  registryContractAddress,\n  query,\n)\n\nconst resolverAddress =\n  InjNameServiceQueryTransformer.resolverAddressResponseToResolverAddress(\n    response,\n  )\n\nconsole.log(resolverAddress)\n```\n\n- Get address for .inj domain name.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  Network,\n  getNetworkEndpoints,\n  getInjNameReverseResolverContractForNetwork,\n} from '@injectivelabs/networks'\nimport {\n  ChainGrpcWasmApi,\n  QueryInjectiveAddress,\n  InjNameServiceQueryTransformer,\n} from '@injectivelabs/sdk-ts'\nimport { nameToNode, normalizeName } from '@injectivelabs/sdk-ts'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst reverseResolverContractAddress =\n  getInjNameReverseResolverContractForNetwork(Network.Testnet)\n\nconst name = 'allen.inj'\n\nconst normalizedName = normalizeName(name)\nconst node = nameToNode(normalizedName)\n\nconst query = new QueryInjectiveAddress({ node }).toPayload()\n\nconst response = await chainGrpcWasmApi.fetchSmartContractState(\n  reverseResolverContractAddress,\n  query,\n)\n\nconst injectiveAddress =\n  InjNameServiceQueryTransformer.injectiveAddressResponseToInjectiveAddress(\n    response,\n  )\n\nif (!injectiveAddress) {\n  throw new Error(`address not found for ${name}`)\n}\n\nconsole.log(injectiveAddress)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/injective-name-service\\#reverse-resolution)    Reverse Resolution\n\n- Get the primary name for injective address.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  QueryInjName,\n  ChainGrpcWasmApi,\n  InjNameServiceQueryTransformer\n} from '@injectivelabs/sdk-ts'\n  import {\n  Network,\n  getNetworkEndpoints,\n  getInjNameReverseResolverContractForNetwork\n} from '@injectivelabs/networks'\n\nconst endpoints = getNetworkEndpoints(Network.Testnet)\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(endpoints.grpc)\n\nconst reverseResolverContractAddress =\n  getInjNameReverseResolverContractForNetwork(Network.Testnet)\nconst injectiveAddress = ''\n\nconst query = new QueryInjName({ address: injectiveAddress }).toPayload()\n\nconst response = await chainGrpcWasmApi.fetchSmartContractState(\n  reverseResolverContractAddress,\n  query,\n)\n\nconst name = InjNameServiceQueryTransformer.injectiveNameResponseToInjectiveName(response)\n\nif (!name) {\n  throw new Error(`.inj not found for ${injectiveAddress}`)\n}\n\nconst addressForName = /** fetch as above example */\n\nif (addressForName.toLowerCase() !== address.toLowerCase()) {\n  throw new Error(`.inj not found for ${injectiveAddress}`)\n}\n\nconsole.log(name)\n```\n\n[PreviousCosmwasm](https://docs.ts.injective.network/smart-contracts/contracts) [NextNeptune Service](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service)\n\nLast updated 9 months ago\n\n<|firecrawl-page-85-lllmstxt|>\n## Neptune Service Tool\n`NeptuneService` is a straightforward tool that interacts with the Neptune CosmWasm smart contracts on Injective. It allows you to fetch asset prices, calculate exchange ratios, create deposit and withdraw messages, and retrieve lending rates.\n\n## [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#example-code-snippets)    Example Code Snippets\n\nBelow are examples of how to use each method in the `NeptuneService` class.\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#initialize-neptuneservice)    Initialize NeptuneService\n\nBefore using the service, create an instance of `NeptuneService`.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { NeptuneService } from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\n// Create a NeptuneService instance using the mainnet\nconst neptuneService = new NeptuneService(Network.MainnetSentry)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#fetch-prices)    Fetch Prices\n\n- Get the prices of specific assets from the Neptune Price Oracle contract. Use native\\_token for bank denoms and token with contract\\_addr for CW20 tokens.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst assets = [\\\n  {\\\n    native_token: {\\\n      denom: 'peggy0xdAC17F958D2ee523a2206206994597C13D831ec7', // peggy USDT bank denom\\\n    },\\\n  },\\\n  {\\\n    token: {\\\n      contract_addr: 'inj1cy9hes20vww2yr6crvs75gxy5hpycya2hmjg9s', // nUSDT contract address\\\n    },\\\n  },\\\n]\n\nconst prices = await neptuneService.fetchPrices(assets)\n\nconsole.log(prices)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#fetch-redemption-ratio)    Fetch Redemption Ratio\n\n- Calculate the redemption ratio between nUSDT (CW20 token) and USDT (bank token).\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst cw20Asset = {\n  token: {\n    contract_addr: 'inj1cy9hes20vww2yr6crvs75gxy5hpycya2hmjg9s', // nUSDT\n  },\n}\n\nconst nativeAsset = {\n  native_token: {\n    denom: 'peggy0xdAC17F958D2ee523a2206206994597C13D831ec7', // USDT\n  },\n}\n\nconst redemptionRatio = await neptuneService.fetchRedemptionRatio({\n  cw20Asset,\n  nativeAsset,\n})\n\nconsole.log(`Redemption Ratio: ${redemptionRatio}`)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#convert-cw20-nusdt-to-bank-usdt)    Convert CW20 nUSDT to Bank USDT\n\n- Calculate the amount in bank USDT from a given amount of CW20 nUSDT using the redemption ratio.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst amountCW20 = 1000 // Amount in nUSDT\nconst redemptionRatio = 0.95 // Obtained from fetchRedemptionRatio\n\nconst bankAmount = neptuneService.calculateBankAmount(\n  amountCW20,\n  redemptionRatio,\n)\n\nconsole.log(`Bank USDT Amount: ${bankAmount}`)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#convert-bank-usdt-to-cw20-nusdt)    Convert Bank USDT to CW20 nUSDT\n\n- Calculate the amount in CW20 nUSDT from a given amount of bank USDT using the redemption ratio.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst amountBank = 950 // Amount in USDT\nconst redemptionRatio = 0.95 // Obtained from fetchRedemptionRatio\n\nconst cw20Amount = neptuneService.calculateCw20Amount(\n  amountBank,\n  redemptionRatio,\n)\n\nconsole.log(`CW20 nUSDT Amount: ${cw20Amount}`)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#fetch-lending-rates)    Fetch Lending Rates\n\n- Retrieve lending rates for the different lending markets in neptune's lending market smart contract\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst lendingRates = await neptuneService.getLendingRates({\n  limit: 10, // Optional: number of rates to fetch\n})\n\nconsole.log(lendingRates)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#fetch-lending-rate-by-denomination)    Fetch Lending Rate by Denomination\n\n- Get the lending rate for USDT for example\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst denom = 'peggy0xdAC17F958D2ee523a2206206994597C13D831ec7' // USDT denom\n\nconst lendingRate = await neptuneService.getLendingRateByDenom({ denom })\n\nif (lendingRate) {\n  console.log(`Lending Rate for USDT: ${lendingRate}`)\n} else {\n  console.log('Lending Rate for USDT not found')\n}\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#calculate-annual-percentage-yield-apy)    Calculate Annual Percentage Yield (APY)\n\n- Convert the annual percentage rate (APR) to the continuously compounded annual percentage yield (APY). Make sure to use the lending rate retried from neptuneService.getLendingRateByDenom to use as the apr.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst apr = 0.1 // 10% APR\n\nconst apy = neptuneService.calculateAPY(apr)\n\nconsole.log(`APY (continuously compounded): ${(apy * 100).toFixed(2)}%`)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#create-and-broadcast-a-deposit-message)    Create and Broadcast a Deposit Message\n\n- Create a message to deposit USDT into the Neptune USDT lending market and broadcast it to the network.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  MsgBroadcasterWithPk,\n  MsgExecuteContractCompat,\n} from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\nconst denom = 'peggy0xdAC17F958D2ee523a2206206994597C13D831ec7' // USDT denom\n\nconst amountInUsdt = '100'\n\n// Convert the amount to the smallest unit (USDT has 6 decimals)\nconst amount = new BigNumberInBase(amountInUsdt).toWei(6).toFixed()\n\nconst depositMsg = neptuneService.createDepositMsg({\n  denom,\n  amount,\n  sender: injectiveAddress,\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.MainnetSentry,\n}).broadcast({\n  msgs: depositMsg,\n})\n\nconsole.log(txHash)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service\\#create-and-broadcast-a-withdraw-message)    Create and Broadcast a Withdraw Message\n\n- Create a message to withdraw USDT from the Neptune USDT lending market and broadcast it to the network\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport {\n  Network,\n  MsgBroadcasterWithPk,\n  MsgExecuteContractCompat,\n} from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\n\nconst privateKey = '0x...' // Your private key\nconst injectiveAddress = 'inj1...' // Your Injective address\n\n// Define the amount to withdraw (e.g., 100 nUSDT)\nconst amountInNusdt = '100'\n\n// Convert the amount to the smallest unit (nUSDT has 6 decimals)\nconst amount = new BigNumberInBase(amountInNusdt).toWei(6).toFixed()\n\nconst withdrawMsg = neptuneService.createWithdrawMsg({\n  amount,\n  sender: injectiveAddress,\n})\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.MainnetSentry,\n}).broadcast({\n  msgs: withdrawMsg,\n})\n\nconsole.log(`Transaction Hash: ${txHash}`)\n```\n\n[PreviousInjective Name Service](https://docs.ts.injective.network/smart-contracts/contracts/injective-name-service) [NextCW20 to Bank & Market Order in One Transaction](https://docs.ts.injective.network/smart-contracts/contracts/cw20-convert-and-market-order-example)\n\nLast updated 3 months ago\n\n<|firecrawl-page-86-lllmstxt|>\n## CW20 to Bank Token Conversion\nThis example helps you create messages to convert CW20 tokens to bank tokens on the Injective blockchain. This is particularly useful when you have CW20 tokens and need to convert them to their bank equivalents to perform operations like placing market orders. Note that this flow only works for cw20 tokens and their corresponding [factory tokens](https://docs.ts.injective.network/getting-started/application-concepts).\n\nThis guide will walk you through:\n\n- Obtaining the user's CW20 token balance.\n\n- Creating a message to convert CW20 tokens to bank tokens using ConvertCw20ToBankService\n\n- Executing a market order using the converted bank balance and existing bank balance\n\n\n## [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/cw20-convert-and-market-order-example\\#get-users-cw20-balance)    Get User's CW20 Balance\n\n[Detailed here](https://docs.ts.injective.network/querying/querying-api/querying-indexer-explorer#fetch-cw20-balances)\n\n- Find the cw20 address and balance from the result set that you want to convert to a bank factory token\n\n\n## [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/cw20-convert-and-market-order-example\\#create-cw20-to-bank-conversion-message)    Create CW20 to Bank Conversion Message\n\n- create the `convertMsg` using the steps detailed [here](https://github.com/InjectiveLabs/injective-ts/blob/dev/.gitbook/readme/application-concepts/README.md#example-on-how-to-convert-cw20-to-a-factory-denom) in order to convert your cw20 token to a bank factory token. No need to submit the tsx yet.\n\n\n## [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/cw20-convert-and-market-order-example\\#create-a-msgcreatespotmarketorder-message)    Create a `MsgCreateSpotMarketOrder` message\n\n- Create the `msg` using the steps detailed in [MsgCreateSpotMarketOrder](https://docs.ts.injective.network/core-modules-and-examples/exchange#msgcreatespotmarketorder). No need to submit the tsx yet.\n\n- Note that the buy order you create will have access to your converted cw20 balance + existing bank balance. Example:\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst order = {\n  price: 1,\n  quantity: 10,\n}\n```\n\n- If you had 5 Cw20 tokens and 5 bank tokens at a price of $1 each, then the order above will go through because we will convert the cw20 to bank before the chain executes this market order. This will be more clear in the next step.\n\n\n## [Direct link to heading](https://docs.ts.injective.network/smart-contracts/contracts/cw20-convert-and-market-order-example\\#place-a-market-order-using-converted-cw20-balance-and-your-existing-bank-balance)    Place a Market Order Using Converted CW20 Balance and your existing bank balance\n\nNow that you have both messages formatted, you can convert your cw20 tokens to bank factory tokens and then place a market order using the combined balance, all in one transaction\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { MsgBroadcasterWithPk } from '@injectivelabs/sdk-ts'\nimport { Network } from '@injectivelabs/networks'\n\nconst privateKey = '0x...'\nconst injectiveAddress = 'inj1...'\n\nconst txHash = await new MsgBroadcasterWithPk({\n  privateKey,\n  network: Network.MainnetSentry,\n}).broadcast({\n  msgs: [convertMsg, msg], // the convert to bank message executes first, Then, you will have that additional balance to complete your market order in the following msg\n})\n\nconsole.log(txHash)\n```\n\n[PreviousNeptune Service](https://docs.ts.injective.network/smart-contracts/contracts/neptune-service) [NextGetting Started](https://docs.ts.injective.network/bridges/bridge)\n\nLast updated 3 months ago\n\n<|firecrawl-page-87-lllmstxt|>\n## Injective Cross-Chain Bridges\nInjective is a blockchain built specifically to support financial applications. A key strength of Injective is its ability to perform seamless cross-chain transactions with the majority of popular blockchains.\n\n### [Direct link to heading](https://docs.ts.injective.network/bridges/bridge\\#bridges-supported)    Bridges Supported\n\nTopic\n\nDescription\n\n[Peggy (Ethereum Bridge)](https://docs.ts.injective.network/bridges/ethereum)\n\nBridging to/from Injective <-> Ethereum\n\n[IBC Bridge](https://docs.ts.injective.network/bridges/ibc)\n\nBridging to/from Injective using IBC\n\n[Wormhole Bridge](https://docs.ts.injective.network/bridges/wormhole)\n\nBridging to/from Injective using Wormhole\n\n[PreviousCW20 to Bank & Market Order in One Transaction](https://docs.ts.injective.network/smart-contracts/contracts/cw20-convert-and-market-order-example) [NextEthereum](https://docs.ts.injective.network/bridges/ethereum)\n\nLast updated 1 month ago\n\n<|firecrawl-page-88-lllmstxt|>\n## Injective Ethereum Bridge\nThe Injective Ethereum bridge enables the Injective Chain to support a trustless, on-chain bidirectional token bridge. In this system, holders of ERC-20 tokens on Ethereum can instantaneously convert their ERC-20 tokens to Cosmos-native coins on the Injective Chain and vice-versa.\n\nThe Injective Peggy bridge consists of three main components:\n\n1. Peggy Contract on Ethereum\n\n2. Peggo Orchestrator\n\n3. Peggy Module on the Injective Chain\n\n\n### [Direct link to heading](https://docs.ts.injective.network/bridges/ethereum\\#peggy-contract)    Peggy Contract\n\nThe function of the Peggy contract is to facilitate efficient, bidirectional cross-chain transfers of ERC-20 tokens from Ethereum to the Injective Chain. Unlike other token bridge setups, the Injective Peggy bridge is a decentralized, non-custodial bridge operated solely by the validators on Injective. The bridge is secured by the proof of stake security of the Injective Chain, as deposits and withdrawals are processed in accordance with attestations made by at least two-thirds of the validators based on consensus staking power.\n\n### [Direct link to heading](https://docs.ts.injective.network/bridges/ethereum\\#peggo-orchestrator)    Peggo Orchestrator\n\nThe orchestrator is an off-chain relayer that every Injective Chain validator operates which serves the function of transmitting ERC-20 token transfer data from Ethereum to the Injective Chain.\n\n### [Direct link to heading](https://docs.ts.injective.network/bridges/ethereum\\#peggy-module)    Peggy Module\n\nOn a basic level, the Peggy module mints new tokens on the Injective Chain upon an ERC-20 deposit from Ethereum and burns tokens upon withdrawing a token from the Injective Chain back to Ethereum. The Peggy module also manages the economic incentives to ensure that validators act honestly and efficiently, through a variety of mechanisms including slashing penalties, native token rewards, and withdrawal fees.\n\n### [Direct link to heading](https://docs.ts.injective.network/bridges/ethereum\\#from-ethereum-to-injective)    From Ethereum to Injective\n\nTo transfer from Ethereum to Injective you have to make a Web3 Transaction and interact with the Peggy contract on Ethereum. There are two steps required to make a transfer:\n\n1. As we are basically locking our ERC20 assets on the Peggy Contract which lives on Ethereum, we need to set an allowance for the assets we are transferring to the Peggy Contract. We have an [example](https://github.com/InjectiveLabs/injective-ts/blob/1fbc2577b9278a62d1676041d6e502e12f5880a8/deprecated/sdk-ui-ts/src/services/web3/Web3Composer.ts#L41-L91) here about how to make this transaction and you can use any web3 provider to sign and broadcast the transaction to the Ethereum Network.\n\n2. After the allowance is set, we need to call the `sendToInjective` function on the Peggy Contract with the desired amount and asset that we want to transfer to the Injective Chain, an example can be found [here](https://github.com/InjectiveLabs/injective-ts/blob/1fbc2577b9278a62d1676041d6e502e12f5880a8/deprecated/sdk-ui-ts/src/services/web3/Web3Composer.ts#L93-L156). Once we get the transaction, we can use a web3 provider to sign and broadcast the transaction to the Ethereum Network. Once the transaction is confirmed, itll take a couple of minutes for the assets to show on the Injective Chain.\n\n\nCouple of notes about the examples above:\n\n- The destination address (if you want to build the transaction yourself) is in the following format\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n'0x000000000000000000000000{ETHEREUM_ADDRESS_HERE_WITHOUT_0X_PREFIX}'\n// example\n'0x000000000000000000000000e28b3b32b6c345a34ff64674606124dd5aceca30'\n```\n\nwhere the Ethereum address is the corresponding Ethereum address of the destination Injective address.\n\n- `const web3 = walletStrategy.getWeb3()` `walletStrategy` is an abstraction that weve built which supports a lot of wallets which can be used to sign and broadcast transactions (both on Ethereum and on the Injective Chain), more details can be found in the documentation of the npm package [@injectivelabs/wallet-ts](https://github.com/InjectiveLabs/injective-ts/blob/master/packages/wallet-ts). Obviously, this is just an example and you can use the web3 package directly, or any web3 provider to handle the transaction.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { PeggyContract } from '@injectivelabs/contracts'\n\nconst contract = new PeggyContract({\n  ethereumChainId,\n  address: peggyContractAddress,\n  web3: web3 as any,\n})\n```\n\n- The snippet below instantiates a PeggyContract instance which can easily `estimateGas` and `sendTransaction` using the `web3` we provide to the contracts constructor. Its implementation can be found [here](https://github.com/InjectiveLabs/injective-ts/blob/master/packages/contracts/src/contracts/Peggy.ts). Obviously, this is just an example and you can use the web3 package directly + the ABI of the contract to instantiate the contract, and then handle the logic of signing and broadcasting the transaction using some web3 provider.\n\n\n### [Direct link to heading](https://docs.ts.injective.network/bridges/ethereum\\#from-injective-to-ethereum)    From Injective to Ethereum\n\nNow that you have the ERC20 version of INJ transferred over to Injective, the native `inj` denom on the Injective Chain is minted and it is the canonical version of the INJ token. To withdraw `inj` from Injective to Ethereum we have to prepare, sign and then broadcast a native Cosmos transaction on the Injective Chain.\n\nIf you are not familiar with how Transactions (and Messages) work on Cosmos you can find more information here. The Message we need to pack into a transaction to instruct Injective to withdraw funds from Injective to Ethereum is `MsgSendToEth`.\n\nWhen `MsgSendToEth` is called on the chain, some of the validators will pick up the transaction, batch multiple `MsgSendToEth` requests into one and: burn the assets being withdrawn on Injective, unlock these funds on the Peggy Smart Contract on Ethereum and send them to the respective address.\n\nThere is a bridgeFee included in these transactions to incentivize Validators to pick up and process your withdrawal requests faster. The bridgeFee is in the asset the user wants to withdraw to Ethereum (if you withdraw INJ you have to pay the bridgeFee in INJ as well).\n\nHere is an example implementation that prepares the transaction, uses a privateKey to sign it and finally, broadcasts it to Injective:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { getNetworkInfo, Network } from '@injectivelabs/networks'\nimport {\n  TxClient,\n  PrivateKey,\n  TxRestClient,\n  MsgSendToEth,\n  DEFAULT_STD_FEE,\n  ChainRestAuthApi,\n  createTransaction,\n} from '@injectivelabs/sdk-ts'\nimport { BigNumberInBase } from '@injectivelabs/utils'\n\n/** MsgSendToEth Example */\n;(async () => {\n  const network = getNetworkInfo(Network.Mainnet) // Gets the rpc/lcd endpoints\n  const privateKeyHash =\n    'f9db9bf330e23cb7839039e944adef6e9df447b90b503d5b4464c90bea9022f3'\n  const privateKey = PrivateKey.fromPrivateKey(privateKeyHash)\n  const injectiveAddress = privateKey.toBech32()\n  const ethAddress = privateKey.toHex()\n  const publicKey = privateKey.toPublicKey().toBase64()\n\n  /** Account Details **/\n  const accountDetails = await new ChainRestAuthApi(network.rest).fetchAccount(\n    injectiveAddress,\n  )\n\n  /** Prepare the Message */\n  const amount = {\n    amount: new BigNumberInBase(0.01).toWei().toFixed(),\n    denom: 'inj',\n  }\n  const bridgeFee = {\n    amount: new BigNumberInBase(0.01).toWei().toFixed(),\n    denom: 'inj',\n  }\n\n  const msg = MsgSendToEth.fromJSON({\n    amount,\n    bridgeFee,\n    injectiveAddress,\n    address: ethAddress,\n  })\n\n  /** Prepare the Transaction **/\n  const { signBytes, txRaw } = createTransaction({\n    message: msg,\n    fee: DEFAULT_STD_FEE,\n    pubKey: publicKey,\n    sequence: parseInt(accountDetails.account.base_account.sequence, 10),\n    accountNumber: parseInt(\n      accountDetails.account.base_account.account_number,\n      10,\n    ),\n    chainId: network.chainId,\n  })\n\n  /** Sign transaction */\n  const signature = await privateKey.sign(Buffer.from(signBytes))\n\n  /** Append Signatures */\n  txRaw.signatures = [signature]\n\n  /** Calculate hash of the transaction */\n  console.log(`Transaction Hash: ${TxClient.hash(txRaw)}`)\n\n  const txService = new TxRestClient(network.rest)\n\n  /** Simulate transaction */\n  const simulationResponse = await txService.simulate(txRaw)\n\n  console.log(\n    `Transaction simulation response: ${JSON.stringify(\n      simulationResponse.gasInfo,\n    )}`,\n  )\n\n  /** Broadcast transaction */\n  const txResponse = await txService.broadcast(txRaw)\n\n  if (txResponse.code !== 0) {\n    console.log(`Transaction failed: ${txResponse.rawLog}`)\n  } else {\n    console.log(\n      `Broadcasted transaction hash: ${JSON.stringify(txResponse.txhash)}`,\n    )\n  }\n})()\n```\n\n[PreviousGetting Started](https://docs.ts.injective.network/bridges/bridge) [NextIBC](https://docs.ts.injective.network/bridges/ibc)\n\nLast updated 9 months ago\n\n<|firecrawl-page-89-lllmstxt|>\n## IBC Bridges Overview\n                      \n\nThis wiki page is currently under work in progress.\n\n                      \n\n[PreviousEthereum](https://docs.ts.injective.network/bridges/ethereum) [NextWormhole](https://docs.ts.injective.network/bridges/wormhole)\n\nLast updated 1 year ago\n\n<|firecrawl-page-90-lllmstxt|>\n## Wormhole Bridge Overview\n                      \n\nThis wiki page is currently under work in progress.\n\n                      \n\n[PreviousIBC](https://docs.ts.injective.network/bridges/ibc) [NextGetting Started](https://docs.ts.injective.network/building-dapps/building-dapps)\n\nLast updated 1 year ago\n\n<|firecrawl-page-91-lllmstxt|>\n## Building DApps on Injective\nInjective is a Layer-1 blockchain built for finance. Injective offers developers out-of-the-box primitives for building decentralized financial applications in addition to an open and permissionless smart contracts layer providing advanced capabilities in building robust Web3 applications.\n\nInjective is natively interoperable with several well-known blockchain networks, including Ethereum, Solana, and all IBC-enabled cosmos chains like CosmosHub, Osmosis, etc. The interoperability not only allows Injective to enable users to bridge assets from multiple chains but also allows for transferring arbitrary data - like oracle prices, etc.\n\nWithin this section we are going to explore configuring different UI frameworks to work with the `@injectivelabs` packages so you can start building decentralized applications on top of Injective. We are also going to showcase example (simple) dApps built on top of Injective.\n\n* * *\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/building-dapps\\#create-injective-dapp-cli-tool)    Create Injective dApp CLI tool\n\nThe simplest way to start your journey on Injective is using our CLI tool. To do this, simply write this command and follow the instructions in your terminal!\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n$ npx @injectivelabs/create-injective-app\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/building-dapps\\#configuration)    Configuration\n\nTopic\n\nDescription\n\n[Configuring Nuxt](https://docs.ts.injective.network/building-dapps/configuring-nuxt)\n\nConfiguring Nuxt 3.x + Vite\n\n[Configuring React](https://docs.ts.injective.network/building-dapps/configuring-react)\n\nConfiguring React 18 + Vite\n\n* * *\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/building-dapps\\#dapps)    Dapps\n\nTopic\n\nDescription\n\n[DEX](https://docs.ts.injective.network/building-dapps/dapps-examples/dex)\n\nBuilding a decentralized exchange on top of Injective\n\n[Bridge](https://docs.ts.injective.network/building-dapps/dapps-examples/bridge)\n\nBuilding a simple bridge between Injective and Ethereum\n\n[Simple Smart Contract](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract)\n\nBuilding a simple smart contract app on top of Injective\n\n[PreviousWormhole](https://docs.ts.injective.network/bridges/wormhole) [NextConfiguring Nuxt](https://docs.ts.injective.network/building-dapps/configuring-nuxt)\n\nLast updated 5 months ago\n\n<|firecrawl-page-92-lllmstxt|>\n## Configuring Nuxt3 for DApps\n## [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-nuxt\\#nuxt3-the-intuitive-web-framework)    Nuxt3 - The Intuitive Web Framework\n\nThe preferred choice of UI framework to build decentralized applications on top of Injective at @InjectiveLabs is Nuxt3. We are going to help you configure Nuxt3 + the Vite builder with the `@injectivelabs` packages and some polyfills since you'll need them to interact with Crypto wallets.\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-nuxt\\#id-1.-installing-nuxt-3)    1\\. Installing Nuxt 3\n\nFollow the Getting Started guide at [Nuxt3 Docs](https://nuxt.com/docs/getting-started/installation) and setup your application.\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-nuxt\\#id-2.-installing-injectivelabs-packages)    2\\. Installing @injectivelabs packages\n\nYou can install the @injectivelabs packages using yarn.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n$ yarn add @injectivelabs/sdk-ts @injectivelabs/networks @injectivelabs/ts-types @injectivelabs/utils\n\n## If you need Wallet Connection\n$ yarn add @injectivelabs/wallet-strategy\n```\n\nThese are the most commonly used packages from the `injective-ts` monorepo.\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-nuxt\\#id-3.-configuring-nuxt-and-adding-polyfills)    3\\. Configuring Nuxt and adding polyfills\n\nFirst, add the needed polyfill packages\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n$ yarn add @bangjelkoski/node-stdlib-browser\n$ yarn add -D @bangjelkoski/vite-plugin-node-polyfills\n```\n\nMake sure you are using the `vue-tsc@1.8.8` , `nuxt@^3.8.1`, `typescript@^5.0.4` versions.\n\n**Buffer**\n\nOne of the main dependencies for any crypto-related decentralized application is Buffer. To make sure we add Buffer to our project, we can install it as a dependency and then make a Nuxt plugin to import it to the global/window object:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n$ yarn add buffer\n```\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename - plugins/buffer.client.ts\nexport default defineNuxtPlugin(() => {\n  import('buffer/').then((Buffer) => {\n    window.Buffer = window.Buffer || Buffer.default.Buffer\n    globalThis.Buffer = window.Buffer || Buffer.default.Buffer\n  })\n})\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-nuxt\\#id-4.-using-a-state-management)    4\\. Using a state management\n\nIf you are going to use `pinia` as state management, add it to your packages:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n$ yarn add @pinia/nuxt@^0.4.9\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-nuxt\\#id-5.-using-vueuse)    5\\. Using `vueuse`\n\nWe recommend adding `@vueuse/nuxt` as a dependency as it offers a lot of utility functions out of the box.\n\nThen, we need to configure the `tsconfig.json` if you are using TypeScript (recommended). You can reference the following `tsconfig.json` as a base.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n{\n  // https://nuxt.com/docs/guide/concepts/typescript\n  \"extends\": \"./.nuxt/tsconfig.json\",\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"module\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"types\": [\"@vueuse/nuxt\", \"@pinia/nuxt\"]\n  },\n  \"exclude\": [\"node_modules\", \"dist\", \".output\"]\n}\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-nuxt\\#id-6.-nuxt.config.ts-packages.json)    6\\. nuxt.config.ts / packages.json\n\nBefore we boot our application, we need to set everything up in the `nuxt.config.ts`, the main configuration point for every Nuxt 3 application. Let's see a reference `nuxt.config.ts` and explain every line using comments so it's easier for developers to understand.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename - nuxt.config.ts\nimport { nodePolyfills } from '@bangjelkoski/vite-plugin-node-polyfills'\nimport tsconfigPaths from 'vite-tsconfig-paths'\n\nexport default defineNuxtConfig({\n  ssr: false, // whether to pre-render your application\n  modules: [\\\n    // nuxtjs modules\\\n    '@pinia/nuxt',\\\n    '@vueuse/nuxt',\\\n  ],\n\n  typescript: {\n    typeCheck: 'build', // we recommend build so you do typescript checks only on build type\n  },\n\n  imports: {\n    // automatic imports of store definitions (if you use pinia)\n    dirs: ['store/**'],\n  },\n\n  pinia: {\n    // import pinia definitions\n    autoImports: ['defineStore'],\n  },\n\n  plugins: [\\\n    {\\\n      // import the buffer plugin we've made\\\n      src: './plugins/buffer.client.ts',\\\n      ssr: false,\\\n    },\\\n  ],\n\n  // We generate only sitemaps for the client side as we don't need a server\n  // Note: there is a problem with sitemaps for Vite + Nuxt3\n  // as usual is that it takes too much time/memory to generate\n  // sitemaps and the build process can fail\n  // on Github Actions/Netlify/Vercel/etc so we have to use another\n  // strategy like generating them locally and pushing them to services like\n  // busgnag\n  sourcemap: {\n    server: false,\n    client: true,\n  },\n\n  // Vite related config\n  vite: {\n    plugins: [\\\n      // setting up node + crypto polyfils + vite TS path resolution\\\n      tsconfigPaths(),\\\n      nodePolyfills({ protocolImports: false }),\\\n    ],\n\n    build: {\n      sourcemap: false, // we don't generate\n\n      // default rollup options\n      rollupOptions: {\n        cache: false,\n        output: {\n          manualChunks: (id: string) => {\n            //\n          },\n        },\n      },\n    },\n\n    // needed for some Vite related issue for the\n    // @bangjelkoski/vite-plugin-node-polyfills plugin\n    optimizeDeps: {\n      exclude: ['fsevents'],\n    },\n  },\n})\n```\n\nThere is one optimization that you can to decrease the bundle size - add these resolutions in the `packages.json`\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n\"resolutions\": {\n  \"@ethereumjs/tx\": \"^4.1.1\",\n  \"**/libsodium\": \"npm:@bangjelkoski/noop\",\n  \"**/libsodium-wrappers\": \"npm:@bangjelkoski/noop\"\n}\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-nuxt\\#id-7.-booting-our-app)    7\\. Booting our app\n\nFinally, you can start your app locally using `yarn dev` or generate static pages using `yarn generate` which you can deploy to any static page hosting like Netlify, Vercel, etc.\n\n[PreviousGetting Started](https://docs.ts.injective.network/building-dapps/building-dapps) [NextConfiguring React](https://docs.ts.injective.network/building-dapps/configuring-react)\n\nLast updated 11 days ago\n\n<|firecrawl-page-93-lllmstxt|>\n## Configuring React for DApps\n## [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-react\\#react-library-for-building-user-interfaces)    React - Library for building user interfaces\n\nReact is currently one of the most popular UI Frameworks. We are going to help you configure React + the Vite builder with the `@injectivelabs` packages and some polyfills since you'll need them to interact with Crypto wallets.\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-react\\#id-1.-installing-react)    1\\. Installing React\n\nFollow the Getting Started guide at [Vite Docs](https://vitejs.dev/guide/) and setup your application.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n$ npm create vite@latest\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-react\\#id-2.-installing-injectivelabs-packages)    2\\. Installing @injectivelabs packages\n\nYou can install the @injectivelabs packages using yarn.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n$ yarn add @injectivelabs/sdk-ts @injectivelabs/networks @injectivelabs/ts-types @injectivelabs/utils\n\n## If you need Wallet Connection\n$ yarn add @injectivelabs/wallet-strategy\n```\n\nThese are the most commonly used packages from the `injective-ts` monorepo.\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-react\\#id-3.-configuring-vite-and-adding-polyfills)    3\\. Configuring Vite and adding polyfills\n\nFirst, add the needed polyfill packages\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n$ yarn add @bangjelkoski/vite-plugin-node-polyfills\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-react\\#id-4.-using-a-state-management)    4\\. Using a state management\n\nReact has a lot of different state managers, pick the one you are going to use and install it. You can use the build in `Context API` for state management without the need to install a third-party solution. The preferred third-party state managers are `Redux` and `Zustand`.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n$ yarn add zustand\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-react\\#id-5.-vite.config.ts)    5\\. vite.config.ts\n\nThe last step is to configure Vite to use the `node-polyfills` that we installed earlier.\n\nOpen up `vite.config.ts` and add `node-polyfills` inside the `plugins` array.\n\nYour config should look like this:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react-swc\";\nimport { nodePolyfills } from \"@bangjelkoski/vite-plugin-node-polyfills\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react(), nodePolyfills({ protocolImports: true })],\n});\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/configuring-react\\#id-8.-booting-our-app)    8\\. Booting our app\n\nFinally, you can start your app locally using `yarn dev` or build for production using `yarn build` which you can deploy to any static page hosting like Netlify, Vercel, etc.\n\n[PreviousConfiguring Nuxt](https://docs.ts.injective.network/building-dapps/configuring-nuxt) [NextdApps Examples](https://docs.ts.injective.network/building-dapps/dapps-examples)\n\nLast updated 11 days ago\n\n<|firecrawl-page-94-lllmstxt|>\n## Injective dApps Examples\nHere you can find some dApps examples built on top of Injective.\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples\\#dapps)    Dapps\n\nTopic\n\nDescription\n\n[DEX](https://docs.ts.injective.network/building-dapps/dapps-examples/dex)\n\nBuilding a decentralized exchange on top of Injective\n\n[Bridge](https://docs.ts.injective.network/building-dapps/dapps-examples/bridge)\n\nBuilding a simple bridge between Injective and Ethereum\n\n[Simple Smart Contract](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract)\n\nBuilding a simple smart contract app on top of Injective\n\n[PreviousConfiguring React](https://docs.ts.injective.network/building-dapps/configuring-react) [NextSmart Contract](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract)\n\nLast updated 1 year ago\n\n<|firecrawl-page-95-lllmstxt|>\n## Building dApps on Injective\nWithin these short series we are going to showcase how easy it is to build a dApp on top of Injective. There is an open-sourced [dApp](https://github.com/InjectiveLabs/injective-simple-sc-counter-ui) which everyone can reference and use to build on top of Injective. There are examples for Next, Nuxt and Vanilla Js. For those who want to start from scratch, this is the right place to start.\n\nIn this example we will implement the connection and interact with an example Smart Contract deployed on the Injective Chain using the injective-ts module.\n\nThe series will include:\n\n- Setting up the API clients and environment,\n\n- Connecting to the Chain and the Indexer API,\n\n- Connect to a user wallet and get their address,\n\n- Querying the smart contract ( in this case fetching the current count of the smart contract ),\n\n- Modifying the state of the contract ( in this case incrementing the count by 1, or setting it to a specific value),\n\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract\\#setup)    Setup\n\nFirst, configure your desired UI framework. You can find more details on the configuration here.\n\nTo get started with the dex, we need to setup the API clients and the environment. To build our DEX we are going to query data from both the Injective Chain and the Indexer API. In this example, we are going to use the existing **testnet** environment.\n\nLet's first setup some of the classes we need to query the data.\n\nFor interacting with the smart contract, we are going to use `ChainGrpcWasmApi` from `@injectivelabs/sdk-ts`. Also we will need the Network Endpoints we are going to use (Mainnet or Testnet), which we can find in `@injectivelabs/networks`\n\nExample:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n//filename: services.ts\nimport { ChainGrpcWasmApi } from '@injectivelabs/sdk-ts'\nimport { Network, getNetworkEndpoints } from '@injectivelabs/networks'\n\nexport const NETWORK = Network.Testnet\nexport const ENDPOINTS = getNetworkEndpoints(NETWORK)\n\nexport const chainGrpcWasmApi = new ChainGrpcWasmApi(ENDPOINTS.grpc)\n```\n\nThen, we also need to setup a wallet connection to allow the user to connect to our DEX and start signing transactions. To make this happen we are going to use our `@injectivelabs/wallet-strategy` package which allows users to connect with a various of different wallet providers and use them to sign transactions on Injective.\n\nThe main purpose of the `@injectivelabs/wallet-strategy` is to offer developers a way to have different wallet implementations on Injective. All of these wallets implementations are exposing the same `ConcreteStrategy` interface which means that users can just use these methods without the need to know the underlying implementation for specific wallets as they are abstracted away.\n\nTo start, you have to make an instance of the WalletStrategy class which gives you the ability to use different wallets out of the box. You can switch the current wallet that is used by using the `setWallet` method on the walletStrategy instance. The default is `Metamask`.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename: wallet.ts\nimport { WalletStrategy } from '@injectivelabs/wallet-strategy'\nimport { Web3Exception } from '@injectivelabs/exceptions'\n\n// These imports are from .env\nimport {\n  CHAIN_ID,\n  ETHEREUM_CHAIN_ID,\n  IS_TESTNET,\n  alchemyRpcEndpoint,\n  alchemyWsRpcEndpoint,\n} from '/constants'\n\nexport const walletStrategy = new WalletStrategy({\n  chainId: CHAIN_ID,\n  ethereumOptions: {\n    ethereumChainId: ETHEREUM_CHAIN_ID,\n    wsRpcUrl: alchemyWsRpcEndpoint,\n    rpcUrl: alchemyRpcEndpoint,\n  },\n})\n```\n\nIf we don't want to use Ethereum native wallets, just omit the `ethereumOptions` within the `WalletStrategy` constructor.\n\nFinally, to do the whole transaction flow (prepare + sign + broadcast) on Injective we are going to use the MsgBroadcaster class.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { Network } from '@injectivelabs/networks'\nexport const NETWORK = Network.Testnet\n\nexport const msgBroadcastClient = new MsgBroadcaster({\n  walletStrategy,\n  network: NETWORK,\n})\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract\\#connect-to-the-users-wallet)    Connect to the user's wallet\n\nSince we are using the `WalletStrategy` to handle the connection with the user's wallet, we can use its methods to handle some use cases like getting the user's addresses, sign/broadcast a transaction, etc. To find out more about the wallet strategy, you can explore the documentation interface and the method the `WalletStrategy` offers.\n\nNote: We can switch between the \"active\" wallet within the `WalletStrategy` using the `setWallet` method.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename: WalletConnection.ts\nimport {\n  WalletException,\n  UnspecifiedErrorCode,\n  ErrorType,\n} from '@injectivelabs/exceptions'\nimport { Wallet } from '@injectivelabs/wallet-base'\nimport { walletStrategy } from './Wallet.ts'\n\nexport const getAddresses = async (wallet: Wallet): Promise<string[]> => {\n  walletStrategy.setWallet(wallet)\n\n  const addresses = await walletStrategy.getAddresses()\n\n  if (addresses.length === 0) {\n    throw new WalletException(\n      new Error('There are no addresses linked in this wallet.'),\n      {\n        code: UnspecifiedErrorCode,\n        type: ErrorType.WalletError,\n      },\n    )\n  }\n\n  if (!addresses.every((address) => !!address)) {\n    throw new WalletException(\n      new Error('There are no addresses linked in this wallet.'),\n      {\n        code: UnspecifiedErrorCode,\n        type: ErrorType.WalletError,\n      },\n    )\n  }\n\n  // If we are using Ethereum native wallets the 'addresses' are the hex addresses\n  // If we are using Cosmos native wallets the 'addresses' are bech32 injective addresses,\n  return addresses\n}\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract\\#querying)    Querying\n\nAfter the initial setup is done, let's see how to query the smart contract to get the current count using the chainGrpcWasmApi service we created earlier, and calling get\\_count on the Smart Contract.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nfunction getCount() {\n  const response = (await chainGrpcWasmApi.fetchSmartContractState(\n    COUNTER_CONTRACT_ADDRESS, // The address of the contract\n    toBase64({ get_count: {} }), // We need to convert our query to Base64\n  )) as { data: string }\n\n  const { count } = fromBase64(response.data) as { count: number } // we need to convert the response from Base64\n\n  return count // return the current counter value.\n}\n```\n\nOnce we have these functions ( `getCount` or others we create) we can call them anywhere in our application (usually the centralized state management services like Pinia in Nuxt, or Context providers in React, etc).\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract\\#modifying-the-state)    Modifying the State\n\nNext we will modify the `count` state. We can do that by sending messages to the chain using the `Broadcast Client` we created earlier and `MsgExecuteContractCompat` from `@injectivelabs/sdk-ts`\n\nThe Smart Contract we use for this example has 2 methods for altering the state:\n\n- `increment`\n\n- `reset`\n\n\n`increment` increment the count by 1, and `reset` sets the count to a given value. Note that `reset` can only be called if you are the creator of the smart contract.\n\nWhen we call these functions, our wallet opens up to sign the message/transaction and broadcasts it.\n\nLets first see how to increment the count.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// Preparing the message\n\nconst msg = MsgExecuteContractCompat.fromJSON({\n  contractAddress: COUNTER_CONTRACT_ADDRESS,\n  sender: injectiveAddress,\n  msg: {\n    increment: {}, // we pass an empty object if the method doesn't have parameters\n  },\n})\n\n// Signing and broadcasting the message\n\nconst response = await msgBroadcastClient.broadcast({\n  msgs: msg, // we can pass multiple messages here using an array. ex: [msg1,msg2]\n  injectiveAddress: injectiveAddress,\n})\n\nconsole.log(response)\n```\n\nNow, lets see an example of how to set the counter to a specific value. Note that in this Smart Contract the count can be set to specific value only by the creator of the Smart Contract.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// Preparing the message\n\nconst msg = MsgExecuteContractCompat.fromJSON({\n  contractAddress: COUNTER_CONTRACT_ADDRESS,\n  sender: injectiveAddress,\n  msg: {\n    reset: {\n      count: parseInt(number, 10), // we are parsing the number variable here because usually it comes from an input which always gives a string, and we need to pass a number instead.\n    },\n  },\n})\n\n// Signing and broadcasting the message\n\nconst response = await msgBroadcastClient.broadcast({\n  msgs: msg,\n  injectiveAddress: injectiveAddress,\n})\n\nconsole.log(response)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract\\#full-example)    Full example\n\nNow lets see a full example of this in Vanilla JS (You can find examples for specific frameworks like Nuxt And Next [HERE](https://github.com/InjectiveLabs/injective-simple-sc-counter-ui))\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nimport { ChainGrpcWasmApi, getInjectiveAddress } from \"@injectivelabs/sdk-ts\";\nimport { Network, getNetworkEndpoints } from \"@injectivelabs/networks\";\nimport { WalletStrategy } from \"@injectivelabs/wallet-strategy\";\nimport { Web3Exception } from \"@injectivelabs/exceptions\";\n\n// These imports are from .env\nimport {\n  CHAIN_ID,\n  ETHEREUM_CHAIN_ID,\n  IS_TESTNET,\n  alchemyRpcEndpoint,\n  alchemyWsRpcEndpoint,\n} from \"/constants\";\n\nconst NETWORK = Network.Testnet;\nconst ENDPOINTS = getNetworkEndpoints(NETWORK);\n\nconst chainGrpcWasmApi = new ChainGrpcWasmApi(ENDPOINTS.grpc);\n\nconst walletStrategy = new WalletStrategy({\n  chainId: CHAIN_ID,\n  ethereumOptions: {\n    ethereumChainId: ETHEREUM_CHAIN_ID,\n    wsRpcUrl: alchemyWsRpcEndpoint,\n    rpcUrl: alchemyRpcEndpoint,\n  },\n});\n\nexport const getAddresses = async (): Promise<string[]> => {\n  const addresses = await walletStrategy.getAddresses();\n\n  if (addresses.length === 0) {\n    throw new Web3Exception(\n      new Error(\"There are no addresses linked in this wallet.\")\n    );\n  }\n\n  return addresses;\n};\n\nconst msgBroadcastClient = new MsgBroadcaster({\n  walletStrategy,\n  network: NETWORK,\n});\n\nconst [address] = await getAddresses();\nconst injectiveAddress = getInjectiveAddress(getInjectiveAddress);\n\nasync function fetchCount() {\n  const response = (await chainGrpcWasmApi.fetchSmartContractState(\n    COUNTER_CONTRACT_ADDRESS, // The address of the contract\n      toBase64({ get_count: {} }) // We need to convert our query to Base64\n    )) as { data: string };\n\n  const { count } = fromBase64(response.data) as { count: number }; // we need to convert the response from Base64\n\n  console.log(count)\n}\n\nasync function increment(){\n    const msg = MsgExecuteContractCompat.fromJSON({\n    contractAddress: COUNTER_CONTRACT_ADDRESS,\n    sender: injectiveAddress,\n    msg: {\n        increment: {},\n        },\n    });\n\n    // Signing and broadcasting the message\n\n    await msgBroadcastClient.broadcast({\n        msgs: msg,\n        injectiveAddress: injectiveAddress,\n    });\n}\n\nasync function main() {\n    await fetchCount() // this will log: {count: 5}\n    await increment() // this opens up your wallet to sign the transaction and broadcast it\n    await fetchCount() // the count now is 6. log: {count: 6}\n}\n\nmain()\n\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract\\#final-thoughts)    Final Thoughts\n\nWhat's left for you is to build a nice UI around the business logic explained above :)\n\n[PreviousdApps Examples](https://docs.ts.injective.network/building-dapps/dapps-examples) [NextDEX](https://docs.ts.injective.network/building-dapps/dapps-examples/dex)\n\nLast updated 10 days ago\n\n<|firecrawl-page-96-lllmstxt|>\n## Build a DEX\nWithin these short series we are going to showcase how easy it is to build a DEX on top of Injective. There is an open-sourced [DEX](https://github.com/InjectiveLabs/injective-dex) which everyone can reference and use to build on top of Injective. For those who want to start from scratch, this is the right place to start.\n\nThe series will include:\n\n- Setting up the API clients and environment,\n\n- Connecting to the Chain and the Indexer API,\n\n- Connect to a user wallet and get their address,\n\n- Fetching Spot and Derivative markets and their orderbooks,\n\n- Placing market orders on both spot and a derivative market,\n\n- View all positions for an Injective address.\n\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/dex\\#setup)    Setup\n\nFirst, configure your desired UI framework. You can find more details on the configuration here.\n\nTo get started with the dex, we need to setup the API clients and the environment. To build our DEX we are going to query data from both the Injective Chain and the Indexer API. In this example, we are going to use the existing **testnet** environment.\n\nLet's first setup some of the classes we need to query the data.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename: Services.ts\nimport {\n  ChainGrpcBankApi,\n  IndexerGrpcSpotApi,\n  IndexerGrpcDerivativesApi,\n} from '@injectivelabs/sdk-ts'\nimport { getNetworkEndpoints, Network } from '@injectivelabs/networks'\n\n// Getting the pre-defined endpoints for the Testnet environment\n// (using TestnetK8s here because we want to use the Kubernetes infra)\nexport const NETWORK = Network.Testnet\nexport const ENDPOINTS = getNetworkEndpoints(NETWORK)\n\nexport const chainBankApi = new ChainGrpcBankApi(ENDPOINTS.grpc)\nexport const indexerSpotApi = new IndexerGrpcSpotApi(ENDPOINTS.indexer)\nexport const indexerDerivativesApi = new IndexerGrpcDerivativesApi(\n  ENDPOINTS.indexer,\n)\n\nexport const indexerSpotStream = new IndexerGrpcDerivativeStream(\n  ENDPOINTS.indexer,\n)\nexport const indexerDerivativeStream = new IndexerGrpcDerivativeStream(\n  ENDPOINTS.indexer,\n)\n```\n\nThen, we also need to setup a wallet connection to allow the user to connect to our DEX and start signing transactions. To make this happen we are going to use our `@injectivelabs/wallet-strategy` package which allows users to connect with a various of different wallet providers and use them to sign transactions on Injective.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename: Wallet.ts\nimport { Wallet } from '@injectivelabs/wallet-base'\nimport { WalletStrategy } from '@injectivelabs/wallet-strategy'\nimport { ChainId, EthereumChainId } from '@injectivelabs/ts-types'\n\nconst chainId = ChainId.Testnet // The Injective Chain chainId\nconst ethereumChainId = EthereumChainId.Goerli // The Ethereum Chain ID\n\nexport const alchemyRpcEndpoint = `https://eth-goerli.alchemyapi.io/v2/${process.env.APP_ALCHEMY_GOERLI_KEY}`\n\nexport const walletStrategy = new WalletStrategy({\n  chainId: CHAIN_ID,\n  ethereumOptions: {\n    rpcUrl: alchemyRpcEndpoint,\n    ethereumChainId: ETHEREUM_CHAIN_ID,\n  },\n})\n```\n\nIf we don't want to use Ethereum native wallets, just omit the `ethereumOptions` within the `WalletStrategy` constructor.\n\nFinally, to do the whole transaction flow (prepare + sign + broadcast) on Injective we are going to use the MsgBroadcaster class.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename: MsgBroadcaster.ts\nimport { Wallet } from '@injectivelabs/wallet-base'\nimport { BaseWalletStrategy, MsgBroadcaster } from '@injectivelabs/wallet-core'\nimport { MetamaskStrategy } from '@injectivelabs/wallet-evm'\n\nconst strategyArgs: WalletStrategyArguments = {} /** define the args */\nconst strategyEthArgs: ConcreteEthereumWalletStrategyArgs = {} /** if the wallet is an Ethereum wallet */\nconst strategies = {\n  [Wallet.Metamask]: new MetamaskStrategy(strategyEthArgs)\n}\n\nexport const walletStrategy = new BaseWalletStrategy({...strategyArgs, strategies})\n\nconst broadcasterArgs: MsgBroadcasterOptions = {} /** define the broadcaster args */\nexport const msgBroadcaster = new MsgBroadcaster({...broadcasterArgs, walletStrategy})\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/dex\\#connect-to-the-users-wallet)    Connect to the user's wallet\n\nSince we are using the `WalletStrategy` to handle the connection with the user's wallet, we can use its methods to handle some use cases like getting the user's addresses, sign/broadcast a transaction, etc. To find out more about the wallet strategy, you can explore the documentation interface and the method the `WalletStrategy` offers.\n\nNote: We can switch between the \"active\" wallet within the `WalletStrategy` using the `setWallet` method.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename: WalletConnection.ts\nimport {\n  WalletException,\n  UnspecifiedErrorCode,\n  ErrorType,\n} from '@injectivelabs/exceptions'\nimport { Wallet } from '@injectivelabs/wallet-base'\nimport { walletStrategy } from './Wallet.ts'\n\nexport const getAddresses = async (wallet: Wallet): Promise<string[]> => {\n  walletStrategy.setWallet(wallet)\n\n  const addresses = await walletStrategy.getAddresses()\n\n  if (addresses.length === 0) {\n    throw new WalletException(\n      new Error('There are no addresses linked in this wallet.'),\n      {\n        code: UnspecifiedErrorCode,\n        type: ErrorType.WalletError,\n      },\n    )\n  }\n\n  if (!addresses.every((address) => !!address)) {\n    throw new WalletException(\n      new Error('There are no addresses linked in this wallet.'),\n      {\n        code: UnspecifiedErrorCode,\n        type: ErrorType.WalletError,\n      },\n    )\n  }\n\n  // If we are using Ethereum native wallets the 'addresses' are the hex addresses\n  // If we are using Cosmos native wallets the 'addresses' are bech32 injective addresses,\n  return addresses\n}\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/dex\\#querying)    Querying\n\nAfter the initial setup is done, let's see how to query (and stream) markets from the IndexerAPI, as well as user's balances from the chain directly.\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename: Query.ts\nimport  { getDefaultSubaccountId, OrderbookWithSequence } from '@injectivelabs/sdk-ts'\nimport {\n  chainBankApi,\n  indexerSpotApi,\n  indexerSpotStream,\n  indexerDerivativesApi\n  indexerDerivativesStream,\n} from './Services.ts'\n\nexport const fetchDerivativeMarkets = async () => {\n  return await indexerDerivativesApi.fetchMarkets()\n}\n\nexport const fetchPositions = async (injectiveAddress: string) => {\n  const subaccountId = getDefaultSubaccountId(injectiveAddress)\n\n  return await indexerDerivativesApi.fetchPositions({ subaccountId })\n}\n\nexport const fetchSpotMarkets = async () => {\n  return await indexerSpotsApi.fetchMarkets()\n}\n\nexport const fetchBankBalances = async (injectiveAddress: string) => {\n  return await chainBankApi.fetchBalances(injectiveAddress)\n}\n\nexport const streamDerivativeMarketOrderbook = async (\n  marketId: string,\n  ) => {\n  const streamOrderbookUpdates = indexerDerivativesStream.streamDerivativeOrderbookUpdate.bind(indexerDerivativesStream)\n  const callback = (orderbookUpdate) => {\n    console.log(orderbookUpdate)\n  }\n\n  streamOrderbookUpdates({\n    marketIds,\n    callback\n  })\n}\n\nexport const streamSpotMarketOrderbook = async (\n  marketId: string,\n  ) => {\n  const streamOrderbookUpdates = indexerSpotsStream.streamSpotOrderbookUpdate.bind(indexerSpotsStream)\n  const callback = (orderbookUpdate) => {\n    console.log(orderbookUpdate)\n  }\n\n  streamOrderbookUpdates({\n    marketIds,\n    callback\n  })\n}\n```\n\nOnce we have these functions we can call them anywhere in our application (usually the centralized state management services like Pinia in Nuxt, or Context providers in React, etc).\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/dex\\#transactions)    Transactions\n\nFinally, let's make some transactions. For this example, we are going to:\n\n1. Send assets from one address to another,\n\n2. Make a spot limit order,\n\n3. Make a derivative market order.\n\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\n// filename: Transactions.ts\nimport { BigNumberInWei } from '@injectivelabs/utils'\nimport {\n  MsgSend,\n  MsgCreateSpotLimitOrder,\n  spotPriceToChainPriceToFixed,\n  MsgCreateDerivativeMarketOrder,\n  spotQuantityToChainQuantityToFixed\n} from '@injectivelabs/sdk-ts'\n\n// used to send assets from one address to another\nexport const makeMsgSend = ({\n  sender: string,\n  recipient: string,\n  amount: string, // human readable amount\n  denom: string\n}) => {\n  const amount = {\n    denom,\n    amount: new BigNumberInBase(amount).toWei(/** denom's decimals */)\n  }\n\n  return MsgSend.fromJSON({\n    amount,\n    srcInjectiveAddress: sender,\n    dstInjectiveAddress: recipient,\n  })\n}\n\n// used to create a spot limit order\nexport const makeMsgCreateSpotLimitOrder = ({\n  price, // human readable number\n  quantity, // human readable number\n  orderType, // OrderType enum\n  injectiveAddress,\n}) => {\n  const subaccountId = getDefaultSubaccountId(injectiveAddress)\n  const market = {\n    marketId: '0x...',\n    baseDecimals: 18,\n    quoteDecimals: 6,\n    minPriceTickSize: '', /* fetched from the chain */\n    minQuantityTickSize: '', /* fetched from the chain */\n    priceTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n    quantityTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n  }\n\n  return MsgCreateSpotLimitOrder.fromJSON({\n    subaccountId,\n    injectiveAddress,\n    orderType: orderType,\n    price: spotPriceToChainPriceToFixed({\n      value: price,\n      tensMultiplier: market.priceTensMultiplier,\n      baseDecimals: market.baseDecimals,\n      quoteDecimals: market.quoteDecimals\n    }),\n    quantity: spotQuantityToChainQuantityToFixed({\n      value: quantity,\n      tensMultiplier: market.quantityTensMultiplier,\n      baseDecimals: market.baseDecimals\n    }),\n    marketId: market.marketId,\n    feeRecipient: injectiveAddress,\n  })\n}\n\n// used to create a derivative market order\nexport const makeMsgCreateDerivativeMarketOrder = ({\n  price, // human readable number\n  margin, // human readable number\n  quantity, // human readable number\n  orderType, // OrderType enum\n  injectiveAddress,\n}) => {\n  const subaccountId = getDefaultSubaccountId(injectiveAddress)\n  const market = {\n    marketId: '0x...',\n    baseDecimals: 18,\n    quoteDecimals: 6,\n    minPriceTickSize: '', /* fetched from the chain */\n    minQuantityTickSize: '', /* fetched from the chain */\n    priceTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n    quantityTensMultiplier: '', /** can be fetched from getDerivativeMarketTensMultiplier */\n  }\n\n  return MsgCreateDerivativeMarketOrder.fromJSON(\n    orderType: orderPrice,\n    triggerPrice: '0',\n    injectiveAddress,\n    price: derivativePriceToChainPriceToFixed({\n      value: order.price,\n      tensMultiplier: market.priceTensMultiplier,\n      quoteDecimals: market.quoteDecimals\n    }),\n    quantity: derivativeQuantityToChainQuantityToFixed({\n      value: order.quantity,\n      tensMultiplier: market.quantityTensMultiplier,\n    }),\n    margin: derivativeMarginToChainMarginToFixed({\n      value: order.margin,\n      quoteDecimals: market.quoteDecimals,\n      tensMultiplier: priceTensMultiplier,\n    }),\n    marketId: market.marketId,\n    feeRecipient: feeRecipient,\n    subaccountId: subaccountI\n  })\n\n}\n```\n\nAfter we have the Messages, you can use the `msgBroadcaster` client to broadcast these transactions:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nconst response = await msgBroadcaster({\n  msgs: /** the message here */,\n  injectiveAddress: signersInjectiveAddress,\n})\n\nconsole.log(response)\n```\n\n### [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/dex\\#final-thoughts)    Final Thoughts\n\nWhat's left for you is to build a nice UI around the business logic explained above :)\n\n[PreviousSmart Contract](https://docs.ts.injective.network/building-dapps/dapps-examples/smart-contract) [NextBridge](https://docs.ts.injective.network/building-dapps/dapps-examples/bridge)\n\nLast updated 11 days ago\n\n<|firecrawl-page-97-lllmstxt|>\n## DApps Examples\n                      \n\nThis wiki page is currently under work in progress.\n\n                      \n\n[PreviousDEX](https://docs.ts.injective.network/building-dapps/dapps-examples/dex) [NextSimple HTML example with Webpack](https://docs.ts.injective.network/building-dapps/dapps-examples/simple-html-example-with-webpack)\n\nLast updated 5 months ago\n\n<|firecrawl-page-98-lllmstxt|>\n## Simple HTML Example\nThe [example](https://github.com/InjectiveLabs/injective-ts-webpack-example) is based on the [Cosmos transaction handling section](https://docs.ts.injective.network/transactions/transactions-cosmos).\n\n## [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/simple-html-example-with-webpack\\#running-the-example)    Running the example\n\nClone the project repo:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\ngit clone https://github.com/InjectiveLabs/injective-ts-webpack-example.git\n```\n\nEnsure you have npm installed and install dependencies:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\ncd injective-ts-webpack-example && npm install\n```\n\nRun the example:\n\nCopy\n\n```inline-grid min-w-full grid-cols-[auto_1fr] p-2 [count-reset:line]\nnpm start\n....\n<i> [webpack-dev-server] Project is running at:\n<i> [webpack-dev-server] Loopback: http://localhost:8080/, http://[::1]:8080/\n....\n```\n\nGo to the http://localhost:8080/ in your browser. If you have a Kelr wallet set up and connected to the Injective testnet, you should see \"Confirm Transaction\" pop up window.\n\n## [Direct link to heading](https://docs.ts.injective.network/building-dapps/dapps-examples/simple-html-example-with-webpack\\#how-does-it-work)    How does it work?\n\nTransaction logic is in the `src/sendTx.tx`, which is loaded by `src/index.html` Webpack is used to put eveything together and serve on the local server endpoint.\n\nThe `webpack.config.js` file configures Webpack to bundle a TypeScript application starting from `./src/sendTx.ts`, using `ts-loader` to transpile TypeScript files, and includes rules to handle `.js` and `.json` files appropriately. It resolves browser-compatible versions of Node.js core modules using the `fallback` option, enabling modules like `buffer`, `crypto`, and `stream` in the browser environment. The configuration utilizes `HtmlWebpackPlugin` to generate an HTML file based on `src/index.html`, and `ProvidePlugin` to automatically load `Buffer` and `process` variables globally. The bundled output is named `bundle.js` and placed in the `dist` directory, and the `devServer` is set up to serve content from `./dist` for development purposes.\n\n[PreviousBridge](https://docs.ts.injective.network/building-dapps/dapps-examples/bridge)\n\nLast updated 4 months ago\n\n"
    }
  ]